
/**
 * Client
**/

import * as runtime from './runtime/index';
declare const prisma: unique symbol
export type PrismaPromise<A> = Promise<A> & {[prisma]: true}
type UnwrapPromise<P extends any> = P extends Promise<infer R> ? R : P
type UnwrapTuple<Tuple extends readonly unknown[]> = {
  [K in keyof Tuple]: K extends `${number}` ? Tuple[K] extends PrismaPromise<infer X> ? X : UnwrapPromise<Tuple[K]> : UnwrapPromise<Tuple[K]>
};


/**
 * Model ActionRole
 * 
 */
export type ActionRole = {
  action_role_id: string
  controller_path: string | null
  action_user: UserAction
  role: UserRole
  is_can: boolean
  is_company: boolean
  parent_id: string | null
  created_at: Date
  updated_at: Date
  created_by: string | null
  updated_by: string | null
}

/**
 * Model Customer
 * 
 */
export type Customer = {
  customer_id: string
  first_name: string
  last_name: string
  first_name_kana: string
  last_name_kana: string
  gender: Gender | null
  birth_date: Date | null
  spouse: Prisma.JsonValue | null
  family_size: number | null
  email: string | null
  mobile: string | null
  phone: string | null
  profile_image: string | null
  cv_file: string | null
  resume_file: string | null
  prefecture: Prisma.JsonValue | null
  post_code: string | null
  city: string | null
  district: string | null
  address: string | null
  address1: string | null
  nearest_station: string | null
  socials: Prisma.JsonValue | null
  country: string | null
  experienced_year: number | null
  from_data: number | null
  status_customer: CustomerStatus | null
  created_at: Date
  updated_at: Date
  created_by: string | null
  updated_by: string | null
}

/**
 * Model CustomerDesired
 * 
 */
export type CustomerDesired = {
  desired_id: string
  customer_id: string | null
  occupation: Prisma.JsonValue[]
  industry: Prisma.JsonValue[]
  location: Prisma.JsonValue[]
  career_level: Prisma.JsonValue[]
  contract_type: Prisma.JsonValue[]
  desired_company: Prisma.JsonValue[]
  time_to: string
  annual_income: number
  created_at: Date
  updated_at: Date
  created_by: string | null
  updated_by: string | null
}

/**
 * Model CustomerEducation
 * 
 */
export type CustomerEducation = {
  education_id: string
  customer_id: string | null
  country: string | null
  degree: Prisma.JsonValue | null
  entrollment_date: Date | null
  graduate_date: Date | null
  is_current: boolean | null
  school_id: number | null
  school: Prisma.JsonValue | null
  faculty: string | null
  department: string | null
  created_at: Date
  updated_at: Date
  created_by: string | null
  updated_by: string | null
}

/**
 * Model CustomerExperience
 * 
 */
export type CustomerExperience = {
  experience_id: string
  jobdetail_id: string
  skill_id: number
  over_year: number | null
  created_at: Date
  updated_at: Date | null
  created_by: string | null
  updated_by: string | null
}

/**
 * Model CustomerJobDetail
 * Cutomer's one to one
 */
export type CustomerJobDetail = {
  jobdetail_id: string
  customer_id: string | null
  experienced_company: number
  annual_income: number | null
  has_management_exp: boolean
  created_at: Date
  updated_at: Date
  created_by: string | null
  updated_by: string | null
}

/**
 * Model CustomerLanguage
 * 
 */
export type CustomerLanguage = {
  language_id: string
  customer_id: string
  level: LanguageLevel | null
  language: number | null
  is_motherlanguage: boolean
  certificate: Prisma.JsonValue | null
  created_at: Date
  updated_at: Date | null
  created_by: string | null
  updated_b: string | null
}

/**
 * Model CustomerQualification
 * 
 */
export type CustomerQualification = {
  qualification_id: string
  customer_id: string
  qualification: Prisma.JsonValue | null
  created_at: Date
  updated_at: Date
  created_by: string | null
  updated_by: string | null
}

/**
 * Model CustomerVisa
 * 
 */
export type CustomerVisa = {
  visa_id: string
  customer_id: string
  status_visa: StatusVisa | null
  date_expire: Date | null
  country_citizenship: string | null
  back_visafile: string | null
  front_visafile: string | null
  created_at: Date
  updated_at: Date
  created_by: string | null
  updated_by: string | null
}

/**
 * Model CustomerWorkHistory
 * 
 */
export type CustomerWorkHistory = {
  workhistory_id: string
  customer_id: string
  company_id: string | null
  company_info: Prisma.JsonValue | null
  occupation: Prisma.JsonValue | null
  industry: Prisma.JsonValue | null
  position: JobPosition | null
  enter_date: Date | null
  leave_date: Date | null
  working_month: number | null
  is_current: boolean | null
  duties: string | null
  created_at: Date
  updated_at: Date
  created_by: string | null
  updated_by: string | null
}

/**
 * Model Dictionary
 * 
 */
export type Dictionary = {
  dictionaries_id: string
  dictionary_id: number
  language_code: string
  dic_value: string
  created_at: Date
}

/**
 * Model Entity
 * 
 */
export type Entity = {
  entity_id: number
  name: string
  kana: string | null
  logo: string | null
  socials: Prisma.JsonValue | null
  gps: Prisma.JsonValue | null
  contact_person: Prisma.JsonValue | null
  contact_details: Prisma.JsonValue | null
  is_system: boolean
  created_at: Date
  updated_at: Date
  created_by: string | null
  updated_by: string | null
}

/**
 * Model EntityAccountInfo
 * 
 */
export type EntityAccountInfo = {
  entity_accountinfo_id: string
  entity_id: number | null
  bank_code: string | null
  branch_code: string | null
  account_id: string | null
  is_default: boolean | null
  created_at: Date
  updated_at: Date
  updated_by: string | null
  created_by: string | null
}

/**
 * Model EntityBranch
 * 
 */
export type EntityBranch = {
  branch_id: number
  branch_name: string | null
  kana: string | null
  is_jeadquarter: boolean
  image: string | null
  prefecture: Prisma.JsonValue | null
  post_code: string | null
  city: string | null
  district: string | null
  address: string | null
  address1: string | null
  nearest_station: string | null
  socials: Prisma.JsonValue | null
  gps: Prisma.JsonValue | null
  contact_person: Prisma.JsonValue | null
  contact_details: Prisma.JsonValue | null
  created_at: Date
  updated_at: Date
  created_by: string | null
  updated_by: string | null
  entity_id: number
}

/**
 * Model EntityDetail
 * 
 */
export type EntityDetail = {
  entity_detail_id: string
  entity_id: number | null
  establishment: Date | null
  capital: number | null
  numberof_employees: number | null
  business_performance: Prisma.JsonValue | null
  representative_telephone: string | null
  representative: string | null
  average_age: number | null
  foreign_capitalratio: number | null
  homepage: string | null
  business_summary: string | null
  organizational_structure: string | null
  company_sales: string | null
  workplace_environment: string | null
  shareholder: Prisma.JsonValue | null
  related_company: number | null
  recruitment_personname: string | null
  memo: string | null
  business_status: string | null
  created_at: Date
  updated_at: Date
  created_by: string | null
  updated_by: string | null
}

/**
 * Model Files
 * 
 */
export type Files = {
  file_id: string
  file_name: string
  target_id: string
  file_path: string
  file_type: FileType
  fiel_source: FileSource
  created_at: Date
  created_by: string
}

/**
 * Model Inquiry
 * 
 */
export type Inquiry = {
  inquire_id: string
  parent_id: string | null
  fromuser_id: string | null
  entity_id: number | null
  assigned_user_id: string | null
  subject: string
  body: string
  inquiry_status: InquiryStatus | null
  is_read: boolean
  is_answer: boolean
  created_at: Date
  updated_at: Date
  created_by: string | null
}

/**
 * Model Job
 * 
 */
export type Job = {
  job_id: string
  created_at: Date
  updated_at: Date
  created_by: string
  updated_by: string | null
  job_publish: JobPublish
  location_details: string | null
  career_level: JobPosition[]
  benefit_other: string | null
  smoke: Smoke[]
  employment_status: EmploymentStatus
  japanese_level: LanguageLevel
  english_level: LanguageLevel
  experienced_count: number
  age_min: number | null
  age_max: number | null
  set_age_reason: string | null
  recruitment_type: ReqriutmentType | null
  job_title: string
  job_description: string
  japanese_percentage: number | null
  must_condition: string
  want_condition: string | null
  position_name: string | null
  working_hour: string
  salary_type: SalaryType
  salary_min: number | null
  salary_max: number | null
  salary_detail: string
  day_off: string | null
  progress_detail: string
  entity_branch_id: number
  expire_date: Date | null
}

/**
 * Model JobOtherLanguage
 * 
 */
export type JobOtherLanguage = {
  job_other_language_id: string
  language_id: number
  language_level: LanguageLevel
  job_id: string
}

/**
 * Model JobReferenceList
 * 
 */
export type JobReferenceList = {
  job_reference_id: string
  job_id: string
  reference_list_id: number
  reference_list_item_id: number
}

/**
 * Model JobCandidate
 * 
 */
export type JobCandidate = {
  job_candidate_id: string
  job_id: string
  customer_id: string
  candidate_status: number
  created_at: Date
  updated_at: Date
  created_by: string | null
  updated_by: string | null
}

/**
 * Model JobRequirement
 * 
 */
export type JobRequirement = {
  job_require_id: string
  job_id: string
  require_id: number
  require_detial: Prisma.JsonValue | null
  created_at: Date
  updated_at: Date
  created_by: string | null
  updated_by: string | null
}

/**
 * Model SystemLangauge
 * 
 */
export type SystemLangauge = {
  language_id: number
  language_code: string
  is_default: boolean
}

/**
 * Model Logger
 * 
 */
export type Logger = {
  log_id: string
  action_user: UserAction
  user_id: string | null
  new_value: Prisma.JsonValue | null
  old_value: Prisma.JsonValue | null
  created_at: Date
  updated_at: Date
  created_by: string | null
  updated_by: string | null
}

/**
 * Model News
 * 
 */
export type News = {
  news_id: string
  page_id: number
  title: string
  brief: string
  image_id: string
  content: string
  is_top: boolean
  is_publish: boolean
  created_at: Date
  updated_at: Date
  created_by: string
  update_by: string
}

/**
 * Model Notification
 * 
 */
export type Notification = {
  notifiation_id: string
  user_id: string
  link: string
  message: string
  is_new: boolean
  is_badge: boolean
  created_at: Date
  created_by: string
}

/**
 * Model Pages
 * 
 */
export type Pages = {
  page_id: number
  page_name: string
  page_type: number
  created_at: Date
  created_by: string
}

/**
 * Model ReferenceList
 * 
 */
export type ReferenceList = {
  list_id: number
  list_name: string
  created_at: Date
}

/**
 * Model ReferenceListItems
 * 
 */
export type ReferenceListItems = {
  listitem_id: number
  list_id: number
  dictionary_id: number
  code: string | null
  listitem_value: string | null
  parent_id: number | null
  value: string | null
  created_at: Date
  updated_at: Date
  dictionaryDictionaries_id: string | null
}

/**
 * Model ScoutFav
 * 
 */
export type ScoutFav = {
  scout_id: string
  entity_id: number | null
  branch_id: number | null
  user_id: string
  job_id: string | null
  note: string
  created_at: Date
  created_by: string
}

/**
 * Model User
 * 
 */
export type User = {
  user_id: string
  email: string
  mobile: string | null
  name: string | null
  password_hash: string
  role: UserRole
  company_id: number
  customer_id: string | null
  attemptpass_count: number | null
  reset_code: string
  is_emailverified: boolean
  is_mobileverified: boolean
  user_status: UserStatus
  created_at: Date
  updated_at: Date
  deleted_at: Date | null
  favs: Prisma.JsonValue
}


/**
 * Enums
 */

// Based on
// https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

export const CustomerStatus: {
  no_data: 'no_data'
};

export type CustomerStatus = (typeof CustomerStatus)[keyof typeof CustomerStatus]


export const EmploymentStatus: {
  employee: 'employee',
  contract_employee: 'contract_employee',
  outsourcing: 'outsourcing'
};

export type EmploymentStatus = (typeof EmploymentStatus)[keyof typeof EmploymentStatus]


export const FileSource: {
  content_image: 'content_image',
  page_image: 'page_image',
  user: 'user',
  user_avatar: 'user_avatar',
  user_image: 'user_image',
  user_cv: 'user_cv',
  user_resume: 'user_resume',
  user_portfolio: 'user_portfolio',
  user_other: 'user_other',
  other: 'other'
};

export type FileSource = (typeof FileSource)[keyof typeof FileSource]


export const FileType: {
  image: 'image',
  video: 'video',
  pdf: 'pdf',
  gif: 'gif',
  csv: 'csv',
  other: 'other'
};

export type FileType = (typeof FileType)[keyof typeof FileType]


export const Gender: {
  no_data: 'no_data',
  male: 'male',
  female: 'female'
};

export type Gender = (typeof Gender)[keyof typeof Gender]


export const InquiryStatus: {
  open: 'open',
  reply: 'reply',
  closed: 'closed'
};

export type InquiryStatus = (typeof InquiryStatus)[keyof typeof InquiryStatus]


export const JobPosition: {
  no_data: 'no_data',
  execute: 'execute',
  manager: 'manager',
  senior: 'senior',
  staff: 'staff',
  entry: 'entry'
};

export type JobPosition = (typeof JobPosition)[keyof typeof JobPosition]


export const JobPublish: {
  public: 'public',
  private: 'private'
};

export type JobPublish = (typeof JobPublish)[keyof typeof JobPublish]


export const LanguageLevel: {
  no_data: 'no_data',
  vative: 'vative',
  near_native: 'near_native',
  business: 'business',
  daily_conversation: 'daily_conversation',
  greeting: 'greeting'
};

export type LanguageLevel = (typeof LanguageLevel)[keyof typeof LanguageLevel]


export const ReqriutmentType: {
  direct: 'direct',
  referral_company: 'referral_company'
};

export type ReqriutmentType = (typeof ReqriutmentType)[keyof typeof ReqriutmentType]


export const SalaryType: {
  no_data: 'no_data',
  hourly_wage: 'hourly_wage',
  daily_wage: 'daily_wage',
  monthly_salary: 'monthly_salary',
  annual_salary: 'annual_salary'
};

export type SalaryType = (typeof SalaryType)[keyof typeof SalaryType]


export const Smoke: {
  no_data: 'no_data',
  yes__no_smoking_on_site: 'yes__no_smoking_on_site',
  yes__no_smoking_indoors_and_smoking_area_set_up_outdoors: 'yes__no_smoking_indoors_and_smoking_area_set_up_outdoors',
  yes__no_smoking_indoors: 'yes__no_smoking_indoors',
  yes__smoking_room_installed_indoors: 'yes__smoking_room_installed_indoors',
  yes__working_in_smoking_areas: 'yes__working_in_smoking_areas',
  no_smoking_allowed: 'no_smoking_allowed'
};

export type Smoke = (typeof Smoke)[keyof typeof Smoke]


export const StatusVisa: {
  no_data: 'no_data'
};

export type StatusVisa = (typeof StatusVisa)[keyof typeof StatusVisa]


export const UserAction: {
  no_data: 'no_data',
  manage: 'manage',
  create: 'create',
  read: 'read',
  update: 'update',
  delete: 'delete'
};

export type UserAction = (typeof UserAction)[keyof typeof UserAction]


export const UserRole: {
  no_data: 'no_data',
  gtn_super_admin: 'gtn_super_admin',
  gtn_admin: 'gtn_admin',
  company_super_admin: 'company_super_admin',
  company_admin: 'company_admin',
  company_user: 'company_user',
  job_seeker: 'job_seeker'
};

export type UserRole = (typeof UserRole)[keyof typeof UserRole]


export const UserStatus: {
  active: 'active',
  inactive_waitverify: 'inactive_waitverify',
  inactive_changepass: 'inactive_changepass',
  suspended_attempt: 'suspended_attempt',
  suspended_admin: 'suspended_admin',
  deleted: 'deleted'
};

export type UserStatus = (typeof UserStatus)[keyof typeof UserStatus]


/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more ActionRoles
 * const actionRoles = await prisma.actionRole.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  GlobalReject extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined = 'rejectOnNotFound' extends keyof T
    ? T['rejectOnNotFound']
    : false
      > {
    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more ActionRoles
   * const actionRoles = await prisma.actionRole.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends (U | 'beforeExit')>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : V extends 'beforeExit' ? () => Promise<void> : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): Promise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): Promise<void>;

  /**
   * Add a middleware
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): Promise<UnwrapTuple<P>>;

  $transaction<R>(fn: (prisma: Prisma.TransactionClient) => Promise<R>, options?: {maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel}): Promise<R>;

      /**
   * `prisma.actionRole`: Exposes CRUD operations for the **ActionRole** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ActionRoles
    * const actionRoles = await prisma.actionRole.findMany()
    * ```
    */
  get actionRole(): Prisma.ActionRoleDelegate<GlobalReject>;

  /**
   * `prisma.customer`: Exposes CRUD operations for the **Customer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Customers
    * const customers = await prisma.customer.findMany()
    * ```
    */
  get customer(): Prisma.CustomerDelegate<GlobalReject>;

  /**
   * `prisma.customerDesired`: Exposes CRUD operations for the **CustomerDesired** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CustomerDesireds
    * const customerDesireds = await prisma.customerDesired.findMany()
    * ```
    */
  get customerDesired(): Prisma.CustomerDesiredDelegate<GlobalReject>;

  /**
   * `prisma.customerEducation`: Exposes CRUD operations for the **CustomerEducation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CustomerEducations
    * const customerEducations = await prisma.customerEducation.findMany()
    * ```
    */
  get customerEducation(): Prisma.CustomerEducationDelegate<GlobalReject>;

  /**
   * `prisma.customerExperience`: Exposes CRUD operations for the **CustomerExperience** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CustomerExperiences
    * const customerExperiences = await prisma.customerExperience.findMany()
    * ```
    */
  get customerExperience(): Prisma.CustomerExperienceDelegate<GlobalReject>;

  /**
   * `prisma.customerJobDetail`: Exposes CRUD operations for the **CustomerJobDetail** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CustomerJobDetails
    * const customerJobDetails = await prisma.customerJobDetail.findMany()
    * ```
    */
  get customerJobDetail(): Prisma.CustomerJobDetailDelegate<GlobalReject>;

  /**
   * `prisma.customerLanguage`: Exposes CRUD operations for the **CustomerLanguage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CustomerLanguages
    * const customerLanguages = await prisma.customerLanguage.findMany()
    * ```
    */
  get customerLanguage(): Prisma.CustomerLanguageDelegate<GlobalReject>;

  /**
   * `prisma.customerQualification`: Exposes CRUD operations for the **CustomerQualification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CustomerQualifications
    * const customerQualifications = await prisma.customerQualification.findMany()
    * ```
    */
  get customerQualification(): Prisma.CustomerQualificationDelegate<GlobalReject>;

  /**
   * `prisma.customerVisa`: Exposes CRUD operations for the **CustomerVisa** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CustomerVisas
    * const customerVisas = await prisma.customerVisa.findMany()
    * ```
    */
  get customerVisa(): Prisma.CustomerVisaDelegate<GlobalReject>;

  /**
   * `prisma.customerWorkHistory`: Exposes CRUD operations for the **CustomerWorkHistory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CustomerWorkHistories
    * const customerWorkHistories = await prisma.customerWorkHistory.findMany()
    * ```
    */
  get customerWorkHistory(): Prisma.CustomerWorkHistoryDelegate<GlobalReject>;

  /**
   * `prisma.dictionary`: Exposes CRUD operations for the **Dictionary** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Dictionaries
    * const dictionaries = await prisma.dictionary.findMany()
    * ```
    */
  get dictionary(): Prisma.DictionaryDelegate<GlobalReject>;

  /**
   * `prisma.entity`: Exposes CRUD operations for the **Entity** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Entities
    * const entities = await prisma.entity.findMany()
    * ```
    */
  get entity(): Prisma.EntityDelegate<GlobalReject>;

  /**
   * `prisma.entityAccountInfo`: Exposes CRUD operations for the **EntityAccountInfo** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EntityAccountInfos
    * const entityAccountInfos = await prisma.entityAccountInfo.findMany()
    * ```
    */
  get entityAccountInfo(): Prisma.EntityAccountInfoDelegate<GlobalReject>;

  /**
   * `prisma.entityBranch`: Exposes CRUD operations for the **EntityBranch** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EntityBranches
    * const entityBranches = await prisma.entityBranch.findMany()
    * ```
    */
  get entityBranch(): Prisma.EntityBranchDelegate<GlobalReject>;

  /**
   * `prisma.entityDetail`: Exposes CRUD operations for the **EntityDetail** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EntityDetails
    * const entityDetails = await prisma.entityDetail.findMany()
    * ```
    */
  get entityDetail(): Prisma.EntityDetailDelegate<GlobalReject>;

  /**
   * `prisma.files`: Exposes CRUD operations for the **Files** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Files
    * const files = await prisma.files.findMany()
    * ```
    */
  get files(): Prisma.FilesDelegate<GlobalReject>;

  /**
   * `prisma.inquiry`: Exposes CRUD operations for the **Inquiry** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Inquiries
    * const inquiries = await prisma.inquiry.findMany()
    * ```
    */
  get inquiry(): Prisma.InquiryDelegate<GlobalReject>;

  /**
   * `prisma.job`: Exposes CRUD operations for the **Job** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Jobs
    * const jobs = await prisma.job.findMany()
    * ```
    */
  get job(): Prisma.JobDelegate<GlobalReject>;

  /**
   * `prisma.jobOtherLanguage`: Exposes CRUD operations for the **JobOtherLanguage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more JobOtherLanguages
    * const jobOtherLanguages = await prisma.jobOtherLanguage.findMany()
    * ```
    */
  get jobOtherLanguage(): Prisma.JobOtherLanguageDelegate<GlobalReject>;

  /**
   * `prisma.jobReferenceList`: Exposes CRUD operations for the **JobReferenceList** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more JobReferenceLists
    * const jobReferenceLists = await prisma.jobReferenceList.findMany()
    * ```
    */
  get jobReferenceList(): Prisma.JobReferenceListDelegate<GlobalReject>;

  /**
   * `prisma.jobCandidate`: Exposes CRUD operations for the **JobCandidate** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more JobCandidates
    * const jobCandidates = await prisma.jobCandidate.findMany()
    * ```
    */
  get jobCandidate(): Prisma.JobCandidateDelegate<GlobalReject>;

  /**
   * `prisma.jobRequirement`: Exposes CRUD operations for the **JobRequirement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more JobRequirements
    * const jobRequirements = await prisma.jobRequirement.findMany()
    * ```
    */
  get jobRequirement(): Prisma.JobRequirementDelegate<GlobalReject>;

  /**
   * `prisma.systemLangauge`: Exposes CRUD operations for the **SystemLangauge** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SystemLangauges
    * const systemLangauges = await prisma.systemLangauge.findMany()
    * ```
    */
  get systemLangauge(): Prisma.SystemLangaugeDelegate<GlobalReject>;

  /**
   * `prisma.logger`: Exposes CRUD operations for the **Logger** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Loggers
    * const loggers = await prisma.logger.findMany()
    * ```
    */
  get logger(): Prisma.LoggerDelegate<GlobalReject>;

  /**
   * `prisma.news`: Exposes CRUD operations for the **News** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more News
    * const news = await prisma.news.findMany()
    * ```
    */
  get news(): Prisma.NewsDelegate<GlobalReject>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.NotificationDelegate<GlobalReject>;

  /**
   * `prisma.pages`: Exposes CRUD operations for the **Pages** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Pages
    * const pages = await prisma.pages.findMany()
    * ```
    */
  get pages(): Prisma.PagesDelegate<GlobalReject>;

  /**
   * `prisma.referenceList`: Exposes CRUD operations for the **ReferenceList** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ReferenceLists
    * const referenceLists = await prisma.referenceList.findMany()
    * ```
    */
  get referenceList(): Prisma.ReferenceListDelegate<GlobalReject>;

  /**
   * `prisma.referenceListItems`: Exposes CRUD operations for the **ReferenceListItems** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ReferenceListItems
    * const referenceListItems = await prisma.referenceListItems.findMany()
    * ```
    */
  get referenceListItems(): Prisma.ReferenceListItemsDelegate<GlobalReject>;

  /**
   * `prisma.scoutFav`: Exposes CRUD operations for the **ScoutFav** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ScoutFavs
    * const scoutFavs = await prisma.scoutFav.findMany()
    * ```
    */
  get scoutFav(): Prisma.ScoutFavDelegate<GlobalReject>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<GlobalReject>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket


  /**
   * Prisma Client JS version: 4.7.1
   * Query Engine version: d6e67a83f971b175a593ccc12e15c4a757f93ffe
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }
  type HasSelect = {
    select: any
  }
  type HasInclude = {
    include: any
  }
  type CheckSelect<T, S, U> = T extends SelectAndInclude
    ? 'Please either choose `select` or `include`'
    : T extends HasSelect
    ? U
    : T extends HasInclude
    ? U
    : S

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => Promise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Exact<A, W = unknown> = 
  W extends unknown ? A extends Narrowable ? Cast<A, W> : Cast<
  {[K in keyof A]: K extends keyof W ? Exact<A[K], W[K]> : never},
  {[K in keyof W]: K extends keyof A ? Exact<A[K], W[K]> : W[K]}>
  : never;

  type Narrowable = string | number | boolean | bigint;

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;

  export function validator<V>(): <S>(select: Exact<S, V>) => S;

  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but with an array
   */
  type PickArray<T, K extends Array<keyof T>> = Prisma__Pick<T, TupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>

  class PrismaClientFetcher {
    private readonly prisma;
    private readonly debug;
    private readonly hooks?;
    constructor(prisma: PrismaClient<any, any>, debug?: boolean, hooks?: Hooks | undefined);
    request<T>(document: any, dataPath?: string[], rootField?: string, typeName?: string, isList?: boolean, callsite?: string): Promise<T>;
    sanitizeMessage(message: string): string;
    protected unpack(document: any, data: any, path: string[], rootField?: string, isList?: boolean): any;
  }

  export const ModelName: {
    ActionRole: 'ActionRole',
    Customer: 'Customer',
    CustomerDesired: 'CustomerDesired',
    CustomerEducation: 'CustomerEducation',
    CustomerExperience: 'CustomerExperience',
    CustomerJobDetail: 'CustomerJobDetail',
    CustomerLanguage: 'CustomerLanguage',
    CustomerQualification: 'CustomerQualification',
    CustomerVisa: 'CustomerVisa',
    CustomerWorkHistory: 'CustomerWorkHistory',
    Dictionary: 'Dictionary',
    Entity: 'Entity',
    EntityAccountInfo: 'EntityAccountInfo',
    EntityBranch: 'EntityBranch',
    EntityDetail: 'EntityDetail',
    Files: 'Files',
    Inquiry: 'Inquiry',
    Job: 'Job',
    JobOtherLanguage: 'JobOtherLanguage',
    JobReferenceList: 'JobReferenceList',
    JobCandidate: 'JobCandidate',
    JobRequirement: 'JobRequirement',
    SystemLangauge: 'SystemLangauge',
    Logger: 'Logger',
    News: 'News',
    Notification: 'Notification',
    Pages: 'Pages',
    ReferenceList: 'ReferenceList',
    ReferenceListItems: 'ReferenceListItems',
    ScoutFav: 'ScoutFav',
    User: 'User'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  export type RejectOnNotFound = boolean | ((error: Error) => Error)
  export type RejectPerModel = { [P in ModelName]?: RejectOnNotFound }
  export type RejectPerOperation =  { [P in "findUnique" | "findFirst"]?: RejectPerModel | RejectOnNotFound } 
  type IsReject<T> = T extends true ? True : T extends (err: Error) => Error ? True : False
  export type HasReject<
    GlobalRejectSettings extends Prisma.PrismaClientOptions['rejectOnNotFound'],
    LocalRejectSettings,
    Action extends PrismaAction,
    Model extends ModelName
  > = LocalRejectSettings extends RejectOnNotFound
    ? IsReject<LocalRejectSettings>
    : GlobalRejectSettings extends RejectPerOperation
    ? Action extends keyof GlobalRejectSettings
      ? GlobalRejectSettings[Action] extends RejectOnNotFound
        ? IsReject<GlobalRejectSettings[Action]>
        : GlobalRejectSettings[Action] extends RejectPerModel
        ? Model extends keyof GlobalRejectSettings[Action]
          ? IsReject<GlobalRejectSettings[Action][Model]>
          : False
        : False
      : False
    : IsReject<GlobalRejectSettings>
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

  export interface PrismaClientOptions {
    /**
     * Configure findUnique/findFirst to throw an error if the query returns null. 
     * @deprecated since 4.0.0. Use `findUniqueOrThrow`/`findFirstOrThrow` methods instead.
     * @example
     * ```
     * // Reject on both findUnique/findFirst
     * rejectOnNotFound: true
     * // Reject only on findFirst with a custom error
     * rejectOnNotFound: { findFirst: (err) => new Error("Custom Error")}
     * // Reject on user.findUnique with a custom error
     * rejectOnNotFound: { findUnique: {User: (err) => new Error("User not found")}}
     * ```
     */
    rejectOnNotFound?: RejectOnNotFound | RejectPerOperation
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources

    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat

    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: Array<LogLevel | LogDefinition>
  }

  export type Hooks = {
    beforeRequest?: (options: { query: string, path: string[], rootField?: string, typeName?: string, document: any }) => any
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findMany'
    | 'findFirst'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => Promise<T>,
  ) => Promise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<PrismaClient, '$connect' | '$disconnect' | '$on' | '$transaction' | '$use'>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type CustomerCountOutputType
   */


  export type CustomerCountOutputType = {
    customer_visas: number
    customer_jobdetails: number
    customer_educations: number
    customer_languages: number
    customer_qualifications: number
    customer_workhistories: number
    job_candidates: number
    customer_desired: number
  }

  export type CustomerCountOutputTypeSelect = {
    customer_visas?: boolean
    customer_jobdetails?: boolean
    customer_educations?: boolean
    customer_languages?: boolean
    customer_qualifications?: boolean
    customer_workhistories?: boolean
    job_candidates?: boolean
    customer_desired?: boolean
  }

  export type CustomerCountOutputTypeGetPayload<S extends boolean | null | undefined | CustomerCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? CustomerCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (CustomerCountOutputTypeArgs)
    ? CustomerCountOutputType 
    : S extends { select: any } & (CustomerCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof CustomerCountOutputType ? CustomerCountOutputType[P] : never
  } 
      : CustomerCountOutputType




  // Custom InputTypes

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the CustomerCountOutputType
     * 
    **/
    select?: CustomerCountOutputTypeSelect | null
  }



  /**
   * Count Type CustomerJobDetailCountOutputType
   */


  export type CustomerJobDetailCountOutputType = {
    customer_experiences: number
  }

  export type CustomerJobDetailCountOutputTypeSelect = {
    customer_experiences?: boolean
  }

  export type CustomerJobDetailCountOutputTypeGetPayload<S extends boolean | null | undefined | CustomerJobDetailCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? CustomerJobDetailCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (CustomerJobDetailCountOutputTypeArgs)
    ? CustomerJobDetailCountOutputType 
    : S extends { select: any } & (CustomerJobDetailCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof CustomerJobDetailCountOutputType ? CustomerJobDetailCountOutputType[P] : never
  } 
      : CustomerJobDetailCountOutputType




  // Custom InputTypes

  /**
   * CustomerJobDetailCountOutputType without action
   */
  export type CustomerJobDetailCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the CustomerJobDetailCountOutputType
     * 
    **/
    select?: CustomerJobDetailCountOutputTypeSelect | null
  }



  /**
   * Count Type DictionaryCountOutputType
   */


  export type DictionaryCountOutputType = {
    reference_listitems: number
  }

  export type DictionaryCountOutputTypeSelect = {
    reference_listitems?: boolean
  }

  export type DictionaryCountOutputTypeGetPayload<S extends boolean | null | undefined | DictionaryCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? DictionaryCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (DictionaryCountOutputTypeArgs)
    ? DictionaryCountOutputType 
    : S extends { select: any } & (DictionaryCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof DictionaryCountOutputType ? DictionaryCountOutputType[P] : never
  } 
      : DictionaryCountOutputType




  // Custom InputTypes

  /**
   * DictionaryCountOutputType without action
   */
  export type DictionaryCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the DictionaryCountOutputType
     * 
    **/
    select?: DictionaryCountOutputTypeSelect | null
  }



  /**
   * Count Type EntityCountOutputType
   */


  export type EntityCountOutputType = {
    entity_details: number
    entity_branches: number
    entity_accountinfos: number
    inquiries: number
  }

  export type EntityCountOutputTypeSelect = {
    entity_details?: boolean
    entity_branches?: boolean
    entity_accountinfos?: boolean
    inquiries?: boolean
  }

  export type EntityCountOutputTypeGetPayload<S extends boolean | null | undefined | EntityCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? EntityCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (EntityCountOutputTypeArgs)
    ? EntityCountOutputType 
    : S extends { select: any } & (EntityCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof EntityCountOutputType ? EntityCountOutputType[P] : never
  } 
      : EntityCountOutputType




  // Custom InputTypes

  /**
   * EntityCountOutputType without action
   */
  export type EntityCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the EntityCountOutputType
     * 
    **/
    select?: EntityCountOutputTypeSelect | null
  }



  /**
   * Count Type EntityBranchCountOutputType
   */


  export type EntityBranchCountOutputType = {
    jobs: number
  }

  export type EntityBranchCountOutputTypeSelect = {
    jobs?: boolean
  }

  export type EntityBranchCountOutputTypeGetPayload<S extends boolean | null | undefined | EntityBranchCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? EntityBranchCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (EntityBranchCountOutputTypeArgs)
    ? EntityBranchCountOutputType 
    : S extends { select: any } & (EntityBranchCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof EntityBranchCountOutputType ? EntityBranchCountOutputType[P] : never
  } 
      : EntityBranchCountOutputType




  // Custom InputTypes

  /**
   * EntityBranchCountOutputType without action
   */
  export type EntityBranchCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the EntityBranchCountOutputType
     * 
    **/
    select?: EntityBranchCountOutputTypeSelect | null
  }



  /**
   * Count Type JobCountOutputType
   */


  export type JobCountOutputType = {
    job_references: number
    job_other_languages: number
    job_candidates: number
    JobRequirement: number
  }

  export type JobCountOutputTypeSelect = {
    job_references?: boolean
    job_other_languages?: boolean
    job_candidates?: boolean
    JobRequirement?: boolean
  }

  export type JobCountOutputTypeGetPayload<S extends boolean | null | undefined | JobCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? JobCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (JobCountOutputTypeArgs)
    ? JobCountOutputType 
    : S extends { select: any } & (JobCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof JobCountOutputType ? JobCountOutputType[P] : never
  } 
      : JobCountOutputType




  // Custom InputTypes

  /**
   * JobCountOutputType without action
   */
  export type JobCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the JobCountOutputType
     * 
    **/
    select?: JobCountOutputTypeSelect | null
  }



  /**
   * Count Type PagesCountOutputType
   */


  export type PagesCountOutputType = {
    news: number
  }

  export type PagesCountOutputTypeSelect = {
    news?: boolean
  }

  export type PagesCountOutputTypeGetPayload<S extends boolean | null | undefined | PagesCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? PagesCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (PagesCountOutputTypeArgs)
    ? PagesCountOutputType 
    : S extends { select: any } & (PagesCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof PagesCountOutputType ? PagesCountOutputType[P] : never
  } 
      : PagesCountOutputType




  // Custom InputTypes

  /**
   * PagesCountOutputType without action
   */
  export type PagesCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the PagesCountOutputType
     * 
    **/
    select?: PagesCountOutputTypeSelect | null
  }



  /**
   * Count Type ReferenceListCountOutputType
   */


  export type ReferenceListCountOutputType = {
    listitems: number
    JobReferenceList: number
  }

  export type ReferenceListCountOutputTypeSelect = {
    listitems?: boolean
    JobReferenceList?: boolean
  }

  export type ReferenceListCountOutputTypeGetPayload<S extends boolean | null | undefined | ReferenceListCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? ReferenceListCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (ReferenceListCountOutputTypeArgs)
    ? ReferenceListCountOutputType 
    : S extends { select: any } & (ReferenceListCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof ReferenceListCountOutputType ? ReferenceListCountOutputType[P] : never
  } 
      : ReferenceListCountOutputType




  // Custom InputTypes

  /**
   * ReferenceListCountOutputType without action
   */
  export type ReferenceListCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the ReferenceListCountOutputType
     * 
    **/
    select?: ReferenceListCountOutputTypeSelect | null
  }



  /**
   * Count Type ReferenceListItemsCountOutputType
   */


  export type ReferenceListItemsCountOutputType = {
    customer_experiences: number
    JobReferenceList: number
  }

  export type ReferenceListItemsCountOutputTypeSelect = {
    customer_experiences?: boolean
    JobReferenceList?: boolean
  }

  export type ReferenceListItemsCountOutputTypeGetPayload<S extends boolean | null | undefined | ReferenceListItemsCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? ReferenceListItemsCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (ReferenceListItemsCountOutputTypeArgs)
    ? ReferenceListItemsCountOutputType 
    : S extends { select: any } & (ReferenceListItemsCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof ReferenceListItemsCountOutputType ? ReferenceListItemsCountOutputType[P] : never
  } 
      : ReferenceListItemsCountOutputType




  // Custom InputTypes

  /**
   * ReferenceListItemsCountOutputType without action
   */
  export type ReferenceListItemsCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the ReferenceListItemsCountOutputType
     * 
    **/
    select?: ReferenceListItemsCountOutputTypeSelect | null
  }



  /**
   * Count Type UserCountOutputType
   */


  export type UserCountOutputType = {
    loggers: number
    from_inquiries: number
    assign_inquiries: number
    notifications: number
    ScoutFav: number
  }

  export type UserCountOutputTypeSelect = {
    loggers?: boolean
    from_inquiries?: boolean
    assign_inquiries?: boolean
    notifications?: boolean
    ScoutFav?: boolean
  }

  export type UserCountOutputTypeGetPayload<S extends boolean | null | undefined | UserCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? UserCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (UserCountOutputTypeArgs)
    ? UserCountOutputType 
    : S extends { select: any } & (UserCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof UserCountOutputType ? UserCountOutputType[P] : never
  } 
      : UserCountOutputType




  // Custom InputTypes

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     * 
    **/
    select?: UserCountOutputTypeSelect | null
  }



  /**
   * Models
   */

  /**
   * Model ActionRole
   */


  export type AggregateActionRole = {
    _count: ActionRoleCountAggregateOutputType | null
    _min: ActionRoleMinAggregateOutputType | null
    _max: ActionRoleMaxAggregateOutputType | null
  }

  export type ActionRoleMinAggregateOutputType = {
    action_role_id: string | null
    controller_path: string | null
    action_user: UserAction | null
    role: UserRole | null
    is_can: boolean | null
    is_company: boolean | null
    parent_id: string | null
    created_at: Date | null
    updated_at: Date | null
    created_by: string | null
    updated_by: string | null
  }

  export type ActionRoleMaxAggregateOutputType = {
    action_role_id: string | null
    controller_path: string | null
    action_user: UserAction | null
    role: UserRole | null
    is_can: boolean | null
    is_company: boolean | null
    parent_id: string | null
    created_at: Date | null
    updated_at: Date | null
    created_by: string | null
    updated_by: string | null
  }

  export type ActionRoleCountAggregateOutputType = {
    action_role_id: number
    controller_path: number
    action_user: number
    role: number
    is_can: number
    is_company: number
    parent_id: number
    created_at: number
    updated_at: number
    created_by: number
    updated_by: number
    _all: number
  }


  export type ActionRoleMinAggregateInputType = {
    action_role_id?: true
    controller_path?: true
    action_user?: true
    role?: true
    is_can?: true
    is_company?: true
    parent_id?: true
    created_at?: true
    updated_at?: true
    created_by?: true
    updated_by?: true
  }

  export type ActionRoleMaxAggregateInputType = {
    action_role_id?: true
    controller_path?: true
    action_user?: true
    role?: true
    is_can?: true
    is_company?: true
    parent_id?: true
    created_at?: true
    updated_at?: true
    created_by?: true
    updated_by?: true
  }

  export type ActionRoleCountAggregateInputType = {
    action_role_id?: true
    controller_path?: true
    action_user?: true
    role?: true
    is_can?: true
    is_company?: true
    parent_id?: true
    created_at?: true
    updated_at?: true
    created_by?: true
    updated_by?: true
    _all?: true
  }

  export type ActionRoleAggregateArgs = {
    /**
     * Filter which ActionRole to aggregate.
     * 
    **/
    where?: ActionRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActionRoles to fetch.
     * 
    **/
    orderBy?: Enumerable<ActionRoleOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: ActionRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActionRoles from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActionRoles.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ActionRoles
    **/
    _count?: true | ActionRoleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ActionRoleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ActionRoleMaxAggregateInputType
  }

  export type GetActionRoleAggregateType<T extends ActionRoleAggregateArgs> = {
        [P in keyof T & keyof AggregateActionRole]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateActionRole[P]>
      : GetScalarType<T[P], AggregateActionRole[P]>
  }




  export type ActionRoleGroupByArgs = {
    where?: ActionRoleWhereInput
    orderBy?: Enumerable<ActionRoleOrderByWithAggregationInput>
    by: Array<ActionRoleScalarFieldEnum>
    having?: ActionRoleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ActionRoleCountAggregateInputType | true
    _min?: ActionRoleMinAggregateInputType
    _max?: ActionRoleMaxAggregateInputType
  }


  export type ActionRoleGroupByOutputType = {
    action_role_id: string
    controller_path: string | null
    action_user: UserAction
    role: UserRole
    is_can: boolean
    is_company: boolean
    parent_id: string | null
    created_at: Date
    updated_at: Date
    created_by: string | null
    updated_by: string | null
    _count: ActionRoleCountAggregateOutputType | null
    _min: ActionRoleMinAggregateOutputType | null
    _max: ActionRoleMaxAggregateOutputType | null
  }

  type GetActionRoleGroupByPayload<T extends ActionRoleGroupByArgs> = PrismaPromise<
    Array<
      PickArray<ActionRoleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ActionRoleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ActionRoleGroupByOutputType[P]>
            : GetScalarType<T[P], ActionRoleGroupByOutputType[P]>
        }
      >
    >


  export type ActionRoleSelect = {
    action_role_id?: boolean
    controller_path?: boolean
    action_user?: boolean
    role?: boolean
    is_can?: boolean
    is_company?: boolean
    parent_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    created_by?: boolean
    updated_by?: boolean
  }


  export type ActionRoleGetPayload<S extends boolean | null | undefined | ActionRoleArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? ActionRole :
    S extends undefined ? never :
    S extends { include: any } & (ActionRoleArgs | ActionRoleFindManyArgs)
    ? ActionRole 
    : S extends { select: any } & (ActionRoleArgs | ActionRoleFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof ActionRole ? ActionRole[P] : never
  } 
      : ActionRole


  type ActionRoleCountArgs = Merge<
    Omit<ActionRoleFindManyArgs, 'select' | 'include'> & {
      select?: ActionRoleCountAggregateInputType | true
    }
  >

  export interface ActionRoleDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one ActionRole that matches the filter.
     * @param {ActionRoleFindUniqueArgs} args - Arguments to find a ActionRole
     * @example
     * // Get one ActionRole
     * const actionRole = await prisma.actionRole.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ActionRoleFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ActionRoleFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ActionRole'> extends True ? Prisma__ActionRoleClient<ActionRoleGetPayload<T>> : Prisma__ActionRoleClient<ActionRoleGetPayload<T> | null, null>

    /**
     * Find one ActionRole that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ActionRoleFindUniqueOrThrowArgs} args - Arguments to find a ActionRole
     * @example
     * // Get one ActionRole
     * const actionRole = await prisma.actionRole.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ActionRoleFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, ActionRoleFindUniqueOrThrowArgs>
    ): Prisma__ActionRoleClient<ActionRoleGetPayload<T>>

    /**
     * Find the first ActionRole that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActionRoleFindFirstArgs} args - Arguments to find a ActionRole
     * @example
     * // Get one ActionRole
     * const actionRole = await prisma.actionRole.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ActionRoleFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ActionRoleFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ActionRole'> extends True ? Prisma__ActionRoleClient<ActionRoleGetPayload<T>> : Prisma__ActionRoleClient<ActionRoleGetPayload<T> | null, null>

    /**
     * Find the first ActionRole that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActionRoleFindFirstOrThrowArgs} args - Arguments to find a ActionRole
     * @example
     * // Get one ActionRole
     * const actionRole = await prisma.actionRole.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ActionRoleFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ActionRoleFindFirstOrThrowArgs>
    ): Prisma__ActionRoleClient<ActionRoleGetPayload<T>>

    /**
     * Find zero or more ActionRoles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActionRoleFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ActionRoles
     * const actionRoles = await prisma.actionRole.findMany()
     * 
     * // Get first 10 ActionRoles
     * const actionRoles = await prisma.actionRole.findMany({ take: 10 })
     * 
     * // Only select the `action_role_id`
     * const actionRoleWithAction_role_idOnly = await prisma.actionRole.findMany({ select: { action_role_id: true } })
     * 
    **/
    findMany<T extends ActionRoleFindManyArgs>(
      args?: SelectSubset<T, ActionRoleFindManyArgs>
    ): PrismaPromise<Array<ActionRoleGetPayload<T>>>

    /**
     * Create a ActionRole.
     * @param {ActionRoleCreateArgs} args - Arguments to create a ActionRole.
     * @example
     * // Create one ActionRole
     * const ActionRole = await prisma.actionRole.create({
     *   data: {
     *     // ... data to create a ActionRole
     *   }
     * })
     * 
    **/
    create<T extends ActionRoleCreateArgs>(
      args: SelectSubset<T, ActionRoleCreateArgs>
    ): Prisma__ActionRoleClient<ActionRoleGetPayload<T>>

    /**
     * Create many ActionRoles.
     *     @param {ActionRoleCreateManyArgs} args - Arguments to create many ActionRoles.
     *     @example
     *     // Create many ActionRoles
     *     const actionRole = await prisma.actionRole.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ActionRoleCreateManyArgs>(
      args?: SelectSubset<T, ActionRoleCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a ActionRole.
     * @param {ActionRoleDeleteArgs} args - Arguments to delete one ActionRole.
     * @example
     * // Delete one ActionRole
     * const ActionRole = await prisma.actionRole.delete({
     *   where: {
     *     // ... filter to delete one ActionRole
     *   }
     * })
     * 
    **/
    delete<T extends ActionRoleDeleteArgs>(
      args: SelectSubset<T, ActionRoleDeleteArgs>
    ): Prisma__ActionRoleClient<ActionRoleGetPayload<T>>

    /**
     * Update one ActionRole.
     * @param {ActionRoleUpdateArgs} args - Arguments to update one ActionRole.
     * @example
     * // Update one ActionRole
     * const actionRole = await prisma.actionRole.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ActionRoleUpdateArgs>(
      args: SelectSubset<T, ActionRoleUpdateArgs>
    ): Prisma__ActionRoleClient<ActionRoleGetPayload<T>>

    /**
     * Delete zero or more ActionRoles.
     * @param {ActionRoleDeleteManyArgs} args - Arguments to filter ActionRoles to delete.
     * @example
     * // Delete a few ActionRoles
     * const { count } = await prisma.actionRole.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ActionRoleDeleteManyArgs>(
      args?: SelectSubset<T, ActionRoleDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more ActionRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActionRoleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ActionRoles
     * const actionRole = await prisma.actionRole.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ActionRoleUpdateManyArgs>(
      args: SelectSubset<T, ActionRoleUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one ActionRole.
     * @param {ActionRoleUpsertArgs} args - Arguments to update or create a ActionRole.
     * @example
     * // Update or create a ActionRole
     * const actionRole = await prisma.actionRole.upsert({
     *   create: {
     *     // ... data to create a ActionRole
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ActionRole we want to update
     *   }
     * })
    **/
    upsert<T extends ActionRoleUpsertArgs>(
      args: SelectSubset<T, ActionRoleUpsertArgs>
    ): Prisma__ActionRoleClient<ActionRoleGetPayload<T>>

    /**
     * Count the number of ActionRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActionRoleCountArgs} args - Arguments to filter ActionRoles to count.
     * @example
     * // Count the number of ActionRoles
     * const count = await prisma.actionRole.count({
     *   where: {
     *     // ... the filter for the ActionRoles we want to count
     *   }
     * })
    **/
    count<T extends ActionRoleCountArgs>(
      args?: Subset<T, ActionRoleCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ActionRoleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ActionRole.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActionRoleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ActionRoleAggregateArgs>(args: Subset<T, ActionRoleAggregateArgs>): PrismaPromise<GetActionRoleAggregateType<T>>

    /**
     * Group by ActionRole.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActionRoleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ActionRoleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ActionRoleGroupByArgs['orderBy'] }
        : { orderBy?: ActionRoleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ActionRoleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetActionRoleGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for ActionRole.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ActionRoleClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * ActionRole base type for findUnique actions
   */
  export type ActionRoleFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the ActionRole
     * 
    **/
    select?: ActionRoleSelect | null
    /**
     * Filter, which ActionRole to fetch.
     * 
    **/
    where: ActionRoleWhereUniqueInput
  }

  /**
   * ActionRole: findUnique
   */
  export interface ActionRoleFindUniqueArgs extends ActionRoleFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ActionRole findUniqueOrThrow
   */
  export type ActionRoleFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the ActionRole
     * 
    **/
    select?: ActionRoleSelect | null
    /**
     * Filter, which ActionRole to fetch.
     * 
    **/
    where: ActionRoleWhereUniqueInput
  }


  /**
   * ActionRole base type for findFirst actions
   */
  export type ActionRoleFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the ActionRole
     * 
    **/
    select?: ActionRoleSelect | null
    /**
     * Filter, which ActionRole to fetch.
     * 
    **/
    where?: ActionRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActionRoles to fetch.
     * 
    **/
    orderBy?: Enumerable<ActionRoleOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ActionRoles.
     * 
    **/
    cursor?: ActionRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActionRoles from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActionRoles.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ActionRoles.
     * 
    **/
    distinct?: Enumerable<ActionRoleScalarFieldEnum>
  }

  /**
   * ActionRole: findFirst
   */
  export interface ActionRoleFindFirstArgs extends ActionRoleFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ActionRole findFirstOrThrow
   */
  export type ActionRoleFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the ActionRole
     * 
    **/
    select?: ActionRoleSelect | null
    /**
     * Filter, which ActionRole to fetch.
     * 
    **/
    where?: ActionRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActionRoles to fetch.
     * 
    **/
    orderBy?: Enumerable<ActionRoleOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ActionRoles.
     * 
    **/
    cursor?: ActionRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActionRoles from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActionRoles.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ActionRoles.
     * 
    **/
    distinct?: Enumerable<ActionRoleScalarFieldEnum>
  }


  /**
   * ActionRole findMany
   */
  export type ActionRoleFindManyArgs = {
    /**
     * Select specific fields to fetch from the ActionRole
     * 
    **/
    select?: ActionRoleSelect | null
    /**
     * Filter, which ActionRoles to fetch.
     * 
    **/
    where?: ActionRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActionRoles to fetch.
     * 
    **/
    orderBy?: Enumerable<ActionRoleOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ActionRoles.
     * 
    **/
    cursor?: ActionRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActionRoles from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActionRoles.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ActionRoleScalarFieldEnum>
  }


  /**
   * ActionRole create
   */
  export type ActionRoleCreateArgs = {
    /**
     * Select specific fields to fetch from the ActionRole
     * 
    **/
    select?: ActionRoleSelect | null
    /**
     * The data needed to create a ActionRole.
     * 
    **/
    data: XOR<ActionRoleCreateInput, ActionRoleUncheckedCreateInput>
  }


  /**
   * ActionRole createMany
   */
  export type ActionRoleCreateManyArgs = {
    /**
     * The data used to create many ActionRoles.
     * 
    **/
    data: Enumerable<ActionRoleCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * ActionRole update
   */
  export type ActionRoleUpdateArgs = {
    /**
     * Select specific fields to fetch from the ActionRole
     * 
    **/
    select?: ActionRoleSelect | null
    /**
     * The data needed to update a ActionRole.
     * 
    **/
    data: XOR<ActionRoleUpdateInput, ActionRoleUncheckedUpdateInput>
    /**
     * Choose, which ActionRole to update.
     * 
    **/
    where: ActionRoleWhereUniqueInput
  }


  /**
   * ActionRole updateMany
   */
  export type ActionRoleUpdateManyArgs = {
    /**
     * The data used to update ActionRoles.
     * 
    **/
    data: XOR<ActionRoleUpdateManyMutationInput, ActionRoleUncheckedUpdateManyInput>
    /**
     * Filter which ActionRoles to update
     * 
    **/
    where?: ActionRoleWhereInput
  }


  /**
   * ActionRole upsert
   */
  export type ActionRoleUpsertArgs = {
    /**
     * Select specific fields to fetch from the ActionRole
     * 
    **/
    select?: ActionRoleSelect | null
    /**
     * The filter to search for the ActionRole to update in case it exists.
     * 
    **/
    where: ActionRoleWhereUniqueInput
    /**
     * In case the ActionRole found by the `where` argument doesn't exist, create a new ActionRole with this data.
     * 
    **/
    create: XOR<ActionRoleCreateInput, ActionRoleUncheckedCreateInput>
    /**
     * In case the ActionRole was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<ActionRoleUpdateInput, ActionRoleUncheckedUpdateInput>
  }


  /**
   * ActionRole delete
   */
  export type ActionRoleDeleteArgs = {
    /**
     * Select specific fields to fetch from the ActionRole
     * 
    **/
    select?: ActionRoleSelect | null
    /**
     * Filter which ActionRole to delete.
     * 
    **/
    where: ActionRoleWhereUniqueInput
  }


  /**
   * ActionRole deleteMany
   */
  export type ActionRoleDeleteManyArgs = {
    /**
     * Filter which ActionRoles to delete
     * 
    **/
    where?: ActionRoleWhereInput
  }


  /**
   * ActionRole without action
   */
  export type ActionRoleArgs = {
    /**
     * Select specific fields to fetch from the ActionRole
     * 
    **/
    select?: ActionRoleSelect | null
  }



  /**
   * Model Customer
   */


  export type AggregateCustomer = {
    _count: CustomerCountAggregateOutputType | null
    _avg: CustomerAvgAggregateOutputType | null
    _sum: CustomerSumAggregateOutputType | null
    _min: CustomerMinAggregateOutputType | null
    _max: CustomerMaxAggregateOutputType | null
  }

  export type CustomerAvgAggregateOutputType = {
    family_size: number | null
    experienced_year: number | null
    from_data: number | null
  }

  export type CustomerSumAggregateOutputType = {
    family_size: number | null
    experienced_year: number | null
    from_data: number | null
  }

  export type CustomerMinAggregateOutputType = {
    customer_id: string | null
    first_name: string | null
    last_name: string | null
    first_name_kana: string | null
    last_name_kana: string | null
    gender: Gender | null
    birth_date: Date | null
    family_size: number | null
    email: string | null
    mobile: string | null
    phone: string | null
    profile_image: string | null
    cv_file: string | null
    resume_file: string | null
    post_code: string | null
    city: string | null
    district: string | null
    address: string | null
    address1: string | null
    nearest_station: string | null
    country: string | null
    experienced_year: number | null
    from_data: number | null
    status_customer: CustomerStatus | null
    created_at: Date | null
    updated_at: Date | null
    created_by: string | null
    updated_by: string | null
  }

  export type CustomerMaxAggregateOutputType = {
    customer_id: string | null
    first_name: string | null
    last_name: string | null
    first_name_kana: string | null
    last_name_kana: string | null
    gender: Gender | null
    birth_date: Date | null
    family_size: number | null
    email: string | null
    mobile: string | null
    phone: string | null
    profile_image: string | null
    cv_file: string | null
    resume_file: string | null
    post_code: string | null
    city: string | null
    district: string | null
    address: string | null
    address1: string | null
    nearest_station: string | null
    country: string | null
    experienced_year: number | null
    from_data: number | null
    status_customer: CustomerStatus | null
    created_at: Date | null
    updated_at: Date | null
    created_by: string | null
    updated_by: string | null
  }

  export type CustomerCountAggregateOutputType = {
    customer_id: number
    first_name: number
    last_name: number
    first_name_kana: number
    last_name_kana: number
    gender: number
    birth_date: number
    spouse: number
    family_size: number
    email: number
    mobile: number
    phone: number
    profile_image: number
    cv_file: number
    resume_file: number
    prefecture: number
    post_code: number
    city: number
    district: number
    address: number
    address1: number
    nearest_station: number
    socials: number
    country: number
    experienced_year: number
    from_data: number
    status_customer: number
    created_at: number
    updated_at: number
    created_by: number
    updated_by: number
    _all: number
  }


  export type CustomerAvgAggregateInputType = {
    family_size?: true
    experienced_year?: true
    from_data?: true
  }

  export type CustomerSumAggregateInputType = {
    family_size?: true
    experienced_year?: true
    from_data?: true
  }

  export type CustomerMinAggregateInputType = {
    customer_id?: true
    first_name?: true
    last_name?: true
    first_name_kana?: true
    last_name_kana?: true
    gender?: true
    birth_date?: true
    family_size?: true
    email?: true
    mobile?: true
    phone?: true
    profile_image?: true
    cv_file?: true
    resume_file?: true
    post_code?: true
    city?: true
    district?: true
    address?: true
    address1?: true
    nearest_station?: true
    country?: true
    experienced_year?: true
    from_data?: true
    status_customer?: true
    created_at?: true
    updated_at?: true
    created_by?: true
    updated_by?: true
  }

  export type CustomerMaxAggregateInputType = {
    customer_id?: true
    first_name?: true
    last_name?: true
    first_name_kana?: true
    last_name_kana?: true
    gender?: true
    birth_date?: true
    family_size?: true
    email?: true
    mobile?: true
    phone?: true
    profile_image?: true
    cv_file?: true
    resume_file?: true
    post_code?: true
    city?: true
    district?: true
    address?: true
    address1?: true
    nearest_station?: true
    country?: true
    experienced_year?: true
    from_data?: true
    status_customer?: true
    created_at?: true
    updated_at?: true
    created_by?: true
    updated_by?: true
  }

  export type CustomerCountAggregateInputType = {
    customer_id?: true
    first_name?: true
    last_name?: true
    first_name_kana?: true
    last_name_kana?: true
    gender?: true
    birth_date?: true
    spouse?: true
    family_size?: true
    email?: true
    mobile?: true
    phone?: true
    profile_image?: true
    cv_file?: true
    resume_file?: true
    prefecture?: true
    post_code?: true
    city?: true
    district?: true
    address?: true
    address1?: true
    nearest_station?: true
    socials?: true
    country?: true
    experienced_year?: true
    from_data?: true
    status_customer?: true
    created_at?: true
    updated_at?: true
    created_by?: true
    updated_by?: true
    _all?: true
  }

  export type CustomerAggregateArgs = {
    /**
     * Filter which Customer to aggregate.
     * 
    **/
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     * 
    **/
    orderBy?: Enumerable<CustomerOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Customers
    **/
    _count?: true | CustomerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CustomerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CustomerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomerMaxAggregateInputType
  }

  export type GetCustomerAggregateType<T extends CustomerAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomer[P]>
      : GetScalarType<T[P], AggregateCustomer[P]>
  }




  export type CustomerGroupByArgs = {
    where?: CustomerWhereInput
    orderBy?: Enumerable<CustomerOrderByWithAggregationInput>
    by: Array<CustomerScalarFieldEnum>
    having?: CustomerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomerCountAggregateInputType | true
    _avg?: CustomerAvgAggregateInputType
    _sum?: CustomerSumAggregateInputType
    _min?: CustomerMinAggregateInputType
    _max?: CustomerMaxAggregateInputType
  }


  export type CustomerGroupByOutputType = {
    customer_id: string
    first_name: string
    last_name: string
    first_name_kana: string
    last_name_kana: string
    gender: Gender | null
    birth_date: Date | null
    spouse: JsonValue | null
    family_size: number | null
    email: string | null
    mobile: string | null
    phone: string | null
    profile_image: string | null
    cv_file: string | null
    resume_file: string | null
    prefecture: JsonValue | null
    post_code: string | null
    city: string | null
    district: string | null
    address: string | null
    address1: string | null
    nearest_station: string | null
    socials: JsonValue | null
    country: string | null
    experienced_year: number | null
    from_data: number | null
    status_customer: CustomerStatus | null
    created_at: Date
    updated_at: Date
    created_by: string | null
    updated_by: string | null
    _count: CustomerCountAggregateOutputType | null
    _avg: CustomerAvgAggregateOutputType | null
    _sum: CustomerSumAggregateOutputType | null
    _min: CustomerMinAggregateOutputType | null
    _max: CustomerMaxAggregateOutputType | null
  }

  type GetCustomerGroupByPayload<T extends CustomerGroupByArgs> = PrismaPromise<
    Array<
      PickArray<CustomerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomerGroupByOutputType[P]>
            : GetScalarType<T[P], CustomerGroupByOutputType[P]>
        }
      >
    >


  export type CustomerSelect = {
    customer_id?: boolean
    first_name?: boolean
    last_name?: boolean
    first_name_kana?: boolean
    last_name_kana?: boolean
    gender?: boolean
    birth_date?: boolean
    spouse?: boolean
    family_size?: boolean
    email?: boolean
    mobile?: boolean
    phone?: boolean
    profile_image?: boolean
    cv_file?: boolean
    resume_file?: boolean
    prefecture?: boolean
    post_code?: boolean
    city?: boolean
    district?: boolean
    address?: boolean
    address1?: boolean
    nearest_station?: boolean
    socials?: boolean
    country?: boolean
    experienced_year?: boolean
    from_data?: boolean
    status_customer?: boolean
    created_at?: boolean
    updated_at?: boolean
    created_by?: boolean
    updated_by?: boolean
    user?: boolean | UserArgs
    customer_visas?: boolean | CustomerVisaFindManyArgs
    customer_jobdetails?: boolean | CustomerJobDetailFindManyArgs
    customer_educations?: boolean | CustomerEducationFindManyArgs
    customer_languages?: boolean | CustomerLanguageFindManyArgs
    customer_qualifications?: boolean | CustomerQualificationFindManyArgs
    customer_workhistories?: boolean | CustomerWorkHistoryFindManyArgs
    job_candidates?: boolean | JobCandidateFindManyArgs
    customer_desired?: boolean | CustomerDesiredFindManyArgs
    _count?: boolean | CustomerCountOutputTypeArgs
  }


  export type CustomerInclude = {
    user?: boolean | UserArgs
    customer_visas?: boolean | CustomerVisaFindManyArgs
    customer_jobdetails?: boolean | CustomerJobDetailFindManyArgs
    customer_educations?: boolean | CustomerEducationFindManyArgs
    customer_languages?: boolean | CustomerLanguageFindManyArgs
    customer_qualifications?: boolean | CustomerQualificationFindManyArgs
    customer_workhistories?: boolean | CustomerWorkHistoryFindManyArgs
    job_candidates?: boolean | JobCandidateFindManyArgs
    customer_desired?: boolean | CustomerDesiredFindManyArgs
    _count?: boolean | CustomerCountOutputTypeArgs
  } 

  export type CustomerGetPayload<S extends boolean | null | undefined | CustomerArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Customer :
    S extends undefined ? never :
    S extends { include: any } & (CustomerArgs | CustomerFindManyArgs)
    ? Customer  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'user' ? UserGetPayload<S['include'][P]> | null :
        P extends 'customer_visas' ? Array < CustomerVisaGetPayload<S['include'][P]>>  :
        P extends 'customer_jobdetails' ? Array < CustomerJobDetailGetPayload<S['include'][P]>>  :
        P extends 'customer_educations' ? Array < CustomerEducationGetPayload<S['include'][P]>>  :
        P extends 'customer_languages' ? Array < CustomerLanguageGetPayload<S['include'][P]>>  :
        P extends 'customer_qualifications' ? Array < CustomerQualificationGetPayload<S['include'][P]>>  :
        P extends 'customer_workhistories' ? Array < CustomerWorkHistoryGetPayload<S['include'][P]>>  :
        P extends 'job_candidates' ? Array < JobCandidateGetPayload<S['include'][P]>>  :
        P extends 'customer_desired' ? Array < CustomerDesiredGetPayload<S['include'][P]>>  :
        P extends '_count' ? CustomerCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (CustomerArgs | CustomerFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'user' ? UserGetPayload<S['select'][P]> | null :
        P extends 'customer_visas' ? Array < CustomerVisaGetPayload<S['select'][P]>>  :
        P extends 'customer_jobdetails' ? Array < CustomerJobDetailGetPayload<S['select'][P]>>  :
        P extends 'customer_educations' ? Array < CustomerEducationGetPayload<S['select'][P]>>  :
        P extends 'customer_languages' ? Array < CustomerLanguageGetPayload<S['select'][P]>>  :
        P extends 'customer_qualifications' ? Array < CustomerQualificationGetPayload<S['select'][P]>>  :
        P extends 'customer_workhistories' ? Array < CustomerWorkHistoryGetPayload<S['select'][P]>>  :
        P extends 'job_candidates' ? Array < JobCandidateGetPayload<S['select'][P]>>  :
        P extends 'customer_desired' ? Array < CustomerDesiredGetPayload<S['select'][P]>>  :
        P extends '_count' ? CustomerCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Customer ? Customer[P] : never
  } 
      : Customer


  type CustomerCountArgs = Merge<
    Omit<CustomerFindManyArgs, 'select' | 'include'> & {
      select?: CustomerCountAggregateInputType | true
    }
  >

  export interface CustomerDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Customer that matches the filter.
     * @param {CustomerFindUniqueArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CustomerFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CustomerFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Customer'> extends True ? Prisma__CustomerClient<CustomerGetPayload<T>> : Prisma__CustomerClient<CustomerGetPayload<T> | null, null>

    /**
     * Find one Customer that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CustomerFindUniqueOrThrowArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CustomerFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, CustomerFindUniqueOrThrowArgs>
    ): Prisma__CustomerClient<CustomerGetPayload<T>>

    /**
     * Find the first Customer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindFirstArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CustomerFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CustomerFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Customer'> extends True ? Prisma__CustomerClient<CustomerGetPayload<T>> : Prisma__CustomerClient<CustomerGetPayload<T> | null, null>

    /**
     * Find the first Customer that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindFirstOrThrowArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CustomerFindFirstOrThrowArgs>(
      args?: SelectSubset<T, CustomerFindFirstOrThrowArgs>
    ): Prisma__CustomerClient<CustomerGetPayload<T>>

    /**
     * Find zero or more Customers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Customers
     * const customers = await prisma.customer.findMany()
     * 
     * // Get first 10 Customers
     * const customers = await prisma.customer.findMany({ take: 10 })
     * 
     * // Only select the `customer_id`
     * const customerWithCustomer_idOnly = await prisma.customer.findMany({ select: { customer_id: true } })
     * 
    **/
    findMany<T extends CustomerFindManyArgs>(
      args?: SelectSubset<T, CustomerFindManyArgs>
    ): PrismaPromise<Array<CustomerGetPayload<T>>>

    /**
     * Create a Customer.
     * @param {CustomerCreateArgs} args - Arguments to create a Customer.
     * @example
     * // Create one Customer
     * const Customer = await prisma.customer.create({
     *   data: {
     *     // ... data to create a Customer
     *   }
     * })
     * 
    **/
    create<T extends CustomerCreateArgs>(
      args: SelectSubset<T, CustomerCreateArgs>
    ): Prisma__CustomerClient<CustomerGetPayload<T>>

    /**
     * Create many Customers.
     *     @param {CustomerCreateManyArgs} args - Arguments to create many Customers.
     *     @example
     *     // Create many Customers
     *     const customer = await prisma.customer.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CustomerCreateManyArgs>(
      args?: SelectSubset<T, CustomerCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Customer.
     * @param {CustomerDeleteArgs} args - Arguments to delete one Customer.
     * @example
     * // Delete one Customer
     * const Customer = await prisma.customer.delete({
     *   where: {
     *     // ... filter to delete one Customer
     *   }
     * })
     * 
    **/
    delete<T extends CustomerDeleteArgs>(
      args: SelectSubset<T, CustomerDeleteArgs>
    ): Prisma__CustomerClient<CustomerGetPayload<T>>

    /**
     * Update one Customer.
     * @param {CustomerUpdateArgs} args - Arguments to update one Customer.
     * @example
     * // Update one Customer
     * const customer = await prisma.customer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CustomerUpdateArgs>(
      args: SelectSubset<T, CustomerUpdateArgs>
    ): Prisma__CustomerClient<CustomerGetPayload<T>>

    /**
     * Delete zero or more Customers.
     * @param {CustomerDeleteManyArgs} args - Arguments to filter Customers to delete.
     * @example
     * // Delete a few Customers
     * const { count } = await prisma.customer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CustomerDeleteManyArgs>(
      args?: SelectSubset<T, CustomerDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Customers
     * const customer = await prisma.customer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CustomerUpdateManyArgs>(
      args: SelectSubset<T, CustomerUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Customer.
     * @param {CustomerUpsertArgs} args - Arguments to update or create a Customer.
     * @example
     * // Update or create a Customer
     * const customer = await prisma.customer.upsert({
     *   create: {
     *     // ... data to create a Customer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Customer we want to update
     *   }
     * })
    **/
    upsert<T extends CustomerUpsertArgs>(
      args: SelectSubset<T, CustomerUpsertArgs>
    ): Prisma__CustomerClient<CustomerGetPayload<T>>

    /**
     * Count the number of Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerCountArgs} args - Arguments to filter Customers to count.
     * @example
     * // Count the number of Customers
     * const count = await prisma.customer.count({
     *   where: {
     *     // ... the filter for the Customers we want to count
     *   }
     * })
    **/
    count<T extends CustomerCountArgs>(
      args?: Subset<T, CustomerCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Customer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomerAggregateArgs>(args: Subset<T, CustomerAggregateArgs>): PrismaPromise<GetCustomerAggregateType<T>>

    /**
     * Group by Customer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CustomerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CustomerGroupByArgs['orderBy'] }
        : { orderBy?: CustomerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CustomerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomerGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Customer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CustomerClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    user<T extends UserArgs= {}>(args?: Subset<T, UserArgs>): Prisma__UserClient<UserGetPayload<T> | Null>;

    customer_visas<T extends CustomerVisaFindManyArgs= {}>(args?: Subset<T, CustomerVisaFindManyArgs>): PrismaPromise<Array<CustomerVisaGetPayload<T>>| Null>;

    customer_jobdetails<T extends CustomerJobDetailFindManyArgs= {}>(args?: Subset<T, CustomerJobDetailFindManyArgs>): PrismaPromise<Array<CustomerJobDetailGetPayload<T>>| Null>;

    customer_educations<T extends CustomerEducationFindManyArgs= {}>(args?: Subset<T, CustomerEducationFindManyArgs>): PrismaPromise<Array<CustomerEducationGetPayload<T>>| Null>;

    customer_languages<T extends CustomerLanguageFindManyArgs= {}>(args?: Subset<T, CustomerLanguageFindManyArgs>): PrismaPromise<Array<CustomerLanguageGetPayload<T>>| Null>;

    customer_qualifications<T extends CustomerQualificationFindManyArgs= {}>(args?: Subset<T, CustomerQualificationFindManyArgs>): PrismaPromise<Array<CustomerQualificationGetPayload<T>>| Null>;

    customer_workhistories<T extends CustomerWorkHistoryFindManyArgs= {}>(args?: Subset<T, CustomerWorkHistoryFindManyArgs>): PrismaPromise<Array<CustomerWorkHistoryGetPayload<T>>| Null>;

    job_candidates<T extends JobCandidateFindManyArgs= {}>(args?: Subset<T, JobCandidateFindManyArgs>): PrismaPromise<Array<JobCandidateGetPayload<T>>| Null>;

    customer_desired<T extends CustomerDesiredFindManyArgs= {}>(args?: Subset<T, CustomerDesiredFindManyArgs>): PrismaPromise<Array<CustomerDesiredGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Customer base type for findUnique actions
   */
  export type CustomerFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Customer
     * 
    **/
    select?: CustomerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CustomerInclude | null
    /**
     * Filter, which Customer to fetch.
     * 
    **/
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer: findUnique
   */
  export interface CustomerFindUniqueArgs extends CustomerFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Customer findUniqueOrThrow
   */
  export type CustomerFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Customer
     * 
    **/
    select?: CustomerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CustomerInclude | null
    /**
     * Filter, which Customer to fetch.
     * 
    **/
    where: CustomerWhereUniqueInput
  }


  /**
   * Customer base type for findFirst actions
   */
  export type CustomerFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Customer
     * 
    **/
    select?: CustomerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CustomerInclude | null
    /**
     * Filter, which Customer to fetch.
     * 
    **/
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     * 
    **/
    orderBy?: Enumerable<CustomerOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Customers.
     * 
    **/
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Customers.
     * 
    **/
    distinct?: Enumerable<CustomerScalarFieldEnum>
  }

  /**
   * Customer: findFirst
   */
  export interface CustomerFindFirstArgs extends CustomerFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Customer findFirstOrThrow
   */
  export type CustomerFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Customer
     * 
    **/
    select?: CustomerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CustomerInclude | null
    /**
     * Filter, which Customer to fetch.
     * 
    **/
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     * 
    **/
    orderBy?: Enumerable<CustomerOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Customers.
     * 
    **/
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Customers.
     * 
    **/
    distinct?: Enumerable<CustomerScalarFieldEnum>
  }


  /**
   * Customer findMany
   */
  export type CustomerFindManyArgs = {
    /**
     * Select specific fields to fetch from the Customer
     * 
    **/
    select?: CustomerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CustomerInclude | null
    /**
     * Filter, which Customers to fetch.
     * 
    **/
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     * 
    **/
    orderBy?: Enumerable<CustomerOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Customers.
     * 
    **/
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     * 
    **/
    skip?: number
    distinct?: Enumerable<CustomerScalarFieldEnum>
  }


  /**
   * Customer create
   */
  export type CustomerCreateArgs = {
    /**
     * Select specific fields to fetch from the Customer
     * 
    **/
    select?: CustomerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CustomerInclude | null
    /**
     * The data needed to create a Customer.
     * 
    **/
    data: XOR<CustomerCreateInput, CustomerUncheckedCreateInput>
  }


  /**
   * Customer createMany
   */
  export type CustomerCreateManyArgs = {
    /**
     * The data used to create many Customers.
     * 
    **/
    data: Enumerable<CustomerCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Customer update
   */
  export type CustomerUpdateArgs = {
    /**
     * Select specific fields to fetch from the Customer
     * 
    **/
    select?: CustomerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CustomerInclude | null
    /**
     * The data needed to update a Customer.
     * 
    **/
    data: XOR<CustomerUpdateInput, CustomerUncheckedUpdateInput>
    /**
     * Choose, which Customer to update.
     * 
    **/
    where: CustomerWhereUniqueInput
  }


  /**
   * Customer updateMany
   */
  export type CustomerUpdateManyArgs = {
    /**
     * The data used to update Customers.
     * 
    **/
    data: XOR<CustomerUpdateManyMutationInput, CustomerUncheckedUpdateManyInput>
    /**
     * Filter which Customers to update
     * 
    **/
    where?: CustomerWhereInput
  }


  /**
   * Customer upsert
   */
  export type CustomerUpsertArgs = {
    /**
     * Select specific fields to fetch from the Customer
     * 
    **/
    select?: CustomerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CustomerInclude | null
    /**
     * The filter to search for the Customer to update in case it exists.
     * 
    **/
    where: CustomerWhereUniqueInput
    /**
     * In case the Customer found by the `where` argument doesn't exist, create a new Customer with this data.
     * 
    **/
    create: XOR<CustomerCreateInput, CustomerUncheckedCreateInput>
    /**
     * In case the Customer was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<CustomerUpdateInput, CustomerUncheckedUpdateInput>
  }


  /**
   * Customer delete
   */
  export type CustomerDeleteArgs = {
    /**
     * Select specific fields to fetch from the Customer
     * 
    **/
    select?: CustomerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CustomerInclude | null
    /**
     * Filter which Customer to delete.
     * 
    **/
    where: CustomerWhereUniqueInput
  }


  /**
   * Customer deleteMany
   */
  export type CustomerDeleteManyArgs = {
    /**
     * Filter which Customers to delete
     * 
    **/
    where?: CustomerWhereInput
  }


  /**
   * Customer without action
   */
  export type CustomerArgs = {
    /**
     * Select specific fields to fetch from the Customer
     * 
    **/
    select?: CustomerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CustomerInclude | null
  }



  /**
   * Model CustomerDesired
   */


  export type AggregateCustomerDesired = {
    _count: CustomerDesiredCountAggregateOutputType | null
    _avg: CustomerDesiredAvgAggregateOutputType | null
    _sum: CustomerDesiredSumAggregateOutputType | null
    _min: CustomerDesiredMinAggregateOutputType | null
    _max: CustomerDesiredMaxAggregateOutputType | null
  }

  export type CustomerDesiredAvgAggregateOutputType = {
    annual_income: number | null
  }

  export type CustomerDesiredSumAggregateOutputType = {
    annual_income: number | null
  }

  export type CustomerDesiredMinAggregateOutputType = {
    desired_id: string | null
    customer_id: string | null
    time_to: string | null
    annual_income: number | null
    created_at: Date | null
    updated_at: Date | null
    created_by: string | null
    updated_by: string | null
  }

  export type CustomerDesiredMaxAggregateOutputType = {
    desired_id: string | null
    customer_id: string | null
    time_to: string | null
    annual_income: number | null
    created_at: Date | null
    updated_at: Date | null
    created_by: string | null
    updated_by: string | null
  }

  export type CustomerDesiredCountAggregateOutputType = {
    desired_id: number
    customer_id: number
    occupation: number
    industry: number
    location: number
    career_level: number
    contract_type: number
    desired_company: number
    time_to: number
    annual_income: number
    created_at: number
    updated_at: number
    created_by: number
    updated_by: number
    _all: number
  }


  export type CustomerDesiredAvgAggregateInputType = {
    annual_income?: true
  }

  export type CustomerDesiredSumAggregateInputType = {
    annual_income?: true
  }

  export type CustomerDesiredMinAggregateInputType = {
    desired_id?: true
    customer_id?: true
    time_to?: true
    annual_income?: true
    created_at?: true
    updated_at?: true
    created_by?: true
    updated_by?: true
  }

  export type CustomerDesiredMaxAggregateInputType = {
    desired_id?: true
    customer_id?: true
    time_to?: true
    annual_income?: true
    created_at?: true
    updated_at?: true
    created_by?: true
    updated_by?: true
  }

  export type CustomerDesiredCountAggregateInputType = {
    desired_id?: true
    customer_id?: true
    occupation?: true
    industry?: true
    location?: true
    career_level?: true
    contract_type?: true
    desired_company?: true
    time_to?: true
    annual_income?: true
    created_at?: true
    updated_at?: true
    created_by?: true
    updated_by?: true
    _all?: true
  }

  export type CustomerDesiredAggregateArgs = {
    /**
     * Filter which CustomerDesired to aggregate.
     * 
    **/
    where?: CustomerDesiredWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerDesireds to fetch.
     * 
    **/
    orderBy?: Enumerable<CustomerDesiredOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: CustomerDesiredWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerDesireds from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerDesireds.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CustomerDesireds
    **/
    _count?: true | CustomerDesiredCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CustomerDesiredAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CustomerDesiredSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomerDesiredMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomerDesiredMaxAggregateInputType
  }

  export type GetCustomerDesiredAggregateType<T extends CustomerDesiredAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomerDesired]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomerDesired[P]>
      : GetScalarType<T[P], AggregateCustomerDesired[P]>
  }




  export type CustomerDesiredGroupByArgs = {
    where?: CustomerDesiredWhereInput
    orderBy?: Enumerable<CustomerDesiredOrderByWithAggregationInput>
    by: Array<CustomerDesiredScalarFieldEnum>
    having?: CustomerDesiredScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomerDesiredCountAggregateInputType | true
    _avg?: CustomerDesiredAvgAggregateInputType
    _sum?: CustomerDesiredSumAggregateInputType
    _min?: CustomerDesiredMinAggregateInputType
    _max?: CustomerDesiredMaxAggregateInputType
  }


  export type CustomerDesiredGroupByOutputType = {
    desired_id: string
    customer_id: string | null
    occupation: JsonValue[]
    industry: JsonValue[]
    location: JsonValue[]
    career_level: JsonValue[]
    contract_type: JsonValue[]
    desired_company: JsonValue[]
    time_to: string
    annual_income: number
    created_at: Date
    updated_at: Date
    created_by: string | null
    updated_by: string | null
    _count: CustomerDesiredCountAggregateOutputType | null
    _avg: CustomerDesiredAvgAggregateOutputType | null
    _sum: CustomerDesiredSumAggregateOutputType | null
    _min: CustomerDesiredMinAggregateOutputType | null
    _max: CustomerDesiredMaxAggregateOutputType | null
  }

  type GetCustomerDesiredGroupByPayload<T extends CustomerDesiredGroupByArgs> = PrismaPromise<
    Array<
      PickArray<CustomerDesiredGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomerDesiredGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomerDesiredGroupByOutputType[P]>
            : GetScalarType<T[P], CustomerDesiredGroupByOutputType[P]>
        }
      >
    >


  export type CustomerDesiredSelect = {
    desired_id?: boolean
    customer?: boolean | CustomerArgs
    customer_id?: boolean
    occupation?: boolean
    industry?: boolean
    location?: boolean
    career_level?: boolean
    contract_type?: boolean
    desired_company?: boolean
    time_to?: boolean
    annual_income?: boolean
    created_at?: boolean
    updated_at?: boolean
    created_by?: boolean
    updated_by?: boolean
  }


  export type CustomerDesiredInclude = {
    customer?: boolean | CustomerArgs
  } 

  export type CustomerDesiredGetPayload<S extends boolean | null | undefined | CustomerDesiredArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? CustomerDesired :
    S extends undefined ? never :
    S extends { include: any } & (CustomerDesiredArgs | CustomerDesiredFindManyArgs)
    ? CustomerDesired  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'customer' ? CustomerGetPayload<S['include'][P]> | null :  never
  } 
    : S extends { select: any } & (CustomerDesiredArgs | CustomerDesiredFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'customer' ? CustomerGetPayload<S['select'][P]> | null :  P extends keyof CustomerDesired ? CustomerDesired[P] : never
  } 
      : CustomerDesired


  type CustomerDesiredCountArgs = Merge<
    Omit<CustomerDesiredFindManyArgs, 'select' | 'include'> & {
      select?: CustomerDesiredCountAggregateInputType | true
    }
  >

  export interface CustomerDesiredDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one CustomerDesired that matches the filter.
     * @param {CustomerDesiredFindUniqueArgs} args - Arguments to find a CustomerDesired
     * @example
     * // Get one CustomerDesired
     * const customerDesired = await prisma.customerDesired.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CustomerDesiredFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CustomerDesiredFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'CustomerDesired'> extends True ? Prisma__CustomerDesiredClient<CustomerDesiredGetPayload<T>> : Prisma__CustomerDesiredClient<CustomerDesiredGetPayload<T> | null, null>

    /**
     * Find one CustomerDesired that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CustomerDesiredFindUniqueOrThrowArgs} args - Arguments to find a CustomerDesired
     * @example
     * // Get one CustomerDesired
     * const customerDesired = await prisma.customerDesired.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CustomerDesiredFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, CustomerDesiredFindUniqueOrThrowArgs>
    ): Prisma__CustomerDesiredClient<CustomerDesiredGetPayload<T>>

    /**
     * Find the first CustomerDesired that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerDesiredFindFirstArgs} args - Arguments to find a CustomerDesired
     * @example
     * // Get one CustomerDesired
     * const customerDesired = await prisma.customerDesired.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CustomerDesiredFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CustomerDesiredFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'CustomerDesired'> extends True ? Prisma__CustomerDesiredClient<CustomerDesiredGetPayload<T>> : Prisma__CustomerDesiredClient<CustomerDesiredGetPayload<T> | null, null>

    /**
     * Find the first CustomerDesired that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerDesiredFindFirstOrThrowArgs} args - Arguments to find a CustomerDesired
     * @example
     * // Get one CustomerDesired
     * const customerDesired = await prisma.customerDesired.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CustomerDesiredFindFirstOrThrowArgs>(
      args?: SelectSubset<T, CustomerDesiredFindFirstOrThrowArgs>
    ): Prisma__CustomerDesiredClient<CustomerDesiredGetPayload<T>>

    /**
     * Find zero or more CustomerDesireds that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerDesiredFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CustomerDesireds
     * const customerDesireds = await prisma.customerDesired.findMany()
     * 
     * // Get first 10 CustomerDesireds
     * const customerDesireds = await prisma.customerDesired.findMany({ take: 10 })
     * 
     * // Only select the `desired_id`
     * const customerDesiredWithDesired_idOnly = await prisma.customerDesired.findMany({ select: { desired_id: true } })
     * 
    **/
    findMany<T extends CustomerDesiredFindManyArgs>(
      args?: SelectSubset<T, CustomerDesiredFindManyArgs>
    ): PrismaPromise<Array<CustomerDesiredGetPayload<T>>>

    /**
     * Create a CustomerDesired.
     * @param {CustomerDesiredCreateArgs} args - Arguments to create a CustomerDesired.
     * @example
     * // Create one CustomerDesired
     * const CustomerDesired = await prisma.customerDesired.create({
     *   data: {
     *     // ... data to create a CustomerDesired
     *   }
     * })
     * 
    **/
    create<T extends CustomerDesiredCreateArgs>(
      args: SelectSubset<T, CustomerDesiredCreateArgs>
    ): Prisma__CustomerDesiredClient<CustomerDesiredGetPayload<T>>

    /**
     * Create many CustomerDesireds.
     *     @param {CustomerDesiredCreateManyArgs} args - Arguments to create many CustomerDesireds.
     *     @example
     *     // Create many CustomerDesireds
     *     const customerDesired = await prisma.customerDesired.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CustomerDesiredCreateManyArgs>(
      args?: SelectSubset<T, CustomerDesiredCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a CustomerDesired.
     * @param {CustomerDesiredDeleteArgs} args - Arguments to delete one CustomerDesired.
     * @example
     * // Delete one CustomerDesired
     * const CustomerDesired = await prisma.customerDesired.delete({
     *   where: {
     *     // ... filter to delete one CustomerDesired
     *   }
     * })
     * 
    **/
    delete<T extends CustomerDesiredDeleteArgs>(
      args: SelectSubset<T, CustomerDesiredDeleteArgs>
    ): Prisma__CustomerDesiredClient<CustomerDesiredGetPayload<T>>

    /**
     * Update one CustomerDesired.
     * @param {CustomerDesiredUpdateArgs} args - Arguments to update one CustomerDesired.
     * @example
     * // Update one CustomerDesired
     * const customerDesired = await prisma.customerDesired.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CustomerDesiredUpdateArgs>(
      args: SelectSubset<T, CustomerDesiredUpdateArgs>
    ): Prisma__CustomerDesiredClient<CustomerDesiredGetPayload<T>>

    /**
     * Delete zero or more CustomerDesireds.
     * @param {CustomerDesiredDeleteManyArgs} args - Arguments to filter CustomerDesireds to delete.
     * @example
     * // Delete a few CustomerDesireds
     * const { count } = await prisma.customerDesired.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CustomerDesiredDeleteManyArgs>(
      args?: SelectSubset<T, CustomerDesiredDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more CustomerDesireds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerDesiredUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CustomerDesireds
     * const customerDesired = await prisma.customerDesired.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CustomerDesiredUpdateManyArgs>(
      args: SelectSubset<T, CustomerDesiredUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one CustomerDesired.
     * @param {CustomerDesiredUpsertArgs} args - Arguments to update or create a CustomerDesired.
     * @example
     * // Update or create a CustomerDesired
     * const customerDesired = await prisma.customerDesired.upsert({
     *   create: {
     *     // ... data to create a CustomerDesired
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CustomerDesired we want to update
     *   }
     * })
    **/
    upsert<T extends CustomerDesiredUpsertArgs>(
      args: SelectSubset<T, CustomerDesiredUpsertArgs>
    ): Prisma__CustomerDesiredClient<CustomerDesiredGetPayload<T>>

    /**
     * Count the number of CustomerDesireds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerDesiredCountArgs} args - Arguments to filter CustomerDesireds to count.
     * @example
     * // Count the number of CustomerDesireds
     * const count = await prisma.customerDesired.count({
     *   where: {
     *     // ... the filter for the CustomerDesireds we want to count
     *   }
     * })
    **/
    count<T extends CustomerDesiredCountArgs>(
      args?: Subset<T, CustomerDesiredCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomerDesiredCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CustomerDesired.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerDesiredAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomerDesiredAggregateArgs>(args: Subset<T, CustomerDesiredAggregateArgs>): PrismaPromise<GetCustomerDesiredAggregateType<T>>

    /**
     * Group by CustomerDesired.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerDesiredGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CustomerDesiredGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CustomerDesiredGroupByArgs['orderBy'] }
        : { orderBy?: CustomerDesiredGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CustomerDesiredGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomerDesiredGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for CustomerDesired.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CustomerDesiredClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    customer<T extends CustomerArgs= {}>(args?: Subset<T, CustomerArgs>): Prisma__CustomerClient<CustomerGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * CustomerDesired base type for findUnique actions
   */
  export type CustomerDesiredFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the CustomerDesired
     * 
    **/
    select?: CustomerDesiredSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CustomerDesiredInclude | null
    /**
     * Filter, which CustomerDesired to fetch.
     * 
    **/
    where: CustomerDesiredWhereUniqueInput
  }

  /**
   * CustomerDesired: findUnique
   */
  export interface CustomerDesiredFindUniqueArgs extends CustomerDesiredFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * CustomerDesired findUniqueOrThrow
   */
  export type CustomerDesiredFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the CustomerDesired
     * 
    **/
    select?: CustomerDesiredSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CustomerDesiredInclude | null
    /**
     * Filter, which CustomerDesired to fetch.
     * 
    **/
    where: CustomerDesiredWhereUniqueInput
  }


  /**
   * CustomerDesired base type for findFirst actions
   */
  export type CustomerDesiredFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the CustomerDesired
     * 
    **/
    select?: CustomerDesiredSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CustomerDesiredInclude | null
    /**
     * Filter, which CustomerDesired to fetch.
     * 
    **/
    where?: CustomerDesiredWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerDesireds to fetch.
     * 
    **/
    orderBy?: Enumerable<CustomerDesiredOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CustomerDesireds.
     * 
    **/
    cursor?: CustomerDesiredWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerDesireds from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerDesireds.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CustomerDesireds.
     * 
    **/
    distinct?: Enumerable<CustomerDesiredScalarFieldEnum>
  }

  /**
   * CustomerDesired: findFirst
   */
  export interface CustomerDesiredFindFirstArgs extends CustomerDesiredFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * CustomerDesired findFirstOrThrow
   */
  export type CustomerDesiredFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the CustomerDesired
     * 
    **/
    select?: CustomerDesiredSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CustomerDesiredInclude | null
    /**
     * Filter, which CustomerDesired to fetch.
     * 
    **/
    where?: CustomerDesiredWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerDesireds to fetch.
     * 
    **/
    orderBy?: Enumerable<CustomerDesiredOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CustomerDesireds.
     * 
    **/
    cursor?: CustomerDesiredWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerDesireds from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerDesireds.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CustomerDesireds.
     * 
    **/
    distinct?: Enumerable<CustomerDesiredScalarFieldEnum>
  }


  /**
   * CustomerDesired findMany
   */
  export type CustomerDesiredFindManyArgs = {
    /**
     * Select specific fields to fetch from the CustomerDesired
     * 
    **/
    select?: CustomerDesiredSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CustomerDesiredInclude | null
    /**
     * Filter, which CustomerDesireds to fetch.
     * 
    **/
    where?: CustomerDesiredWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerDesireds to fetch.
     * 
    **/
    orderBy?: Enumerable<CustomerDesiredOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CustomerDesireds.
     * 
    **/
    cursor?: CustomerDesiredWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerDesireds from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerDesireds.
     * 
    **/
    skip?: number
    distinct?: Enumerable<CustomerDesiredScalarFieldEnum>
  }


  /**
   * CustomerDesired create
   */
  export type CustomerDesiredCreateArgs = {
    /**
     * Select specific fields to fetch from the CustomerDesired
     * 
    **/
    select?: CustomerDesiredSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CustomerDesiredInclude | null
    /**
     * The data needed to create a CustomerDesired.
     * 
    **/
    data: XOR<CustomerDesiredCreateInput, CustomerDesiredUncheckedCreateInput>
  }


  /**
   * CustomerDesired createMany
   */
  export type CustomerDesiredCreateManyArgs = {
    /**
     * The data used to create many CustomerDesireds.
     * 
    **/
    data: Enumerable<CustomerDesiredCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * CustomerDesired update
   */
  export type CustomerDesiredUpdateArgs = {
    /**
     * Select specific fields to fetch from the CustomerDesired
     * 
    **/
    select?: CustomerDesiredSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CustomerDesiredInclude | null
    /**
     * The data needed to update a CustomerDesired.
     * 
    **/
    data: XOR<CustomerDesiredUpdateInput, CustomerDesiredUncheckedUpdateInput>
    /**
     * Choose, which CustomerDesired to update.
     * 
    **/
    where: CustomerDesiredWhereUniqueInput
  }


  /**
   * CustomerDesired updateMany
   */
  export type CustomerDesiredUpdateManyArgs = {
    /**
     * The data used to update CustomerDesireds.
     * 
    **/
    data: XOR<CustomerDesiredUpdateManyMutationInput, CustomerDesiredUncheckedUpdateManyInput>
    /**
     * Filter which CustomerDesireds to update
     * 
    **/
    where?: CustomerDesiredWhereInput
  }


  /**
   * CustomerDesired upsert
   */
  export type CustomerDesiredUpsertArgs = {
    /**
     * Select specific fields to fetch from the CustomerDesired
     * 
    **/
    select?: CustomerDesiredSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CustomerDesiredInclude | null
    /**
     * The filter to search for the CustomerDesired to update in case it exists.
     * 
    **/
    where: CustomerDesiredWhereUniqueInput
    /**
     * In case the CustomerDesired found by the `where` argument doesn't exist, create a new CustomerDesired with this data.
     * 
    **/
    create: XOR<CustomerDesiredCreateInput, CustomerDesiredUncheckedCreateInput>
    /**
     * In case the CustomerDesired was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<CustomerDesiredUpdateInput, CustomerDesiredUncheckedUpdateInput>
  }


  /**
   * CustomerDesired delete
   */
  export type CustomerDesiredDeleteArgs = {
    /**
     * Select specific fields to fetch from the CustomerDesired
     * 
    **/
    select?: CustomerDesiredSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CustomerDesiredInclude | null
    /**
     * Filter which CustomerDesired to delete.
     * 
    **/
    where: CustomerDesiredWhereUniqueInput
  }


  /**
   * CustomerDesired deleteMany
   */
  export type CustomerDesiredDeleteManyArgs = {
    /**
     * Filter which CustomerDesireds to delete
     * 
    **/
    where?: CustomerDesiredWhereInput
  }


  /**
   * CustomerDesired without action
   */
  export type CustomerDesiredArgs = {
    /**
     * Select specific fields to fetch from the CustomerDesired
     * 
    **/
    select?: CustomerDesiredSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CustomerDesiredInclude | null
  }



  /**
   * Model CustomerEducation
   */


  export type AggregateCustomerEducation = {
    _count: CustomerEducationCountAggregateOutputType | null
    _avg: CustomerEducationAvgAggregateOutputType | null
    _sum: CustomerEducationSumAggregateOutputType | null
    _min: CustomerEducationMinAggregateOutputType | null
    _max: CustomerEducationMaxAggregateOutputType | null
  }

  export type CustomerEducationAvgAggregateOutputType = {
    school_id: number | null
  }

  export type CustomerEducationSumAggregateOutputType = {
    school_id: number | null
  }

  export type CustomerEducationMinAggregateOutputType = {
    education_id: string | null
    customer_id: string | null
    country: string | null
    entrollment_date: Date | null
    graduate_date: Date | null
    is_current: boolean | null
    school_id: number | null
    faculty: string | null
    department: string | null
    created_at: Date | null
    updated_at: Date | null
    created_by: string | null
    updated_by: string | null
  }

  export type CustomerEducationMaxAggregateOutputType = {
    education_id: string | null
    customer_id: string | null
    country: string | null
    entrollment_date: Date | null
    graduate_date: Date | null
    is_current: boolean | null
    school_id: number | null
    faculty: string | null
    department: string | null
    created_at: Date | null
    updated_at: Date | null
    created_by: string | null
    updated_by: string | null
  }

  export type CustomerEducationCountAggregateOutputType = {
    education_id: number
    customer_id: number
    country: number
    degree: number
    entrollment_date: number
    graduate_date: number
    is_current: number
    school_id: number
    school: number
    faculty: number
    department: number
    created_at: number
    updated_at: number
    created_by: number
    updated_by: number
    _all: number
  }


  export type CustomerEducationAvgAggregateInputType = {
    school_id?: true
  }

  export type CustomerEducationSumAggregateInputType = {
    school_id?: true
  }

  export type CustomerEducationMinAggregateInputType = {
    education_id?: true
    customer_id?: true
    country?: true
    entrollment_date?: true
    graduate_date?: true
    is_current?: true
    school_id?: true
    faculty?: true
    department?: true
    created_at?: true
    updated_at?: true
    created_by?: true
    updated_by?: true
  }

  export type CustomerEducationMaxAggregateInputType = {
    education_id?: true
    customer_id?: true
    country?: true
    entrollment_date?: true
    graduate_date?: true
    is_current?: true
    school_id?: true
    faculty?: true
    department?: true
    created_at?: true
    updated_at?: true
    created_by?: true
    updated_by?: true
  }

  export type CustomerEducationCountAggregateInputType = {
    education_id?: true
    customer_id?: true
    country?: true
    degree?: true
    entrollment_date?: true
    graduate_date?: true
    is_current?: true
    school_id?: true
    school?: true
    faculty?: true
    department?: true
    created_at?: true
    updated_at?: true
    created_by?: true
    updated_by?: true
    _all?: true
  }

  export type CustomerEducationAggregateArgs = {
    /**
     * Filter which CustomerEducation to aggregate.
     * 
    **/
    where?: CustomerEducationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerEducations to fetch.
     * 
    **/
    orderBy?: Enumerable<CustomerEducationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: CustomerEducationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerEducations from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerEducations.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CustomerEducations
    **/
    _count?: true | CustomerEducationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CustomerEducationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CustomerEducationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomerEducationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomerEducationMaxAggregateInputType
  }

  export type GetCustomerEducationAggregateType<T extends CustomerEducationAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomerEducation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomerEducation[P]>
      : GetScalarType<T[P], AggregateCustomerEducation[P]>
  }




  export type CustomerEducationGroupByArgs = {
    where?: CustomerEducationWhereInput
    orderBy?: Enumerable<CustomerEducationOrderByWithAggregationInput>
    by: Array<CustomerEducationScalarFieldEnum>
    having?: CustomerEducationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomerEducationCountAggregateInputType | true
    _avg?: CustomerEducationAvgAggregateInputType
    _sum?: CustomerEducationSumAggregateInputType
    _min?: CustomerEducationMinAggregateInputType
    _max?: CustomerEducationMaxAggregateInputType
  }


  export type CustomerEducationGroupByOutputType = {
    education_id: string
    customer_id: string | null
    country: string | null
    degree: JsonValue | null
    entrollment_date: Date | null
    graduate_date: Date | null
    is_current: boolean | null
    school_id: number | null
    school: JsonValue | null
    faculty: string | null
    department: string | null
    created_at: Date
    updated_at: Date
    created_by: string | null
    updated_by: string | null
    _count: CustomerEducationCountAggregateOutputType | null
    _avg: CustomerEducationAvgAggregateOutputType | null
    _sum: CustomerEducationSumAggregateOutputType | null
    _min: CustomerEducationMinAggregateOutputType | null
    _max: CustomerEducationMaxAggregateOutputType | null
  }

  type GetCustomerEducationGroupByPayload<T extends CustomerEducationGroupByArgs> = PrismaPromise<
    Array<
      PickArray<CustomerEducationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomerEducationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomerEducationGroupByOutputType[P]>
            : GetScalarType<T[P], CustomerEducationGroupByOutputType[P]>
        }
      >
    >


  export type CustomerEducationSelect = {
    education_id?: boolean
    customer?: boolean | CustomerArgs
    customer_id?: boolean
    country?: boolean
    degree?: boolean
    entrollment_date?: boolean
    graduate_date?: boolean
    is_current?: boolean
    school_id?: boolean
    school?: boolean
    faculty?: boolean
    department?: boolean
    created_at?: boolean
    updated_at?: boolean
    created_by?: boolean
    updated_by?: boolean
  }


  export type CustomerEducationInclude = {
    customer?: boolean | CustomerArgs
  } 

  export type CustomerEducationGetPayload<S extends boolean | null | undefined | CustomerEducationArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? CustomerEducation :
    S extends undefined ? never :
    S extends { include: any } & (CustomerEducationArgs | CustomerEducationFindManyArgs)
    ? CustomerEducation  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'customer' ? CustomerGetPayload<S['include'][P]> | null :  never
  } 
    : S extends { select: any } & (CustomerEducationArgs | CustomerEducationFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'customer' ? CustomerGetPayload<S['select'][P]> | null :  P extends keyof CustomerEducation ? CustomerEducation[P] : never
  } 
      : CustomerEducation


  type CustomerEducationCountArgs = Merge<
    Omit<CustomerEducationFindManyArgs, 'select' | 'include'> & {
      select?: CustomerEducationCountAggregateInputType | true
    }
  >

  export interface CustomerEducationDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one CustomerEducation that matches the filter.
     * @param {CustomerEducationFindUniqueArgs} args - Arguments to find a CustomerEducation
     * @example
     * // Get one CustomerEducation
     * const customerEducation = await prisma.customerEducation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CustomerEducationFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CustomerEducationFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'CustomerEducation'> extends True ? Prisma__CustomerEducationClient<CustomerEducationGetPayload<T>> : Prisma__CustomerEducationClient<CustomerEducationGetPayload<T> | null, null>

    /**
     * Find one CustomerEducation that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CustomerEducationFindUniqueOrThrowArgs} args - Arguments to find a CustomerEducation
     * @example
     * // Get one CustomerEducation
     * const customerEducation = await prisma.customerEducation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CustomerEducationFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, CustomerEducationFindUniqueOrThrowArgs>
    ): Prisma__CustomerEducationClient<CustomerEducationGetPayload<T>>

    /**
     * Find the first CustomerEducation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerEducationFindFirstArgs} args - Arguments to find a CustomerEducation
     * @example
     * // Get one CustomerEducation
     * const customerEducation = await prisma.customerEducation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CustomerEducationFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CustomerEducationFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'CustomerEducation'> extends True ? Prisma__CustomerEducationClient<CustomerEducationGetPayload<T>> : Prisma__CustomerEducationClient<CustomerEducationGetPayload<T> | null, null>

    /**
     * Find the first CustomerEducation that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerEducationFindFirstOrThrowArgs} args - Arguments to find a CustomerEducation
     * @example
     * // Get one CustomerEducation
     * const customerEducation = await prisma.customerEducation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CustomerEducationFindFirstOrThrowArgs>(
      args?: SelectSubset<T, CustomerEducationFindFirstOrThrowArgs>
    ): Prisma__CustomerEducationClient<CustomerEducationGetPayload<T>>

    /**
     * Find zero or more CustomerEducations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerEducationFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CustomerEducations
     * const customerEducations = await prisma.customerEducation.findMany()
     * 
     * // Get first 10 CustomerEducations
     * const customerEducations = await prisma.customerEducation.findMany({ take: 10 })
     * 
     * // Only select the `education_id`
     * const customerEducationWithEducation_idOnly = await prisma.customerEducation.findMany({ select: { education_id: true } })
     * 
    **/
    findMany<T extends CustomerEducationFindManyArgs>(
      args?: SelectSubset<T, CustomerEducationFindManyArgs>
    ): PrismaPromise<Array<CustomerEducationGetPayload<T>>>

    /**
     * Create a CustomerEducation.
     * @param {CustomerEducationCreateArgs} args - Arguments to create a CustomerEducation.
     * @example
     * // Create one CustomerEducation
     * const CustomerEducation = await prisma.customerEducation.create({
     *   data: {
     *     // ... data to create a CustomerEducation
     *   }
     * })
     * 
    **/
    create<T extends CustomerEducationCreateArgs>(
      args: SelectSubset<T, CustomerEducationCreateArgs>
    ): Prisma__CustomerEducationClient<CustomerEducationGetPayload<T>>

    /**
     * Create many CustomerEducations.
     *     @param {CustomerEducationCreateManyArgs} args - Arguments to create many CustomerEducations.
     *     @example
     *     // Create many CustomerEducations
     *     const customerEducation = await prisma.customerEducation.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CustomerEducationCreateManyArgs>(
      args?: SelectSubset<T, CustomerEducationCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a CustomerEducation.
     * @param {CustomerEducationDeleteArgs} args - Arguments to delete one CustomerEducation.
     * @example
     * // Delete one CustomerEducation
     * const CustomerEducation = await prisma.customerEducation.delete({
     *   where: {
     *     // ... filter to delete one CustomerEducation
     *   }
     * })
     * 
    **/
    delete<T extends CustomerEducationDeleteArgs>(
      args: SelectSubset<T, CustomerEducationDeleteArgs>
    ): Prisma__CustomerEducationClient<CustomerEducationGetPayload<T>>

    /**
     * Update one CustomerEducation.
     * @param {CustomerEducationUpdateArgs} args - Arguments to update one CustomerEducation.
     * @example
     * // Update one CustomerEducation
     * const customerEducation = await prisma.customerEducation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CustomerEducationUpdateArgs>(
      args: SelectSubset<T, CustomerEducationUpdateArgs>
    ): Prisma__CustomerEducationClient<CustomerEducationGetPayload<T>>

    /**
     * Delete zero or more CustomerEducations.
     * @param {CustomerEducationDeleteManyArgs} args - Arguments to filter CustomerEducations to delete.
     * @example
     * // Delete a few CustomerEducations
     * const { count } = await prisma.customerEducation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CustomerEducationDeleteManyArgs>(
      args?: SelectSubset<T, CustomerEducationDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more CustomerEducations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerEducationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CustomerEducations
     * const customerEducation = await prisma.customerEducation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CustomerEducationUpdateManyArgs>(
      args: SelectSubset<T, CustomerEducationUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one CustomerEducation.
     * @param {CustomerEducationUpsertArgs} args - Arguments to update or create a CustomerEducation.
     * @example
     * // Update or create a CustomerEducation
     * const customerEducation = await prisma.customerEducation.upsert({
     *   create: {
     *     // ... data to create a CustomerEducation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CustomerEducation we want to update
     *   }
     * })
    **/
    upsert<T extends CustomerEducationUpsertArgs>(
      args: SelectSubset<T, CustomerEducationUpsertArgs>
    ): Prisma__CustomerEducationClient<CustomerEducationGetPayload<T>>

    /**
     * Count the number of CustomerEducations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerEducationCountArgs} args - Arguments to filter CustomerEducations to count.
     * @example
     * // Count the number of CustomerEducations
     * const count = await prisma.customerEducation.count({
     *   where: {
     *     // ... the filter for the CustomerEducations we want to count
     *   }
     * })
    **/
    count<T extends CustomerEducationCountArgs>(
      args?: Subset<T, CustomerEducationCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomerEducationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CustomerEducation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerEducationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomerEducationAggregateArgs>(args: Subset<T, CustomerEducationAggregateArgs>): PrismaPromise<GetCustomerEducationAggregateType<T>>

    /**
     * Group by CustomerEducation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerEducationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CustomerEducationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CustomerEducationGroupByArgs['orderBy'] }
        : { orderBy?: CustomerEducationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CustomerEducationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomerEducationGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for CustomerEducation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CustomerEducationClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    customer<T extends CustomerArgs= {}>(args?: Subset<T, CustomerArgs>): Prisma__CustomerClient<CustomerGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * CustomerEducation base type for findUnique actions
   */
  export type CustomerEducationFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the CustomerEducation
     * 
    **/
    select?: CustomerEducationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CustomerEducationInclude | null
    /**
     * Filter, which CustomerEducation to fetch.
     * 
    **/
    where: CustomerEducationWhereUniqueInput
  }

  /**
   * CustomerEducation: findUnique
   */
  export interface CustomerEducationFindUniqueArgs extends CustomerEducationFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * CustomerEducation findUniqueOrThrow
   */
  export type CustomerEducationFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the CustomerEducation
     * 
    **/
    select?: CustomerEducationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CustomerEducationInclude | null
    /**
     * Filter, which CustomerEducation to fetch.
     * 
    **/
    where: CustomerEducationWhereUniqueInput
  }


  /**
   * CustomerEducation base type for findFirst actions
   */
  export type CustomerEducationFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the CustomerEducation
     * 
    **/
    select?: CustomerEducationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CustomerEducationInclude | null
    /**
     * Filter, which CustomerEducation to fetch.
     * 
    **/
    where?: CustomerEducationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerEducations to fetch.
     * 
    **/
    orderBy?: Enumerable<CustomerEducationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CustomerEducations.
     * 
    **/
    cursor?: CustomerEducationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerEducations from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerEducations.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CustomerEducations.
     * 
    **/
    distinct?: Enumerable<CustomerEducationScalarFieldEnum>
  }

  /**
   * CustomerEducation: findFirst
   */
  export interface CustomerEducationFindFirstArgs extends CustomerEducationFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * CustomerEducation findFirstOrThrow
   */
  export type CustomerEducationFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the CustomerEducation
     * 
    **/
    select?: CustomerEducationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CustomerEducationInclude | null
    /**
     * Filter, which CustomerEducation to fetch.
     * 
    **/
    where?: CustomerEducationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerEducations to fetch.
     * 
    **/
    orderBy?: Enumerable<CustomerEducationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CustomerEducations.
     * 
    **/
    cursor?: CustomerEducationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerEducations from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerEducations.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CustomerEducations.
     * 
    **/
    distinct?: Enumerable<CustomerEducationScalarFieldEnum>
  }


  /**
   * CustomerEducation findMany
   */
  export type CustomerEducationFindManyArgs = {
    /**
     * Select specific fields to fetch from the CustomerEducation
     * 
    **/
    select?: CustomerEducationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CustomerEducationInclude | null
    /**
     * Filter, which CustomerEducations to fetch.
     * 
    **/
    where?: CustomerEducationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerEducations to fetch.
     * 
    **/
    orderBy?: Enumerable<CustomerEducationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CustomerEducations.
     * 
    **/
    cursor?: CustomerEducationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerEducations from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerEducations.
     * 
    **/
    skip?: number
    distinct?: Enumerable<CustomerEducationScalarFieldEnum>
  }


  /**
   * CustomerEducation create
   */
  export type CustomerEducationCreateArgs = {
    /**
     * Select specific fields to fetch from the CustomerEducation
     * 
    **/
    select?: CustomerEducationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CustomerEducationInclude | null
    /**
     * The data needed to create a CustomerEducation.
     * 
    **/
    data: XOR<CustomerEducationCreateInput, CustomerEducationUncheckedCreateInput>
  }


  /**
   * CustomerEducation createMany
   */
  export type CustomerEducationCreateManyArgs = {
    /**
     * The data used to create many CustomerEducations.
     * 
    **/
    data: Enumerable<CustomerEducationCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * CustomerEducation update
   */
  export type CustomerEducationUpdateArgs = {
    /**
     * Select specific fields to fetch from the CustomerEducation
     * 
    **/
    select?: CustomerEducationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CustomerEducationInclude | null
    /**
     * The data needed to update a CustomerEducation.
     * 
    **/
    data: XOR<CustomerEducationUpdateInput, CustomerEducationUncheckedUpdateInput>
    /**
     * Choose, which CustomerEducation to update.
     * 
    **/
    where: CustomerEducationWhereUniqueInput
  }


  /**
   * CustomerEducation updateMany
   */
  export type CustomerEducationUpdateManyArgs = {
    /**
     * The data used to update CustomerEducations.
     * 
    **/
    data: XOR<CustomerEducationUpdateManyMutationInput, CustomerEducationUncheckedUpdateManyInput>
    /**
     * Filter which CustomerEducations to update
     * 
    **/
    where?: CustomerEducationWhereInput
  }


  /**
   * CustomerEducation upsert
   */
  export type CustomerEducationUpsertArgs = {
    /**
     * Select specific fields to fetch from the CustomerEducation
     * 
    **/
    select?: CustomerEducationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CustomerEducationInclude | null
    /**
     * The filter to search for the CustomerEducation to update in case it exists.
     * 
    **/
    where: CustomerEducationWhereUniqueInput
    /**
     * In case the CustomerEducation found by the `where` argument doesn't exist, create a new CustomerEducation with this data.
     * 
    **/
    create: XOR<CustomerEducationCreateInput, CustomerEducationUncheckedCreateInput>
    /**
     * In case the CustomerEducation was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<CustomerEducationUpdateInput, CustomerEducationUncheckedUpdateInput>
  }


  /**
   * CustomerEducation delete
   */
  export type CustomerEducationDeleteArgs = {
    /**
     * Select specific fields to fetch from the CustomerEducation
     * 
    **/
    select?: CustomerEducationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CustomerEducationInclude | null
    /**
     * Filter which CustomerEducation to delete.
     * 
    **/
    where: CustomerEducationWhereUniqueInput
  }


  /**
   * CustomerEducation deleteMany
   */
  export type CustomerEducationDeleteManyArgs = {
    /**
     * Filter which CustomerEducations to delete
     * 
    **/
    where?: CustomerEducationWhereInput
  }


  /**
   * CustomerEducation without action
   */
  export type CustomerEducationArgs = {
    /**
     * Select specific fields to fetch from the CustomerEducation
     * 
    **/
    select?: CustomerEducationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CustomerEducationInclude | null
  }



  /**
   * Model CustomerExperience
   */


  export type AggregateCustomerExperience = {
    _count: CustomerExperienceCountAggregateOutputType | null
    _avg: CustomerExperienceAvgAggregateOutputType | null
    _sum: CustomerExperienceSumAggregateOutputType | null
    _min: CustomerExperienceMinAggregateOutputType | null
    _max: CustomerExperienceMaxAggregateOutputType | null
  }

  export type CustomerExperienceAvgAggregateOutputType = {
    skill_id: number | null
    over_year: number | null
  }

  export type CustomerExperienceSumAggregateOutputType = {
    skill_id: number | null
    over_year: number | null
  }

  export type CustomerExperienceMinAggregateOutputType = {
    experience_id: string | null
    jobdetail_id: string | null
    skill_id: number | null
    over_year: number | null
    created_at: Date | null
    updated_at: Date | null
    created_by: string | null
    updated_by: string | null
  }

  export type CustomerExperienceMaxAggregateOutputType = {
    experience_id: string | null
    jobdetail_id: string | null
    skill_id: number | null
    over_year: number | null
    created_at: Date | null
    updated_at: Date | null
    created_by: string | null
    updated_by: string | null
  }

  export type CustomerExperienceCountAggregateOutputType = {
    experience_id: number
    jobdetail_id: number
    skill_id: number
    over_year: number
    created_at: number
    updated_at: number
    created_by: number
    updated_by: number
    _all: number
  }


  export type CustomerExperienceAvgAggregateInputType = {
    skill_id?: true
    over_year?: true
  }

  export type CustomerExperienceSumAggregateInputType = {
    skill_id?: true
    over_year?: true
  }

  export type CustomerExperienceMinAggregateInputType = {
    experience_id?: true
    jobdetail_id?: true
    skill_id?: true
    over_year?: true
    created_at?: true
    updated_at?: true
    created_by?: true
    updated_by?: true
  }

  export type CustomerExperienceMaxAggregateInputType = {
    experience_id?: true
    jobdetail_id?: true
    skill_id?: true
    over_year?: true
    created_at?: true
    updated_at?: true
    created_by?: true
    updated_by?: true
  }

  export type CustomerExperienceCountAggregateInputType = {
    experience_id?: true
    jobdetail_id?: true
    skill_id?: true
    over_year?: true
    created_at?: true
    updated_at?: true
    created_by?: true
    updated_by?: true
    _all?: true
  }

  export type CustomerExperienceAggregateArgs = {
    /**
     * Filter which CustomerExperience to aggregate.
     * 
    **/
    where?: CustomerExperienceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerExperiences to fetch.
     * 
    **/
    orderBy?: Enumerable<CustomerExperienceOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: CustomerExperienceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerExperiences from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerExperiences.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CustomerExperiences
    **/
    _count?: true | CustomerExperienceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CustomerExperienceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CustomerExperienceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomerExperienceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomerExperienceMaxAggregateInputType
  }

  export type GetCustomerExperienceAggregateType<T extends CustomerExperienceAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomerExperience]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomerExperience[P]>
      : GetScalarType<T[P], AggregateCustomerExperience[P]>
  }




  export type CustomerExperienceGroupByArgs = {
    where?: CustomerExperienceWhereInput
    orderBy?: Enumerable<CustomerExperienceOrderByWithAggregationInput>
    by: Array<CustomerExperienceScalarFieldEnum>
    having?: CustomerExperienceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomerExperienceCountAggregateInputType | true
    _avg?: CustomerExperienceAvgAggregateInputType
    _sum?: CustomerExperienceSumAggregateInputType
    _min?: CustomerExperienceMinAggregateInputType
    _max?: CustomerExperienceMaxAggregateInputType
  }


  export type CustomerExperienceGroupByOutputType = {
    experience_id: string
    jobdetail_id: string
    skill_id: number
    over_year: number | null
    created_at: Date
    updated_at: Date | null
    created_by: string | null
    updated_by: string | null
    _count: CustomerExperienceCountAggregateOutputType | null
    _avg: CustomerExperienceAvgAggregateOutputType | null
    _sum: CustomerExperienceSumAggregateOutputType | null
    _min: CustomerExperienceMinAggregateOutputType | null
    _max: CustomerExperienceMaxAggregateOutputType | null
  }

  type GetCustomerExperienceGroupByPayload<T extends CustomerExperienceGroupByArgs> = PrismaPromise<
    Array<
      PickArray<CustomerExperienceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomerExperienceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomerExperienceGroupByOutputType[P]>
            : GetScalarType<T[P], CustomerExperienceGroupByOutputType[P]>
        }
      >
    >


  export type CustomerExperienceSelect = {
    experience_id?: boolean
    jobdetail_id?: boolean
    jobdetails?: boolean | CustomerJobDetailArgs
    skill_id?: boolean
    listitems?: boolean | ReferenceListItemsArgs
    over_year?: boolean
    created_at?: boolean
    updated_at?: boolean
    created_by?: boolean
    updated_by?: boolean
  }


  export type CustomerExperienceInclude = {
    jobdetails?: boolean | CustomerJobDetailArgs
    listitems?: boolean | ReferenceListItemsArgs
  } 

  export type CustomerExperienceGetPayload<S extends boolean | null | undefined | CustomerExperienceArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? CustomerExperience :
    S extends undefined ? never :
    S extends { include: any } & (CustomerExperienceArgs | CustomerExperienceFindManyArgs)
    ? CustomerExperience  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'jobdetails' ? CustomerJobDetailGetPayload<S['include'][P]> :
        P extends 'listitems' ? ReferenceListItemsGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (CustomerExperienceArgs | CustomerExperienceFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'jobdetails' ? CustomerJobDetailGetPayload<S['select'][P]> :
        P extends 'listitems' ? ReferenceListItemsGetPayload<S['select'][P]> :  P extends keyof CustomerExperience ? CustomerExperience[P] : never
  } 
      : CustomerExperience


  type CustomerExperienceCountArgs = Merge<
    Omit<CustomerExperienceFindManyArgs, 'select' | 'include'> & {
      select?: CustomerExperienceCountAggregateInputType | true
    }
  >

  export interface CustomerExperienceDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one CustomerExperience that matches the filter.
     * @param {CustomerExperienceFindUniqueArgs} args - Arguments to find a CustomerExperience
     * @example
     * // Get one CustomerExperience
     * const customerExperience = await prisma.customerExperience.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CustomerExperienceFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CustomerExperienceFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'CustomerExperience'> extends True ? Prisma__CustomerExperienceClient<CustomerExperienceGetPayload<T>> : Prisma__CustomerExperienceClient<CustomerExperienceGetPayload<T> | null, null>

    /**
     * Find one CustomerExperience that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CustomerExperienceFindUniqueOrThrowArgs} args - Arguments to find a CustomerExperience
     * @example
     * // Get one CustomerExperience
     * const customerExperience = await prisma.customerExperience.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CustomerExperienceFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, CustomerExperienceFindUniqueOrThrowArgs>
    ): Prisma__CustomerExperienceClient<CustomerExperienceGetPayload<T>>

    /**
     * Find the first CustomerExperience that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerExperienceFindFirstArgs} args - Arguments to find a CustomerExperience
     * @example
     * // Get one CustomerExperience
     * const customerExperience = await prisma.customerExperience.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CustomerExperienceFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CustomerExperienceFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'CustomerExperience'> extends True ? Prisma__CustomerExperienceClient<CustomerExperienceGetPayload<T>> : Prisma__CustomerExperienceClient<CustomerExperienceGetPayload<T> | null, null>

    /**
     * Find the first CustomerExperience that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerExperienceFindFirstOrThrowArgs} args - Arguments to find a CustomerExperience
     * @example
     * // Get one CustomerExperience
     * const customerExperience = await prisma.customerExperience.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CustomerExperienceFindFirstOrThrowArgs>(
      args?: SelectSubset<T, CustomerExperienceFindFirstOrThrowArgs>
    ): Prisma__CustomerExperienceClient<CustomerExperienceGetPayload<T>>

    /**
     * Find zero or more CustomerExperiences that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerExperienceFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CustomerExperiences
     * const customerExperiences = await prisma.customerExperience.findMany()
     * 
     * // Get first 10 CustomerExperiences
     * const customerExperiences = await prisma.customerExperience.findMany({ take: 10 })
     * 
     * // Only select the `experience_id`
     * const customerExperienceWithExperience_idOnly = await prisma.customerExperience.findMany({ select: { experience_id: true } })
     * 
    **/
    findMany<T extends CustomerExperienceFindManyArgs>(
      args?: SelectSubset<T, CustomerExperienceFindManyArgs>
    ): PrismaPromise<Array<CustomerExperienceGetPayload<T>>>

    /**
     * Create a CustomerExperience.
     * @param {CustomerExperienceCreateArgs} args - Arguments to create a CustomerExperience.
     * @example
     * // Create one CustomerExperience
     * const CustomerExperience = await prisma.customerExperience.create({
     *   data: {
     *     // ... data to create a CustomerExperience
     *   }
     * })
     * 
    **/
    create<T extends CustomerExperienceCreateArgs>(
      args: SelectSubset<T, CustomerExperienceCreateArgs>
    ): Prisma__CustomerExperienceClient<CustomerExperienceGetPayload<T>>

    /**
     * Create many CustomerExperiences.
     *     @param {CustomerExperienceCreateManyArgs} args - Arguments to create many CustomerExperiences.
     *     @example
     *     // Create many CustomerExperiences
     *     const customerExperience = await prisma.customerExperience.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CustomerExperienceCreateManyArgs>(
      args?: SelectSubset<T, CustomerExperienceCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a CustomerExperience.
     * @param {CustomerExperienceDeleteArgs} args - Arguments to delete one CustomerExperience.
     * @example
     * // Delete one CustomerExperience
     * const CustomerExperience = await prisma.customerExperience.delete({
     *   where: {
     *     // ... filter to delete one CustomerExperience
     *   }
     * })
     * 
    **/
    delete<T extends CustomerExperienceDeleteArgs>(
      args: SelectSubset<T, CustomerExperienceDeleteArgs>
    ): Prisma__CustomerExperienceClient<CustomerExperienceGetPayload<T>>

    /**
     * Update one CustomerExperience.
     * @param {CustomerExperienceUpdateArgs} args - Arguments to update one CustomerExperience.
     * @example
     * // Update one CustomerExperience
     * const customerExperience = await prisma.customerExperience.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CustomerExperienceUpdateArgs>(
      args: SelectSubset<T, CustomerExperienceUpdateArgs>
    ): Prisma__CustomerExperienceClient<CustomerExperienceGetPayload<T>>

    /**
     * Delete zero or more CustomerExperiences.
     * @param {CustomerExperienceDeleteManyArgs} args - Arguments to filter CustomerExperiences to delete.
     * @example
     * // Delete a few CustomerExperiences
     * const { count } = await prisma.customerExperience.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CustomerExperienceDeleteManyArgs>(
      args?: SelectSubset<T, CustomerExperienceDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more CustomerExperiences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerExperienceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CustomerExperiences
     * const customerExperience = await prisma.customerExperience.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CustomerExperienceUpdateManyArgs>(
      args: SelectSubset<T, CustomerExperienceUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one CustomerExperience.
     * @param {CustomerExperienceUpsertArgs} args - Arguments to update or create a CustomerExperience.
     * @example
     * // Update or create a CustomerExperience
     * const customerExperience = await prisma.customerExperience.upsert({
     *   create: {
     *     // ... data to create a CustomerExperience
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CustomerExperience we want to update
     *   }
     * })
    **/
    upsert<T extends CustomerExperienceUpsertArgs>(
      args: SelectSubset<T, CustomerExperienceUpsertArgs>
    ): Prisma__CustomerExperienceClient<CustomerExperienceGetPayload<T>>

    /**
     * Count the number of CustomerExperiences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerExperienceCountArgs} args - Arguments to filter CustomerExperiences to count.
     * @example
     * // Count the number of CustomerExperiences
     * const count = await prisma.customerExperience.count({
     *   where: {
     *     // ... the filter for the CustomerExperiences we want to count
     *   }
     * })
    **/
    count<T extends CustomerExperienceCountArgs>(
      args?: Subset<T, CustomerExperienceCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomerExperienceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CustomerExperience.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerExperienceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomerExperienceAggregateArgs>(args: Subset<T, CustomerExperienceAggregateArgs>): PrismaPromise<GetCustomerExperienceAggregateType<T>>

    /**
     * Group by CustomerExperience.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerExperienceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CustomerExperienceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CustomerExperienceGroupByArgs['orderBy'] }
        : { orderBy?: CustomerExperienceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CustomerExperienceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomerExperienceGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for CustomerExperience.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CustomerExperienceClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    jobdetails<T extends CustomerJobDetailArgs= {}>(args?: Subset<T, CustomerJobDetailArgs>): Prisma__CustomerJobDetailClient<CustomerJobDetailGetPayload<T> | Null>;

    listitems<T extends ReferenceListItemsArgs= {}>(args?: Subset<T, ReferenceListItemsArgs>): Prisma__ReferenceListItemsClient<ReferenceListItemsGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * CustomerExperience base type for findUnique actions
   */
  export type CustomerExperienceFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the CustomerExperience
     * 
    **/
    select?: CustomerExperienceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CustomerExperienceInclude | null
    /**
     * Filter, which CustomerExperience to fetch.
     * 
    **/
    where: CustomerExperienceWhereUniqueInput
  }

  /**
   * CustomerExperience: findUnique
   */
  export interface CustomerExperienceFindUniqueArgs extends CustomerExperienceFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * CustomerExperience findUniqueOrThrow
   */
  export type CustomerExperienceFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the CustomerExperience
     * 
    **/
    select?: CustomerExperienceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CustomerExperienceInclude | null
    /**
     * Filter, which CustomerExperience to fetch.
     * 
    **/
    where: CustomerExperienceWhereUniqueInput
  }


  /**
   * CustomerExperience base type for findFirst actions
   */
  export type CustomerExperienceFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the CustomerExperience
     * 
    **/
    select?: CustomerExperienceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CustomerExperienceInclude | null
    /**
     * Filter, which CustomerExperience to fetch.
     * 
    **/
    where?: CustomerExperienceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerExperiences to fetch.
     * 
    **/
    orderBy?: Enumerable<CustomerExperienceOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CustomerExperiences.
     * 
    **/
    cursor?: CustomerExperienceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerExperiences from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerExperiences.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CustomerExperiences.
     * 
    **/
    distinct?: Enumerable<CustomerExperienceScalarFieldEnum>
  }

  /**
   * CustomerExperience: findFirst
   */
  export interface CustomerExperienceFindFirstArgs extends CustomerExperienceFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * CustomerExperience findFirstOrThrow
   */
  export type CustomerExperienceFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the CustomerExperience
     * 
    **/
    select?: CustomerExperienceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CustomerExperienceInclude | null
    /**
     * Filter, which CustomerExperience to fetch.
     * 
    **/
    where?: CustomerExperienceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerExperiences to fetch.
     * 
    **/
    orderBy?: Enumerable<CustomerExperienceOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CustomerExperiences.
     * 
    **/
    cursor?: CustomerExperienceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerExperiences from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerExperiences.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CustomerExperiences.
     * 
    **/
    distinct?: Enumerable<CustomerExperienceScalarFieldEnum>
  }


  /**
   * CustomerExperience findMany
   */
  export type CustomerExperienceFindManyArgs = {
    /**
     * Select specific fields to fetch from the CustomerExperience
     * 
    **/
    select?: CustomerExperienceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CustomerExperienceInclude | null
    /**
     * Filter, which CustomerExperiences to fetch.
     * 
    **/
    where?: CustomerExperienceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerExperiences to fetch.
     * 
    **/
    orderBy?: Enumerable<CustomerExperienceOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CustomerExperiences.
     * 
    **/
    cursor?: CustomerExperienceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerExperiences from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerExperiences.
     * 
    **/
    skip?: number
    distinct?: Enumerable<CustomerExperienceScalarFieldEnum>
  }


  /**
   * CustomerExperience create
   */
  export type CustomerExperienceCreateArgs = {
    /**
     * Select specific fields to fetch from the CustomerExperience
     * 
    **/
    select?: CustomerExperienceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CustomerExperienceInclude | null
    /**
     * The data needed to create a CustomerExperience.
     * 
    **/
    data: XOR<CustomerExperienceCreateInput, CustomerExperienceUncheckedCreateInput>
  }


  /**
   * CustomerExperience createMany
   */
  export type CustomerExperienceCreateManyArgs = {
    /**
     * The data used to create many CustomerExperiences.
     * 
    **/
    data: Enumerable<CustomerExperienceCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * CustomerExperience update
   */
  export type CustomerExperienceUpdateArgs = {
    /**
     * Select specific fields to fetch from the CustomerExperience
     * 
    **/
    select?: CustomerExperienceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CustomerExperienceInclude | null
    /**
     * The data needed to update a CustomerExperience.
     * 
    **/
    data: XOR<CustomerExperienceUpdateInput, CustomerExperienceUncheckedUpdateInput>
    /**
     * Choose, which CustomerExperience to update.
     * 
    **/
    where: CustomerExperienceWhereUniqueInput
  }


  /**
   * CustomerExperience updateMany
   */
  export type CustomerExperienceUpdateManyArgs = {
    /**
     * The data used to update CustomerExperiences.
     * 
    **/
    data: XOR<CustomerExperienceUpdateManyMutationInput, CustomerExperienceUncheckedUpdateManyInput>
    /**
     * Filter which CustomerExperiences to update
     * 
    **/
    where?: CustomerExperienceWhereInput
  }


  /**
   * CustomerExperience upsert
   */
  export type CustomerExperienceUpsertArgs = {
    /**
     * Select specific fields to fetch from the CustomerExperience
     * 
    **/
    select?: CustomerExperienceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CustomerExperienceInclude | null
    /**
     * The filter to search for the CustomerExperience to update in case it exists.
     * 
    **/
    where: CustomerExperienceWhereUniqueInput
    /**
     * In case the CustomerExperience found by the `where` argument doesn't exist, create a new CustomerExperience with this data.
     * 
    **/
    create: XOR<CustomerExperienceCreateInput, CustomerExperienceUncheckedCreateInput>
    /**
     * In case the CustomerExperience was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<CustomerExperienceUpdateInput, CustomerExperienceUncheckedUpdateInput>
  }


  /**
   * CustomerExperience delete
   */
  export type CustomerExperienceDeleteArgs = {
    /**
     * Select specific fields to fetch from the CustomerExperience
     * 
    **/
    select?: CustomerExperienceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CustomerExperienceInclude | null
    /**
     * Filter which CustomerExperience to delete.
     * 
    **/
    where: CustomerExperienceWhereUniqueInput
  }


  /**
   * CustomerExperience deleteMany
   */
  export type CustomerExperienceDeleteManyArgs = {
    /**
     * Filter which CustomerExperiences to delete
     * 
    **/
    where?: CustomerExperienceWhereInput
  }


  /**
   * CustomerExperience without action
   */
  export type CustomerExperienceArgs = {
    /**
     * Select specific fields to fetch from the CustomerExperience
     * 
    **/
    select?: CustomerExperienceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CustomerExperienceInclude | null
  }



  /**
   * Model CustomerJobDetail
   */


  export type AggregateCustomerJobDetail = {
    _count: CustomerJobDetailCountAggregateOutputType | null
    _avg: CustomerJobDetailAvgAggregateOutputType | null
    _sum: CustomerJobDetailSumAggregateOutputType | null
    _min: CustomerJobDetailMinAggregateOutputType | null
    _max: CustomerJobDetailMaxAggregateOutputType | null
  }

  export type CustomerJobDetailAvgAggregateOutputType = {
    experienced_company: number | null
    annual_income: number | null
  }

  export type CustomerJobDetailSumAggregateOutputType = {
    experienced_company: number | null
    annual_income: number | null
  }

  export type CustomerJobDetailMinAggregateOutputType = {
    jobdetail_id: string | null
    customer_id: string | null
    experienced_company: number | null
    annual_income: number | null
    has_management_exp: boolean | null
    created_at: Date | null
    updated_at: Date | null
    created_by: string | null
    updated_by: string | null
  }

  export type CustomerJobDetailMaxAggregateOutputType = {
    jobdetail_id: string | null
    customer_id: string | null
    experienced_company: number | null
    annual_income: number | null
    has_management_exp: boolean | null
    created_at: Date | null
    updated_at: Date | null
    created_by: string | null
    updated_by: string | null
  }

  export type CustomerJobDetailCountAggregateOutputType = {
    jobdetail_id: number
    customer_id: number
    experienced_company: number
    annual_income: number
    has_management_exp: number
    created_at: number
    updated_at: number
    created_by: number
    updated_by: number
    _all: number
  }


  export type CustomerJobDetailAvgAggregateInputType = {
    experienced_company?: true
    annual_income?: true
  }

  export type CustomerJobDetailSumAggregateInputType = {
    experienced_company?: true
    annual_income?: true
  }

  export type CustomerJobDetailMinAggregateInputType = {
    jobdetail_id?: true
    customer_id?: true
    experienced_company?: true
    annual_income?: true
    has_management_exp?: true
    created_at?: true
    updated_at?: true
    created_by?: true
    updated_by?: true
  }

  export type CustomerJobDetailMaxAggregateInputType = {
    jobdetail_id?: true
    customer_id?: true
    experienced_company?: true
    annual_income?: true
    has_management_exp?: true
    created_at?: true
    updated_at?: true
    created_by?: true
    updated_by?: true
  }

  export type CustomerJobDetailCountAggregateInputType = {
    jobdetail_id?: true
    customer_id?: true
    experienced_company?: true
    annual_income?: true
    has_management_exp?: true
    created_at?: true
    updated_at?: true
    created_by?: true
    updated_by?: true
    _all?: true
  }

  export type CustomerJobDetailAggregateArgs = {
    /**
     * Filter which CustomerJobDetail to aggregate.
     * 
    **/
    where?: CustomerJobDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerJobDetails to fetch.
     * 
    **/
    orderBy?: Enumerable<CustomerJobDetailOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: CustomerJobDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerJobDetails from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerJobDetails.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CustomerJobDetails
    **/
    _count?: true | CustomerJobDetailCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CustomerJobDetailAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CustomerJobDetailSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomerJobDetailMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomerJobDetailMaxAggregateInputType
  }

  export type GetCustomerJobDetailAggregateType<T extends CustomerJobDetailAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomerJobDetail]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomerJobDetail[P]>
      : GetScalarType<T[P], AggregateCustomerJobDetail[P]>
  }




  export type CustomerJobDetailGroupByArgs = {
    where?: CustomerJobDetailWhereInput
    orderBy?: Enumerable<CustomerJobDetailOrderByWithAggregationInput>
    by: Array<CustomerJobDetailScalarFieldEnum>
    having?: CustomerJobDetailScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomerJobDetailCountAggregateInputType | true
    _avg?: CustomerJobDetailAvgAggregateInputType
    _sum?: CustomerJobDetailSumAggregateInputType
    _min?: CustomerJobDetailMinAggregateInputType
    _max?: CustomerJobDetailMaxAggregateInputType
  }


  export type CustomerJobDetailGroupByOutputType = {
    jobdetail_id: string
    customer_id: string | null
    experienced_company: number
    annual_income: number | null
    has_management_exp: boolean
    created_at: Date
    updated_at: Date
    created_by: string | null
    updated_by: string | null
    _count: CustomerJobDetailCountAggregateOutputType | null
    _avg: CustomerJobDetailAvgAggregateOutputType | null
    _sum: CustomerJobDetailSumAggregateOutputType | null
    _min: CustomerJobDetailMinAggregateOutputType | null
    _max: CustomerJobDetailMaxAggregateOutputType | null
  }

  type GetCustomerJobDetailGroupByPayload<T extends CustomerJobDetailGroupByArgs> = PrismaPromise<
    Array<
      PickArray<CustomerJobDetailGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomerJobDetailGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomerJobDetailGroupByOutputType[P]>
            : GetScalarType<T[P], CustomerJobDetailGroupByOutputType[P]>
        }
      >
    >


  export type CustomerJobDetailSelect = {
    jobdetail_id?: boolean
    customer_id?: boolean
    customer?: boolean | CustomerArgs
    customer_experiences?: boolean | CustomerExperienceFindManyArgs
    experienced_company?: boolean
    annual_income?: boolean
    has_management_exp?: boolean
    created_at?: boolean
    updated_at?: boolean
    created_by?: boolean
    updated_by?: boolean
    _count?: boolean | CustomerJobDetailCountOutputTypeArgs
  }


  export type CustomerJobDetailInclude = {
    customer?: boolean | CustomerArgs
    customer_experiences?: boolean | CustomerExperienceFindManyArgs
    _count?: boolean | CustomerJobDetailCountOutputTypeArgs
  } 

  export type CustomerJobDetailGetPayload<S extends boolean | null | undefined | CustomerJobDetailArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? CustomerJobDetail :
    S extends undefined ? never :
    S extends { include: any } & (CustomerJobDetailArgs | CustomerJobDetailFindManyArgs)
    ? CustomerJobDetail  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'customer' ? CustomerGetPayload<S['include'][P]> | null :
        P extends 'customer_experiences' ? Array < CustomerExperienceGetPayload<S['include'][P]>>  :
        P extends '_count' ? CustomerJobDetailCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (CustomerJobDetailArgs | CustomerJobDetailFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'customer' ? CustomerGetPayload<S['select'][P]> | null :
        P extends 'customer_experiences' ? Array < CustomerExperienceGetPayload<S['select'][P]>>  :
        P extends '_count' ? CustomerJobDetailCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof CustomerJobDetail ? CustomerJobDetail[P] : never
  } 
      : CustomerJobDetail


  type CustomerJobDetailCountArgs = Merge<
    Omit<CustomerJobDetailFindManyArgs, 'select' | 'include'> & {
      select?: CustomerJobDetailCountAggregateInputType | true
    }
  >

  export interface CustomerJobDetailDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one CustomerJobDetail that matches the filter.
     * @param {CustomerJobDetailFindUniqueArgs} args - Arguments to find a CustomerJobDetail
     * @example
     * // Get one CustomerJobDetail
     * const customerJobDetail = await prisma.customerJobDetail.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CustomerJobDetailFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CustomerJobDetailFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'CustomerJobDetail'> extends True ? Prisma__CustomerJobDetailClient<CustomerJobDetailGetPayload<T>> : Prisma__CustomerJobDetailClient<CustomerJobDetailGetPayload<T> | null, null>

    /**
     * Find one CustomerJobDetail that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CustomerJobDetailFindUniqueOrThrowArgs} args - Arguments to find a CustomerJobDetail
     * @example
     * // Get one CustomerJobDetail
     * const customerJobDetail = await prisma.customerJobDetail.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CustomerJobDetailFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, CustomerJobDetailFindUniqueOrThrowArgs>
    ): Prisma__CustomerJobDetailClient<CustomerJobDetailGetPayload<T>>

    /**
     * Find the first CustomerJobDetail that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerJobDetailFindFirstArgs} args - Arguments to find a CustomerJobDetail
     * @example
     * // Get one CustomerJobDetail
     * const customerJobDetail = await prisma.customerJobDetail.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CustomerJobDetailFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CustomerJobDetailFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'CustomerJobDetail'> extends True ? Prisma__CustomerJobDetailClient<CustomerJobDetailGetPayload<T>> : Prisma__CustomerJobDetailClient<CustomerJobDetailGetPayload<T> | null, null>

    /**
     * Find the first CustomerJobDetail that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerJobDetailFindFirstOrThrowArgs} args - Arguments to find a CustomerJobDetail
     * @example
     * // Get one CustomerJobDetail
     * const customerJobDetail = await prisma.customerJobDetail.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CustomerJobDetailFindFirstOrThrowArgs>(
      args?: SelectSubset<T, CustomerJobDetailFindFirstOrThrowArgs>
    ): Prisma__CustomerJobDetailClient<CustomerJobDetailGetPayload<T>>

    /**
     * Find zero or more CustomerJobDetails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerJobDetailFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CustomerJobDetails
     * const customerJobDetails = await prisma.customerJobDetail.findMany()
     * 
     * // Get first 10 CustomerJobDetails
     * const customerJobDetails = await prisma.customerJobDetail.findMany({ take: 10 })
     * 
     * // Only select the `jobdetail_id`
     * const customerJobDetailWithJobdetail_idOnly = await prisma.customerJobDetail.findMany({ select: { jobdetail_id: true } })
     * 
    **/
    findMany<T extends CustomerJobDetailFindManyArgs>(
      args?: SelectSubset<T, CustomerJobDetailFindManyArgs>
    ): PrismaPromise<Array<CustomerJobDetailGetPayload<T>>>

    /**
     * Create a CustomerJobDetail.
     * @param {CustomerJobDetailCreateArgs} args - Arguments to create a CustomerJobDetail.
     * @example
     * // Create one CustomerJobDetail
     * const CustomerJobDetail = await prisma.customerJobDetail.create({
     *   data: {
     *     // ... data to create a CustomerJobDetail
     *   }
     * })
     * 
    **/
    create<T extends CustomerJobDetailCreateArgs>(
      args: SelectSubset<T, CustomerJobDetailCreateArgs>
    ): Prisma__CustomerJobDetailClient<CustomerJobDetailGetPayload<T>>

    /**
     * Create many CustomerJobDetails.
     *     @param {CustomerJobDetailCreateManyArgs} args - Arguments to create many CustomerJobDetails.
     *     @example
     *     // Create many CustomerJobDetails
     *     const customerJobDetail = await prisma.customerJobDetail.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CustomerJobDetailCreateManyArgs>(
      args?: SelectSubset<T, CustomerJobDetailCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a CustomerJobDetail.
     * @param {CustomerJobDetailDeleteArgs} args - Arguments to delete one CustomerJobDetail.
     * @example
     * // Delete one CustomerJobDetail
     * const CustomerJobDetail = await prisma.customerJobDetail.delete({
     *   where: {
     *     // ... filter to delete one CustomerJobDetail
     *   }
     * })
     * 
    **/
    delete<T extends CustomerJobDetailDeleteArgs>(
      args: SelectSubset<T, CustomerJobDetailDeleteArgs>
    ): Prisma__CustomerJobDetailClient<CustomerJobDetailGetPayload<T>>

    /**
     * Update one CustomerJobDetail.
     * @param {CustomerJobDetailUpdateArgs} args - Arguments to update one CustomerJobDetail.
     * @example
     * // Update one CustomerJobDetail
     * const customerJobDetail = await prisma.customerJobDetail.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CustomerJobDetailUpdateArgs>(
      args: SelectSubset<T, CustomerJobDetailUpdateArgs>
    ): Prisma__CustomerJobDetailClient<CustomerJobDetailGetPayload<T>>

    /**
     * Delete zero or more CustomerJobDetails.
     * @param {CustomerJobDetailDeleteManyArgs} args - Arguments to filter CustomerJobDetails to delete.
     * @example
     * // Delete a few CustomerJobDetails
     * const { count } = await prisma.customerJobDetail.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CustomerJobDetailDeleteManyArgs>(
      args?: SelectSubset<T, CustomerJobDetailDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more CustomerJobDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerJobDetailUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CustomerJobDetails
     * const customerJobDetail = await prisma.customerJobDetail.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CustomerJobDetailUpdateManyArgs>(
      args: SelectSubset<T, CustomerJobDetailUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one CustomerJobDetail.
     * @param {CustomerJobDetailUpsertArgs} args - Arguments to update or create a CustomerJobDetail.
     * @example
     * // Update or create a CustomerJobDetail
     * const customerJobDetail = await prisma.customerJobDetail.upsert({
     *   create: {
     *     // ... data to create a CustomerJobDetail
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CustomerJobDetail we want to update
     *   }
     * })
    **/
    upsert<T extends CustomerJobDetailUpsertArgs>(
      args: SelectSubset<T, CustomerJobDetailUpsertArgs>
    ): Prisma__CustomerJobDetailClient<CustomerJobDetailGetPayload<T>>

    /**
     * Count the number of CustomerJobDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerJobDetailCountArgs} args - Arguments to filter CustomerJobDetails to count.
     * @example
     * // Count the number of CustomerJobDetails
     * const count = await prisma.customerJobDetail.count({
     *   where: {
     *     // ... the filter for the CustomerJobDetails we want to count
     *   }
     * })
    **/
    count<T extends CustomerJobDetailCountArgs>(
      args?: Subset<T, CustomerJobDetailCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomerJobDetailCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CustomerJobDetail.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerJobDetailAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomerJobDetailAggregateArgs>(args: Subset<T, CustomerJobDetailAggregateArgs>): PrismaPromise<GetCustomerJobDetailAggregateType<T>>

    /**
     * Group by CustomerJobDetail.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerJobDetailGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CustomerJobDetailGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CustomerJobDetailGroupByArgs['orderBy'] }
        : { orderBy?: CustomerJobDetailGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CustomerJobDetailGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomerJobDetailGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for CustomerJobDetail.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CustomerJobDetailClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    customer<T extends CustomerArgs= {}>(args?: Subset<T, CustomerArgs>): Prisma__CustomerClient<CustomerGetPayload<T> | Null>;

    customer_experiences<T extends CustomerExperienceFindManyArgs= {}>(args?: Subset<T, CustomerExperienceFindManyArgs>): PrismaPromise<Array<CustomerExperienceGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * CustomerJobDetail base type for findUnique actions
   */
  export type CustomerJobDetailFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the CustomerJobDetail
     * 
    **/
    select?: CustomerJobDetailSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CustomerJobDetailInclude | null
    /**
     * Filter, which CustomerJobDetail to fetch.
     * 
    **/
    where: CustomerJobDetailWhereUniqueInput
  }

  /**
   * CustomerJobDetail: findUnique
   */
  export interface CustomerJobDetailFindUniqueArgs extends CustomerJobDetailFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * CustomerJobDetail findUniqueOrThrow
   */
  export type CustomerJobDetailFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the CustomerJobDetail
     * 
    **/
    select?: CustomerJobDetailSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CustomerJobDetailInclude | null
    /**
     * Filter, which CustomerJobDetail to fetch.
     * 
    **/
    where: CustomerJobDetailWhereUniqueInput
  }


  /**
   * CustomerJobDetail base type for findFirst actions
   */
  export type CustomerJobDetailFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the CustomerJobDetail
     * 
    **/
    select?: CustomerJobDetailSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CustomerJobDetailInclude | null
    /**
     * Filter, which CustomerJobDetail to fetch.
     * 
    **/
    where?: CustomerJobDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerJobDetails to fetch.
     * 
    **/
    orderBy?: Enumerable<CustomerJobDetailOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CustomerJobDetails.
     * 
    **/
    cursor?: CustomerJobDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerJobDetails from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerJobDetails.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CustomerJobDetails.
     * 
    **/
    distinct?: Enumerable<CustomerJobDetailScalarFieldEnum>
  }

  /**
   * CustomerJobDetail: findFirst
   */
  export interface CustomerJobDetailFindFirstArgs extends CustomerJobDetailFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * CustomerJobDetail findFirstOrThrow
   */
  export type CustomerJobDetailFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the CustomerJobDetail
     * 
    **/
    select?: CustomerJobDetailSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CustomerJobDetailInclude | null
    /**
     * Filter, which CustomerJobDetail to fetch.
     * 
    **/
    where?: CustomerJobDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerJobDetails to fetch.
     * 
    **/
    orderBy?: Enumerable<CustomerJobDetailOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CustomerJobDetails.
     * 
    **/
    cursor?: CustomerJobDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerJobDetails from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerJobDetails.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CustomerJobDetails.
     * 
    **/
    distinct?: Enumerable<CustomerJobDetailScalarFieldEnum>
  }


  /**
   * CustomerJobDetail findMany
   */
  export type CustomerJobDetailFindManyArgs = {
    /**
     * Select specific fields to fetch from the CustomerJobDetail
     * 
    **/
    select?: CustomerJobDetailSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CustomerJobDetailInclude | null
    /**
     * Filter, which CustomerJobDetails to fetch.
     * 
    **/
    where?: CustomerJobDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerJobDetails to fetch.
     * 
    **/
    orderBy?: Enumerable<CustomerJobDetailOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CustomerJobDetails.
     * 
    **/
    cursor?: CustomerJobDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerJobDetails from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerJobDetails.
     * 
    **/
    skip?: number
    distinct?: Enumerable<CustomerJobDetailScalarFieldEnum>
  }


  /**
   * CustomerJobDetail create
   */
  export type CustomerJobDetailCreateArgs = {
    /**
     * Select specific fields to fetch from the CustomerJobDetail
     * 
    **/
    select?: CustomerJobDetailSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CustomerJobDetailInclude | null
    /**
     * The data needed to create a CustomerJobDetail.
     * 
    **/
    data: XOR<CustomerJobDetailCreateInput, CustomerJobDetailUncheckedCreateInput>
  }


  /**
   * CustomerJobDetail createMany
   */
  export type CustomerJobDetailCreateManyArgs = {
    /**
     * The data used to create many CustomerJobDetails.
     * 
    **/
    data: Enumerable<CustomerJobDetailCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * CustomerJobDetail update
   */
  export type CustomerJobDetailUpdateArgs = {
    /**
     * Select specific fields to fetch from the CustomerJobDetail
     * 
    **/
    select?: CustomerJobDetailSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CustomerJobDetailInclude | null
    /**
     * The data needed to update a CustomerJobDetail.
     * 
    **/
    data: XOR<CustomerJobDetailUpdateInput, CustomerJobDetailUncheckedUpdateInput>
    /**
     * Choose, which CustomerJobDetail to update.
     * 
    **/
    where: CustomerJobDetailWhereUniqueInput
  }


  /**
   * CustomerJobDetail updateMany
   */
  export type CustomerJobDetailUpdateManyArgs = {
    /**
     * The data used to update CustomerJobDetails.
     * 
    **/
    data: XOR<CustomerJobDetailUpdateManyMutationInput, CustomerJobDetailUncheckedUpdateManyInput>
    /**
     * Filter which CustomerJobDetails to update
     * 
    **/
    where?: CustomerJobDetailWhereInput
  }


  /**
   * CustomerJobDetail upsert
   */
  export type CustomerJobDetailUpsertArgs = {
    /**
     * Select specific fields to fetch from the CustomerJobDetail
     * 
    **/
    select?: CustomerJobDetailSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CustomerJobDetailInclude | null
    /**
     * The filter to search for the CustomerJobDetail to update in case it exists.
     * 
    **/
    where: CustomerJobDetailWhereUniqueInput
    /**
     * In case the CustomerJobDetail found by the `where` argument doesn't exist, create a new CustomerJobDetail with this data.
     * 
    **/
    create: XOR<CustomerJobDetailCreateInput, CustomerJobDetailUncheckedCreateInput>
    /**
     * In case the CustomerJobDetail was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<CustomerJobDetailUpdateInput, CustomerJobDetailUncheckedUpdateInput>
  }


  /**
   * CustomerJobDetail delete
   */
  export type CustomerJobDetailDeleteArgs = {
    /**
     * Select specific fields to fetch from the CustomerJobDetail
     * 
    **/
    select?: CustomerJobDetailSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CustomerJobDetailInclude | null
    /**
     * Filter which CustomerJobDetail to delete.
     * 
    **/
    where: CustomerJobDetailWhereUniqueInput
  }


  /**
   * CustomerJobDetail deleteMany
   */
  export type CustomerJobDetailDeleteManyArgs = {
    /**
     * Filter which CustomerJobDetails to delete
     * 
    **/
    where?: CustomerJobDetailWhereInput
  }


  /**
   * CustomerJobDetail without action
   */
  export type CustomerJobDetailArgs = {
    /**
     * Select specific fields to fetch from the CustomerJobDetail
     * 
    **/
    select?: CustomerJobDetailSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CustomerJobDetailInclude | null
  }



  /**
   * Model CustomerLanguage
   */


  export type AggregateCustomerLanguage = {
    _count: CustomerLanguageCountAggregateOutputType | null
    _avg: CustomerLanguageAvgAggregateOutputType | null
    _sum: CustomerLanguageSumAggregateOutputType | null
    _min: CustomerLanguageMinAggregateOutputType | null
    _max: CustomerLanguageMaxAggregateOutputType | null
  }

  export type CustomerLanguageAvgAggregateOutputType = {
    language: number | null
  }

  export type CustomerLanguageSumAggregateOutputType = {
    language: number | null
  }

  export type CustomerLanguageMinAggregateOutputType = {
    language_id: string | null
    customer_id: string | null
    level: LanguageLevel | null
    language: number | null
    is_motherlanguage: boolean | null
    created_at: Date | null
    updated_at: Date | null
    created_by: string | null
    updated_b: string | null
  }

  export type CustomerLanguageMaxAggregateOutputType = {
    language_id: string | null
    customer_id: string | null
    level: LanguageLevel | null
    language: number | null
    is_motherlanguage: boolean | null
    created_at: Date | null
    updated_at: Date | null
    created_by: string | null
    updated_b: string | null
  }

  export type CustomerLanguageCountAggregateOutputType = {
    language_id: number
    customer_id: number
    level: number
    language: number
    is_motherlanguage: number
    certificate: number
    created_at: number
    updated_at: number
    created_by: number
    updated_b: number
    _all: number
  }


  export type CustomerLanguageAvgAggregateInputType = {
    language?: true
  }

  export type CustomerLanguageSumAggregateInputType = {
    language?: true
  }

  export type CustomerLanguageMinAggregateInputType = {
    language_id?: true
    customer_id?: true
    level?: true
    language?: true
    is_motherlanguage?: true
    created_at?: true
    updated_at?: true
    created_by?: true
    updated_b?: true
  }

  export type CustomerLanguageMaxAggregateInputType = {
    language_id?: true
    customer_id?: true
    level?: true
    language?: true
    is_motherlanguage?: true
    created_at?: true
    updated_at?: true
    created_by?: true
    updated_b?: true
  }

  export type CustomerLanguageCountAggregateInputType = {
    language_id?: true
    customer_id?: true
    level?: true
    language?: true
    is_motherlanguage?: true
    certificate?: true
    created_at?: true
    updated_at?: true
    created_by?: true
    updated_b?: true
    _all?: true
  }

  export type CustomerLanguageAggregateArgs = {
    /**
     * Filter which CustomerLanguage to aggregate.
     * 
    **/
    where?: CustomerLanguageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerLanguages to fetch.
     * 
    **/
    orderBy?: Enumerable<CustomerLanguageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: CustomerLanguageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerLanguages from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerLanguages.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CustomerLanguages
    **/
    _count?: true | CustomerLanguageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CustomerLanguageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CustomerLanguageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomerLanguageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomerLanguageMaxAggregateInputType
  }

  export type GetCustomerLanguageAggregateType<T extends CustomerLanguageAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomerLanguage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomerLanguage[P]>
      : GetScalarType<T[P], AggregateCustomerLanguage[P]>
  }




  export type CustomerLanguageGroupByArgs = {
    where?: CustomerLanguageWhereInput
    orderBy?: Enumerable<CustomerLanguageOrderByWithAggregationInput>
    by: Array<CustomerLanguageScalarFieldEnum>
    having?: CustomerLanguageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomerLanguageCountAggregateInputType | true
    _avg?: CustomerLanguageAvgAggregateInputType
    _sum?: CustomerLanguageSumAggregateInputType
    _min?: CustomerLanguageMinAggregateInputType
    _max?: CustomerLanguageMaxAggregateInputType
  }


  export type CustomerLanguageGroupByOutputType = {
    language_id: string
    customer_id: string
    level: LanguageLevel | null
    language: number | null
    is_motherlanguage: boolean
    certificate: JsonValue | null
    created_at: Date
    updated_at: Date | null
    created_by: string | null
    updated_b: string | null
    _count: CustomerLanguageCountAggregateOutputType | null
    _avg: CustomerLanguageAvgAggregateOutputType | null
    _sum: CustomerLanguageSumAggregateOutputType | null
    _min: CustomerLanguageMinAggregateOutputType | null
    _max: CustomerLanguageMaxAggregateOutputType | null
  }

  type GetCustomerLanguageGroupByPayload<T extends CustomerLanguageGroupByArgs> = PrismaPromise<
    Array<
      PickArray<CustomerLanguageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomerLanguageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomerLanguageGroupByOutputType[P]>
            : GetScalarType<T[P], CustomerLanguageGroupByOutputType[P]>
        }
      >
    >


  export type CustomerLanguageSelect = {
    language_id?: boolean
    customer_id?: boolean
    customer?: boolean | CustomerArgs
    level?: boolean
    language?: boolean
    is_motherlanguage?: boolean
    certificate?: boolean
    created_at?: boolean
    updated_at?: boolean
    created_by?: boolean
    updated_b?: boolean
  }


  export type CustomerLanguageInclude = {
    customer?: boolean | CustomerArgs
  } 

  export type CustomerLanguageGetPayload<S extends boolean | null | undefined | CustomerLanguageArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? CustomerLanguage :
    S extends undefined ? never :
    S extends { include: any } & (CustomerLanguageArgs | CustomerLanguageFindManyArgs)
    ? CustomerLanguage  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'customer' ? CustomerGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (CustomerLanguageArgs | CustomerLanguageFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'customer' ? CustomerGetPayload<S['select'][P]> :  P extends keyof CustomerLanguage ? CustomerLanguage[P] : never
  } 
      : CustomerLanguage


  type CustomerLanguageCountArgs = Merge<
    Omit<CustomerLanguageFindManyArgs, 'select' | 'include'> & {
      select?: CustomerLanguageCountAggregateInputType | true
    }
  >

  export interface CustomerLanguageDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one CustomerLanguage that matches the filter.
     * @param {CustomerLanguageFindUniqueArgs} args - Arguments to find a CustomerLanguage
     * @example
     * // Get one CustomerLanguage
     * const customerLanguage = await prisma.customerLanguage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CustomerLanguageFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CustomerLanguageFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'CustomerLanguage'> extends True ? Prisma__CustomerLanguageClient<CustomerLanguageGetPayload<T>> : Prisma__CustomerLanguageClient<CustomerLanguageGetPayload<T> | null, null>

    /**
     * Find one CustomerLanguage that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CustomerLanguageFindUniqueOrThrowArgs} args - Arguments to find a CustomerLanguage
     * @example
     * // Get one CustomerLanguage
     * const customerLanguage = await prisma.customerLanguage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CustomerLanguageFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, CustomerLanguageFindUniqueOrThrowArgs>
    ): Prisma__CustomerLanguageClient<CustomerLanguageGetPayload<T>>

    /**
     * Find the first CustomerLanguage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerLanguageFindFirstArgs} args - Arguments to find a CustomerLanguage
     * @example
     * // Get one CustomerLanguage
     * const customerLanguage = await prisma.customerLanguage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CustomerLanguageFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CustomerLanguageFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'CustomerLanguage'> extends True ? Prisma__CustomerLanguageClient<CustomerLanguageGetPayload<T>> : Prisma__CustomerLanguageClient<CustomerLanguageGetPayload<T> | null, null>

    /**
     * Find the first CustomerLanguage that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerLanguageFindFirstOrThrowArgs} args - Arguments to find a CustomerLanguage
     * @example
     * // Get one CustomerLanguage
     * const customerLanguage = await prisma.customerLanguage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CustomerLanguageFindFirstOrThrowArgs>(
      args?: SelectSubset<T, CustomerLanguageFindFirstOrThrowArgs>
    ): Prisma__CustomerLanguageClient<CustomerLanguageGetPayload<T>>

    /**
     * Find zero or more CustomerLanguages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerLanguageFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CustomerLanguages
     * const customerLanguages = await prisma.customerLanguage.findMany()
     * 
     * // Get first 10 CustomerLanguages
     * const customerLanguages = await prisma.customerLanguage.findMany({ take: 10 })
     * 
     * // Only select the `language_id`
     * const customerLanguageWithLanguage_idOnly = await prisma.customerLanguage.findMany({ select: { language_id: true } })
     * 
    **/
    findMany<T extends CustomerLanguageFindManyArgs>(
      args?: SelectSubset<T, CustomerLanguageFindManyArgs>
    ): PrismaPromise<Array<CustomerLanguageGetPayload<T>>>

    /**
     * Create a CustomerLanguage.
     * @param {CustomerLanguageCreateArgs} args - Arguments to create a CustomerLanguage.
     * @example
     * // Create one CustomerLanguage
     * const CustomerLanguage = await prisma.customerLanguage.create({
     *   data: {
     *     // ... data to create a CustomerLanguage
     *   }
     * })
     * 
    **/
    create<T extends CustomerLanguageCreateArgs>(
      args: SelectSubset<T, CustomerLanguageCreateArgs>
    ): Prisma__CustomerLanguageClient<CustomerLanguageGetPayload<T>>

    /**
     * Create many CustomerLanguages.
     *     @param {CustomerLanguageCreateManyArgs} args - Arguments to create many CustomerLanguages.
     *     @example
     *     // Create many CustomerLanguages
     *     const customerLanguage = await prisma.customerLanguage.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CustomerLanguageCreateManyArgs>(
      args?: SelectSubset<T, CustomerLanguageCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a CustomerLanguage.
     * @param {CustomerLanguageDeleteArgs} args - Arguments to delete one CustomerLanguage.
     * @example
     * // Delete one CustomerLanguage
     * const CustomerLanguage = await prisma.customerLanguage.delete({
     *   where: {
     *     // ... filter to delete one CustomerLanguage
     *   }
     * })
     * 
    **/
    delete<T extends CustomerLanguageDeleteArgs>(
      args: SelectSubset<T, CustomerLanguageDeleteArgs>
    ): Prisma__CustomerLanguageClient<CustomerLanguageGetPayload<T>>

    /**
     * Update one CustomerLanguage.
     * @param {CustomerLanguageUpdateArgs} args - Arguments to update one CustomerLanguage.
     * @example
     * // Update one CustomerLanguage
     * const customerLanguage = await prisma.customerLanguage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CustomerLanguageUpdateArgs>(
      args: SelectSubset<T, CustomerLanguageUpdateArgs>
    ): Prisma__CustomerLanguageClient<CustomerLanguageGetPayload<T>>

    /**
     * Delete zero or more CustomerLanguages.
     * @param {CustomerLanguageDeleteManyArgs} args - Arguments to filter CustomerLanguages to delete.
     * @example
     * // Delete a few CustomerLanguages
     * const { count } = await prisma.customerLanguage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CustomerLanguageDeleteManyArgs>(
      args?: SelectSubset<T, CustomerLanguageDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more CustomerLanguages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerLanguageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CustomerLanguages
     * const customerLanguage = await prisma.customerLanguage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CustomerLanguageUpdateManyArgs>(
      args: SelectSubset<T, CustomerLanguageUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one CustomerLanguage.
     * @param {CustomerLanguageUpsertArgs} args - Arguments to update or create a CustomerLanguage.
     * @example
     * // Update or create a CustomerLanguage
     * const customerLanguage = await prisma.customerLanguage.upsert({
     *   create: {
     *     // ... data to create a CustomerLanguage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CustomerLanguage we want to update
     *   }
     * })
    **/
    upsert<T extends CustomerLanguageUpsertArgs>(
      args: SelectSubset<T, CustomerLanguageUpsertArgs>
    ): Prisma__CustomerLanguageClient<CustomerLanguageGetPayload<T>>

    /**
     * Count the number of CustomerLanguages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerLanguageCountArgs} args - Arguments to filter CustomerLanguages to count.
     * @example
     * // Count the number of CustomerLanguages
     * const count = await prisma.customerLanguage.count({
     *   where: {
     *     // ... the filter for the CustomerLanguages we want to count
     *   }
     * })
    **/
    count<T extends CustomerLanguageCountArgs>(
      args?: Subset<T, CustomerLanguageCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomerLanguageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CustomerLanguage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerLanguageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomerLanguageAggregateArgs>(args: Subset<T, CustomerLanguageAggregateArgs>): PrismaPromise<GetCustomerLanguageAggregateType<T>>

    /**
     * Group by CustomerLanguage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerLanguageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CustomerLanguageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CustomerLanguageGroupByArgs['orderBy'] }
        : { orderBy?: CustomerLanguageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CustomerLanguageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomerLanguageGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for CustomerLanguage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CustomerLanguageClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    customer<T extends CustomerArgs= {}>(args?: Subset<T, CustomerArgs>): Prisma__CustomerClient<CustomerGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * CustomerLanguage base type for findUnique actions
   */
  export type CustomerLanguageFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the CustomerLanguage
     * 
    **/
    select?: CustomerLanguageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CustomerLanguageInclude | null
    /**
     * Filter, which CustomerLanguage to fetch.
     * 
    **/
    where: CustomerLanguageWhereUniqueInput
  }

  /**
   * CustomerLanguage: findUnique
   */
  export interface CustomerLanguageFindUniqueArgs extends CustomerLanguageFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * CustomerLanguage findUniqueOrThrow
   */
  export type CustomerLanguageFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the CustomerLanguage
     * 
    **/
    select?: CustomerLanguageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CustomerLanguageInclude | null
    /**
     * Filter, which CustomerLanguage to fetch.
     * 
    **/
    where: CustomerLanguageWhereUniqueInput
  }


  /**
   * CustomerLanguage base type for findFirst actions
   */
  export type CustomerLanguageFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the CustomerLanguage
     * 
    **/
    select?: CustomerLanguageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CustomerLanguageInclude | null
    /**
     * Filter, which CustomerLanguage to fetch.
     * 
    **/
    where?: CustomerLanguageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerLanguages to fetch.
     * 
    **/
    orderBy?: Enumerable<CustomerLanguageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CustomerLanguages.
     * 
    **/
    cursor?: CustomerLanguageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerLanguages from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerLanguages.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CustomerLanguages.
     * 
    **/
    distinct?: Enumerable<CustomerLanguageScalarFieldEnum>
  }

  /**
   * CustomerLanguage: findFirst
   */
  export interface CustomerLanguageFindFirstArgs extends CustomerLanguageFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * CustomerLanguage findFirstOrThrow
   */
  export type CustomerLanguageFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the CustomerLanguage
     * 
    **/
    select?: CustomerLanguageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CustomerLanguageInclude | null
    /**
     * Filter, which CustomerLanguage to fetch.
     * 
    **/
    where?: CustomerLanguageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerLanguages to fetch.
     * 
    **/
    orderBy?: Enumerable<CustomerLanguageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CustomerLanguages.
     * 
    **/
    cursor?: CustomerLanguageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerLanguages from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerLanguages.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CustomerLanguages.
     * 
    **/
    distinct?: Enumerable<CustomerLanguageScalarFieldEnum>
  }


  /**
   * CustomerLanguage findMany
   */
  export type CustomerLanguageFindManyArgs = {
    /**
     * Select specific fields to fetch from the CustomerLanguage
     * 
    **/
    select?: CustomerLanguageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CustomerLanguageInclude | null
    /**
     * Filter, which CustomerLanguages to fetch.
     * 
    **/
    where?: CustomerLanguageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerLanguages to fetch.
     * 
    **/
    orderBy?: Enumerable<CustomerLanguageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CustomerLanguages.
     * 
    **/
    cursor?: CustomerLanguageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerLanguages from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerLanguages.
     * 
    **/
    skip?: number
    distinct?: Enumerable<CustomerLanguageScalarFieldEnum>
  }


  /**
   * CustomerLanguage create
   */
  export type CustomerLanguageCreateArgs = {
    /**
     * Select specific fields to fetch from the CustomerLanguage
     * 
    **/
    select?: CustomerLanguageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CustomerLanguageInclude | null
    /**
     * The data needed to create a CustomerLanguage.
     * 
    **/
    data: XOR<CustomerLanguageCreateInput, CustomerLanguageUncheckedCreateInput>
  }


  /**
   * CustomerLanguage createMany
   */
  export type CustomerLanguageCreateManyArgs = {
    /**
     * The data used to create many CustomerLanguages.
     * 
    **/
    data: Enumerable<CustomerLanguageCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * CustomerLanguage update
   */
  export type CustomerLanguageUpdateArgs = {
    /**
     * Select specific fields to fetch from the CustomerLanguage
     * 
    **/
    select?: CustomerLanguageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CustomerLanguageInclude | null
    /**
     * The data needed to update a CustomerLanguage.
     * 
    **/
    data: XOR<CustomerLanguageUpdateInput, CustomerLanguageUncheckedUpdateInput>
    /**
     * Choose, which CustomerLanguage to update.
     * 
    **/
    where: CustomerLanguageWhereUniqueInput
  }


  /**
   * CustomerLanguage updateMany
   */
  export type CustomerLanguageUpdateManyArgs = {
    /**
     * The data used to update CustomerLanguages.
     * 
    **/
    data: XOR<CustomerLanguageUpdateManyMutationInput, CustomerLanguageUncheckedUpdateManyInput>
    /**
     * Filter which CustomerLanguages to update
     * 
    **/
    where?: CustomerLanguageWhereInput
  }


  /**
   * CustomerLanguage upsert
   */
  export type CustomerLanguageUpsertArgs = {
    /**
     * Select specific fields to fetch from the CustomerLanguage
     * 
    **/
    select?: CustomerLanguageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CustomerLanguageInclude | null
    /**
     * The filter to search for the CustomerLanguage to update in case it exists.
     * 
    **/
    where: CustomerLanguageWhereUniqueInput
    /**
     * In case the CustomerLanguage found by the `where` argument doesn't exist, create a new CustomerLanguage with this data.
     * 
    **/
    create: XOR<CustomerLanguageCreateInput, CustomerLanguageUncheckedCreateInput>
    /**
     * In case the CustomerLanguage was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<CustomerLanguageUpdateInput, CustomerLanguageUncheckedUpdateInput>
  }


  /**
   * CustomerLanguage delete
   */
  export type CustomerLanguageDeleteArgs = {
    /**
     * Select specific fields to fetch from the CustomerLanguage
     * 
    **/
    select?: CustomerLanguageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CustomerLanguageInclude | null
    /**
     * Filter which CustomerLanguage to delete.
     * 
    **/
    where: CustomerLanguageWhereUniqueInput
  }


  /**
   * CustomerLanguage deleteMany
   */
  export type CustomerLanguageDeleteManyArgs = {
    /**
     * Filter which CustomerLanguages to delete
     * 
    **/
    where?: CustomerLanguageWhereInput
  }


  /**
   * CustomerLanguage without action
   */
  export type CustomerLanguageArgs = {
    /**
     * Select specific fields to fetch from the CustomerLanguage
     * 
    **/
    select?: CustomerLanguageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CustomerLanguageInclude | null
  }



  /**
   * Model CustomerQualification
   */


  export type AggregateCustomerQualification = {
    _count: CustomerQualificationCountAggregateOutputType | null
    _min: CustomerQualificationMinAggregateOutputType | null
    _max: CustomerQualificationMaxAggregateOutputType | null
  }

  export type CustomerQualificationMinAggregateOutputType = {
    qualification_id: string | null
    customer_id: string | null
    created_at: Date | null
    updated_at: Date | null
    created_by: string | null
    updated_by: string | null
  }

  export type CustomerQualificationMaxAggregateOutputType = {
    qualification_id: string | null
    customer_id: string | null
    created_at: Date | null
    updated_at: Date | null
    created_by: string | null
    updated_by: string | null
  }

  export type CustomerQualificationCountAggregateOutputType = {
    qualification_id: number
    customer_id: number
    qualification: number
    created_at: number
    updated_at: number
    created_by: number
    updated_by: number
    _all: number
  }


  export type CustomerQualificationMinAggregateInputType = {
    qualification_id?: true
    customer_id?: true
    created_at?: true
    updated_at?: true
    created_by?: true
    updated_by?: true
  }

  export type CustomerQualificationMaxAggregateInputType = {
    qualification_id?: true
    customer_id?: true
    created_at?: true
    updated_at?: true
    created_by?: true
    updated_by?: true
  }

  export type CustomerQualificationCountAggregateInputType = {
    qualification_id?: true
    customer_id?: true
    qualification?: true
    created_at?: true
    updated_at?: true
    created_by?: true
    updated_by?: true
    _all?: true
  }

  export type CustomerQualificationAggregateArgs = {
    /**
     * Filter which CustomerQualification to aggregate.
     * 
    **/
    where?: CustomerQualificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerQualifications to fetch.
     * 
    **/
    orderBy?: Enumerable<CustomerQualificationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: CustomerQualificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerQualifications from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerQualifications.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CustomerQualifications
    **/
    _count?: true | CustomerQualificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomerQualificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomerQualificationMaxAggregateInputType
  }

  export type GetCustomerQualificationAggregateType<T extends CustomerQualificationAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomerQualification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomerQualification[P]>
      : GetScalarType<T[P], AggregateCustomerQualification[P]>
  }




  export type CustomerQualificationGroupByArgs = {
    where?: CustomerQualificationWhereInput
    orderBy?: Enumerable<CustomerQualificationOrderByWithAggregationInput>
    by: Array<CustomerQualificationScalarFieldEnum>
    having?: CustomerQualificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomerQualificationCountAggregateInputType | true
    _min?: CustomerQualificationMinAggregateInputType
    _max?: CustomerQualificationMaxAggregateInputType
  }


  export type CustomerQualificationGroupByOutputType = {
    qualification_id: string
    customer_id: string
    qualification: JsonValue | null
    created_at: Date
    updated_at: Date
    created_by: string | null
    updated_by: string | null
    _count: CustomerQualificationCountAggregateOutputType | null
    _min: CustomerQualificationMinAggregateOutputType | null
    _max: CustomerQualificationMaxAggregateOutputType | null
  }

  type GetCustomerQualificationGroupByPayload<T extends CustomerQualificationGroupByArgs> = PrismaPromise<
    Array<
      PickArray<CustomerQualificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomerQualificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomerQualificationGroupByOutputType[P]>
            : GetScalarType<T[P], CustomerQualificationGroupByOutputType[P]>
        }
      >
    >


  export type CustomerQualificationSelect = {
    qualification_id?: boolean
    customer_id?: boolean
    customers?: boolean | CustomerArgs
    qualification?: boolean
    created_at?: boolean
    updated_at?: boolean
    created_by?: boolean
    updated_by?: boolean
  }


  export type CustomerQualificationInclude = {
    customers?: boolean | CustomerArgs
  } 

  export type CustomerQualificationGetPayload<S extends boolean | null | undefined | CustomerQualificationArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? CustomerQualification :
    S extends undefined ? never :
    S extends { include: any } & (CustomerQualificationArgs | CustomerQualificationFindManyArgs)
    ? CustomerQualification  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'customers' ? CustomerGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (CustomerQualificationArgs | CustomerQualificationFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'customers' ? CustomerGetPayload<S['select'][P]> :  P extends keyof CustomerQualification ? CustomerQualification[P] : never
  } 
      : CustomerQualification


  type CustomerQualificationCountArgs = Merge<
    Omit<CustomerQualificationFindManyArgs, 'select' | 'include'> & {
      select?: CustomerQualificationCountAggregateInputType | true
    }
  >

  export interface CustomerQualificationDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one CustomerQualification that matches the filter.
     * @param {CustomerQualificationFindUniqueArgs} args - Arguments to find a CustomerQualification
     * @example
     * // Get one CustomerQualification
     * const customerQualification = await prisma.customerQualification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CustomerQualificationFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CustomerQualificationFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'CustomerQualification'> extends True ? Prisma__CustomerQualificationClient<CustomerQualificationGetPayload<T>> : Prisma__CustomerQualificationClient<CustomerQualificationGetPayload<T> | null, null>

    /**
     * Find one CustomerQualification that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CustomerQualificationFindUniqueOrThrowArgs} args - Arguments to find a CustomerQualification
     * @example
     * // Get one CustomerQualification
     * const customerQualification = await prisma.customerQualification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CustomerQualificationFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, CustomerQualificationFindUniqueOrThrowArgs>
    ): Prisma__CustomerQualificationClient<CustomerQualificationGetPayload<T>>

    /**
     * Find the first CustomerQualification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerQualificationFindFirstArgs} args - Arguments to find a CustomerQualification
     * @example
     * // Get one CustomerQualification
     * const customerQualification = await prisma.customerQualification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CustomerQualificationFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CustomerQualificationFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'CustomerQualification'> extends True ? Prisma__CustomerQualificationClient<CustomerQualificationGetPayload<T>> : Prisma__CustomerQualificationClient<CustomerQualificationGetPayload<T> | null, null>

    /**
     * Find the first CustomerQualification that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerQualificationFindFirstOrThrowArgs} args - Arguments to find a CustomerQualification
     * @example
     * // Get one CustomerQualification
     * const customerQualification = await prisma.customerQualification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CustomerQualificationFindFirstOrThrowArgs>(
      args?: SelectSubset<T, CustomerQualificationFindFirstOrThrowArgs>
    ): Prisma__CustomerQualificationClient<CustomerQualificationGetPayload<T>>

    /**
     * Find zero or more CustomerQualifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerQualificationFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CustomerQualifications
     * const customerQualifications = await prisma.customerQualification.findMany()
     * 
     * // Get first 10 CustomerQualifications
     * const customerQualifications = await prisma.customerQualification.findMany({ take: 10 })
     * 
     * // Only select the `qualification_id`
     * const customerQualificationWithQualification_idOnly = await prisma.customerQualification.findMany({ select: { qualification_id: true } })
     * 
    **/
    findMany<T extends CustomerQualificationFindManyArgs>(
      args?: SelectSubset<T, CustomerQualificationFindManyArgs>
    ): PrismaPromise<Array<CustomerQualificationGetPayload<T>>>

    /**
     * Create a CustomerQualification.
     * @param {CustomerQualificationCreateArgs} args - Arguments to create a CustomerQualification.
     * @example
     * // Create one CustomerQualification
     * const CustomerQualification = await prisma.customerQualification.create({
     *   data: {
     *     // ... data to create a CustomerQualification
     *   }
     * })
     * 
    **/
    create<T extends CustomerQualificationCreateArgs>(
      args: SelectSubset<T, CustomerQualificationCreateArgs>
    ): Prisma__CustomerQualificationClient<CustomerQualificationGetPayload<T>>

    /**
     * Create many CustomerQualifications.
     *     @param {CustomerQualificationCreateManyArgs} args - Arguments to create many CustomerQualifications.
     *     @example
     *     // Create many CustomerQualifications
     *     const customerQualification = await prisma.customerQualification.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CustomerQualificationCreateManyArgs>(
      args?: SelectSubset<T, CustomerQualificationCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a CustomerQualification.
     * @param {CustomerQualificationDeleteArgs} args - Arguments to delete one CustomerQualification.
     * @example
     * // Delete one CustomerQualification
     * const CustomerQualification = await prisma.customerQualification.delete({
     *   where: {
     *     // ... filter to delete one CustomerQualification
     *   }
     * })
     * 
    **/
    delete<T extends CustomerQualificationDeleteArgs>(
      args: SelectSubset<T, CustomerQualificationDeleteArgs>
    ): Prisma__CustomerQualificationClient<CustomerQualificationGetPayload<T>>

    /**
     * Update one CustomerQualification.
     * @param {CustomerQualificationUpdateArgs} args - Arguments to update one CustomerQualification.
     * @example
     * // Update one CustomerQualification
     * const customerQualification = await prisma.customerQualification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CustomerQualificationUpdateArgs>(
      args: SelectSubset<T, CustomerQualificationUpdateArgs>
    ): Prisma__CustomerQualificationClient<CustomerQualificationGetPayload<T>>

    /**
     * Delete zero or more CustomerQualifications.
     * @param {CustomerQualificationDeleteManyArgs} args - Arguments to filter CustomerQualifications to delete.
     * @example
     * // Delete a few CustomerQualifications
     * const { count } = await prisma.customerQualification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CustomerQualificationDeleteManyArgs>(
      args?: SelectSubset<T, CustomerQualificationDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more CustomerQualifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerQualificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CustomerQualifications
     * const customerQualification = await prisma.customerQualification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CustomerQualificationUpdateManyArgs>(
      args: SelectSubset<T, CustomerQualificationUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one CustomerQualification.
     * @param {CustomerQualificationUpsertArgs} args - Arguments to update or create a CustomerQualification.
     * @example
     * // Update or create a CustomerQualification
     * const customerQualification = await prisma.customerQualification.upsert({
     *   create: {
     *     // ... data to create a CustomerQualification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CustomerQualification we want to update
     *   }
     * })
    **/
    upsert<T extends CustomerQualificationUpsertArgs>(
      args: SelectSubset<T, CustomerQualificationUpsertArgs>
    ): Prisma__CustomerQualificationClient<CustomerQualificationGetPayload<T>>

    /**
     * Count the number of CustomerQualifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerQualificationCountArgs} args - Arguments to filter CustomerQualifications to count.
     * @example
     * // Count the number of CustomerQualifications
     * const count = await prisma.customerQualification.count({
     *   where: {
     *     // ... the filter for the CustomerQualifications we want to count
     *   }
     * })
    **/
    count<T extends CustomerQualificationCountArgs>(
      args?: Subset<T, CustomerQualificationCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomerQualificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CustomerQualification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerQualificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomerQualificationAggregateArgs>(args: Subset<T, CustomerQualificationAggregateArgs>): PrismaPromise<GetCustomerQualificationAggregateType<T>>

    /**
     * Group by CustomerQualification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerQualificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CustomerQualificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CustomerQualificationGroupByArgs['orderBy'] }
        : { orderBy?: CustomerQualificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CustomerQualificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomerQualificationGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for CustomerQualification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CustomerQualificationClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    customers<T extends CustomerArgs= {}>(args?: Subset<T, CustomerArgs>): Prisma__CustomerClient<CustomerGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * CustomerQualification base type for findUnique actions
   */
  export type CustomerQualificationFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the CustomerQualification
     * 
    **/
    select?: CustomerQualificationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CustomerQualificationInclude | null
    /**
     * Filter, which CustomerQualification to fetch.
     * 
    **/
    where: CustomerQualificationWhereUniqueInput
  }

  /**
   * CustomerQualification: findUnique
   */
  export interface CustomerQualificationFindUniqueArgs extends CustomerQualificationFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * CustomerQualification findUniqueOrThrow
   */
  export type CustomerQualificationFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the CustomerQualification
     * 
    **/
    select?: CustomerQualificationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CustomerQualificationInclude | null
    /**
     * Filter, which CustomerQualification to fetch.
     * 
    **/
    where: CustomerQualificationWhereUniqueInput
  }


  /**
   * CustomerQualification base type for findFirst actions
   */
  export type CustomerQualificationFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the CustomerQualification
     * 
    **/
    select?: CustomerQualificationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CustomerQualificationInclude | null
    /**
     * Filter, which CustomerQualification to fetch.
     * 
    **/
    where?: CustomerQualificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerQualifications to fetch.
     * 
    **/
    orderBy?: Enumerable<CustomerQualificationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CustomerQualifications.
     * 
    **/
    cursor?: CustomerQualificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerQualifications from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerQualifications.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CustomerQualifications.
     * 
    **/
    distinct?: Enumerable<CustomerQualificationScalarFieldEnum>
  }

  /**
   * CustomerQualification: findFirst
   */
  export interface CustomerQualificationFindFirstArgs extends CustomerQualificationFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * CustomerQualification findFirstOrThrow
   */
  export type CustomerQualificationFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the CustomerQualification
     * 
    **/
    select?: CustomerQualificationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CustomerQualificationInclude | null
    /**
     * Filter, which CustomerQualification to fetch.
     * 
    **/
    where?: CustomerQualificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerQualifications to fetch.
     * 
    **/
    orderBy?: Enumerable<CustomerQualificationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CustomerQualifications.
     * 
    **/
    cursor?: CustomerQualificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerQualifications from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerQualifications.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CustomerQualifications.
     * 
    **/
    distinct?: Enumerable<CustomerQualificationScalarFieldEnum>
  }


  /**
   * CustomerQualification findMany
   */
  export type CustomerQualificationFindManyArgs = {
    /**
     * Select specific fields to fetch from the CustomerQualification
     * 
    **/
    select?: CustomerQualificationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CustomerQualificationInclude | null
    /**
     * Filter, which CustomerQualifications to fetch.
     * 
    **/
    where?: CustomerQualificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerQualifications to fetch.
     * 
    **/
    orderBy?: Enumerable<CustomerQualificationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CustomerQualifications.
     * 
    **/
    cursor?: CustomerQualificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerQualifications from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerQualifications.
     * 
    **/
    skip?: number
    distinct?: Enumerable<CustomerQualificationScalarFieldEnum>
  }


  /**
   * CustomerQualification create
   */
  export type CustomerQualificationCreateArgs = {
    /**
     * Select specific fields to fetch from the CustomerQualification
     * 
    **/
    select?: CustomerQualificationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CustomerQualificationInclude | null
    /**
     * The data needed to create a CustomerQualification.
     * 
    **/
    data: XOR<CustomerQualificationCreateInput, CustomerQualificationUncheckedCreateInput>
  }


  /**
   * CustomerQualification createMany
   */
  export type CustomerQualificationCreateManyArgs = {
    /**
     * The data used to create many CustomerQualifications.
     * 
    **/
    data: Enumerable<CustomerQualificationCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * CustomerQualification update
   */
  export type CustomerQualificationUpdateArgs = {
    /**
     * Select specific fields to fetch from the CustomerQualification
     * 
    **/
    select?: CustomerQualificationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CustomerQualificationInclude | null
    /**
     * The data needed to update a CustomerQualification.
     * 
    **/
    data: XOR<CustomerQualificationUpdateInput, CustomerQualificationUncheckedUpdateInput>
    /**
     * Choose, which CustomerQualification to update.
     * 
    **/
    where: CustomerQualificationWhereUniqueInput
  }


  /**
   * CustomerQualification updateMany
   */
  export type CustomerQualificationUpdateManyArgs = {
    /**
     * The data used to update CustomerQualifications.
     * 
    **/
    data: XOR<CustomerQualificationUpdateManyMutationInput, CustomerQualificationUncheckedUpdateManyInput>
    /**
     * Filter which CustomerQualifications to update
     * 
    **/
    where?: CustomerQualificationWhereInput
  }


  /**
   * CustomerQualification upsert
   */
  export type CustomerQualificationUpsertArgs = {
    /**
     * Select specific fields to fetch from the CustomerQualification
     * 
    **/
    select?: CustomerQualificationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CustomerQualificationInclude | null
    /**
     * The filter to search for the CustomerQualification to update in case it exists.
     * 
    **/
    where: CustomerQualificationWhereUniqueInput
    /**
     * In case the CustomerQualification found by the `where` argument doesn't exist, create a new CustomerQualification with this data.
     * 
    **/
    create: XOR<CustomerQualificationCreateInput, CustomerQualificationUncheckedCreateInput>
    /**
     * In case the CustomerQualification was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<CustomerQualificationUpdateInput, CustomerQualificationUncheckedUpdateInput>
  }


  /**
   * CustomerQualification delete
   */
  export type CustomerQualificationDeleteArgs = {
    /**
     * Select specific fields to fetch from the CustomerQualification
     * 
    **/
    select?: CustomerQualificationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CustomerQualificationInclude | null
    /**
     * Filter which CustomerQualification to delete.
     * 
    **/
    where: CustomerQualificationWhereUniqueInput
  }


  /**
   * CustomerQualification deleteMany
   */
  export type CustomerQualificationDeleteManyArgs = {
    /**
     * Filter which CustomerQualifications to delete
     * 
    **/
    where?: CustomerQualificationWhereInput
  }


  /**
   * CustomerQualification without action
   */
  export type CustomerQualificationArgs = {
    /**
     * Select specific fields to fetch from the CustomerQualification
     * 
    **/
    select?: CustomerQualificationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CustomerQualificationInclude | null
  }



  /**
   * Model CustomerVisa
   */


  export type AggregateCustomerVisa = {
    _count: CustomerVisaCountAggregateOutputType | null
    _min: CustomerVisaMinAggregateOutputType | null
    _max: CustomerVisaMaxAggregateOutputType | null
  }

  export type CustomerVisaMinAggregateOutputType = {
    visa_id: string | null
    customer_id: string | null
    status_visa: StatusVisa | null
    date_expire: Date | null
    country_citizenship: string | null
    back_visafile: string | null
    front_visafile: string | null
    created_at: Date | null
    updated_at: Date | null
    created_by: string | null
    updated_by: string | null
  }

  export type CustomerVisaMaxAggregateOutputType = {
    visa_id: string | null
    customer_id: string | null
    status_visa: StatusVisa | null
    date_expire: Date | null
    country_citizenship: string | null
    back_visafile: string | null
    front_visafile: string | null
    created_at: Date | null
    updated_at: Date | null
    created_by: string | null
    updated_by: string | null
  }

  export type CustomerVisaCountAggregateOutputType = {
    visa_id: number
    customer_id: number
    status_visa: number
    date_expire: number
    country_citizenship: number
    back_visafile: number
    front_visafile: number
    created_at: number
    updated_at: number
    created_by: number
    updated_by: number
    _all: number
  }


  export type CustomerVisaMinAggregateInputType = {
    visa_id?: true
    customer_id?: true
    status_visa?: true
    date_expire?: true
    country_citizenship?: true
    back_visafile?: true
    front_visafile?: true
    created_at?: true
    updated_at?: true
    created_by?: true
    updated_by?: true
  }

  export type CustomerVisaMaxAggregateInputType = {
    visa_id?: true
    customer_id?: true
    status_visa?: true
    date_expire?: true
    country_citizenship?: true
    back_visafile?: true
    front_visafile?: true
    created_at?: true
    updated_at?: true
    created_by?: true
    updated_by?: true
  }

  export type CustomerVisaCountAggregateInputType = {
    visa_id?: true
    customer_id?: true
    status_visa?: true
    date_expire?: true
    country_citizenship?: true
    back_visafile?: true
    front_visafile?: true
    created_at?: true
    updated_at?: true
    created_by?: true
    updated_by?: true
    _all?: true
  }

  export type CustomerVisaAggregateArgs = {
    /**
     * Filter which CustomerVisa to aggregate.
     * 
    **/
    where?: CustomerVisaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerVisas to fetch.
     * 
    **/
    orderBy?: Enumerable<CustomerVisaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: CustomerVisaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerVisas from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerVisas.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CustomerVisas
    **/
    _count?: true | CustomerVisaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomerVisaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomerVisaMaxAggregateInputType
  }

  export type GetCustomerVisaAggregateType<T extends CustomerVisaAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomerVisa]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomerVisa[P]>
      : GetScalarType<T[P], AggregateCustomerVisa[P]>
  }




  export type CustomerVisaGroupByArgs = {
    where?: CustomerVisaWhereInput
    orderBy?: Enumerable<CustomerVisaOrderByWithAggregationInput>
    by: Array<CustomerVisaScalarFieldEnum>
    having?: CustomerVisaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomerVisaCountAggregateInputType | true
    _min?: CustomerVisaMinAggregateInputType
    _max?: CustomerVisaMaxAggregateInputType
  }


  export type CustomerVisaGroupByOutputType = {
    visa_id: string
    customer_id: string
    status_visa: StatusVisa | null
    date_expire: Date | null
    country_citizenship: string | null
    back_visafile: string | null
    front_visafile: string | null
    created_at: Date
    updated_at: Date
    created_by: string | null
    updated_by: string | null
    _count: CustomerVisaCountAggregateOutputType | null
    _min: CustomerVisaMinAggregateOutputType | null
    _max: CustomerVisaMaxAggregateOutputType | null
  }

  type GetCustomerVisaGroupByPayload<T extends CustomerVisaGroupByArgs> = PrismaPromise<
    Array<
      PickArray<CustomerVisaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomerVisaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomerVisaGroupByOutputType[P]>
            : GetScalarType<T[P], CustomerVisaGroupByOutputType[P]>
        }
      >
    >


  export type CustomerVisaSelect = {
    visa_id?: boolean
    customer_id?: boolean
    customer?: boolean | CustomerArgs
    status_visa?: boolean
    date_expire?: boolean
    country_citizenship?: boolean
    back_visafile?: boolean
    front_visafile?: boolean
    created_at?: boolean
    updated_at?: boolean
    created_by?: boolean
    updated_by?: boolean
  }


  export type CustomerVisaInclude = {
    customer?: boolean | CustomerArgs
  } 

  export type CustomerVisaGetPayload<S extends boolean | null | undefined | CustomerVisaArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? CustomerVisa :
    S extends undefined ? never :
    S extends { include: any } & (CustomerVisaArgs | CustomerVisaFindManyArgs)
    ? CustomerVisa  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'customer' ? CustomerGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (CustomerVisaArgs | CustomerVisaFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'customer' ? CustomerGetPayload<S['select'][P]> :  P extends keyof CustomerVisa ? CustomerVisa[P] : never
  } 
      : CustomerVisa


  type CustomerVisaCountArgs = Merge<
    Omit<CustomerVisaFindManyArgs, 'select' | 'include'> & {
      select?: CustomerVisaCountAggregateInputType | true
    }
  >

  export interface CustomerVisaDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one CustomerVisa that matches the filter.
     * @param {CustomerVisaFindUniqueArgs} args - Arguments to find a CustomerVisa
     * @example
     * // Get one CustomerVisa
     * const customerVisa = await prisma.customerVisa.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CustomerVisaFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CustomerVisaFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'CustomerVisa'> extends True ? Prisma__CustomerVisaClient<CustomerVisaGetPayload<T>> : Prisma__CustomerVisaClient<CustomerVisaGetPayload<T> | null, null>

    /**
     * Find one CustomerVisa that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CustomerVisaFindUniqueOrThrowArgs} args - Arguments to find a CustomerVisa
     * @example
     * // Get one CustomerVisa
     * const customerVisa = await prisma.customerVisa.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CustomerVisaFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, CustomerVisaFindUniqueOrThrowArgs>
    ): Prisma__CustomerVisaClient<CustomerVisaGetPayload<T>>

    /**
     * Find the first CustomerVisa that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerVisaFindFirstArgs} args - Arguments to find a CustomerVisa
     * @example
     * // Get one CustomerVisa
     * const customerVisa = await prisma.customerVisa.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CustomerVisaFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CustomerVisaFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'CustomerVisa'> extends True ? Prisma__CustomerVisaClient<CustomerVisaGetPayload<T>> : Prisma__CustomerVisaClient<CustomerVisaGetPayload<T> | null, null>

    /**
     * Find the first CustomerVisa that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerVisaFindFirstOrThrowArgs} args - Arguments to find a CustomerVisa
     * @example
     * // Get one CustomerVisa
     * const customerVisa = await prisma.customerVisa.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CustomerVisaFindFirstOrThrowArgs>(
      args?: SelectSubset<T, CustomerVisaFindFirstOrThrowArgs>
    ): Prisma__CustomerVisaClient<CustomerVisaGetPayload<T>>

    /**
     * Find zero or more CustomerVisas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerVisaFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CustomerVisas
     * const customerVisas = await prisma.customerVisa.findMany()
     * 
     * // Get first 10 CustomerVisas
     * const customerVisas = await prisma.customerVisa.findMany({ take: 10 })
     * 
     * // Only select the `visa_id`
     * const customerVisaWithVisa_idOnly = await prisma.customerVisa.findMany({ select: { visa_id: true } })
     * 
    **/
    findMany<T extends CustomerVisaFindManyArgs>(
      args?: SelectSubset<T, CustomerVisaFindManyArgs>
    ): PrismaPromise<Array<CustomerVisaGetPayload<T>>>

    /**
     * Create a CustomerVisa.
     * @param {CustomerVisaCreateArgs} args - Arguments to create a CustomerVisa.
     * @example
     * // Create one CustomerVisa
     * const CustomerVisa = await prisma.customerVisa.create({
     *   data: {
     *     // ... data to create a CustomerVisa
     *   }
     * })
     * 
    **/
    create<T extends CustomerVisaCreateArgs>(
      args: SelectSubset<T, CustomerVisaCreateArgs>
    ): Prisma__CustomerVisaClient<CustomerVisaGetPayload<T>>

    /**
     * Create many CustomerVisas.
     *     @param {CustomerVisaCreateManyArgs} args - Arguments to create many CustomerVisas.
     *     @example
     *     // Create many CustomerVisas
     *     const customerVisa = await prisma.customerVisa.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CustomerVisaCreateManyArgs>(
      args?: SelectSubset<T, CustomerVisaCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a CustomerVisa.
     * @param {CustomerVisaDeleteArgs} args - Arguments to delete one CustomerVisa.
     * @example
     * // Delete one CustomerVisa
     * const CustomerVisa = await prisma.customerVisa.delete({
     *   where: {
     *     // ... filter to delete one CustomerVisa
     *   }
     * })
     * 
    **/
    delete<T extends CustomerVisaDeleteArgs>(
      args: SelectSubset<T, CustomerVisaDeleteArgs>
    ): Prisma__CustomerVisaClient<CustomerVisaGetPayload<T>>

    /**
     * Update one CustomerVisa.
     * @param {CustomerVisaUpdateArgs} args - Arguments to update one CustomerVisa.
     * @example
     * // Update one CustomerVisa
     * const customerVisa = await prisma.customerVisa.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CustomerVisaUpdateArgs>(
      args: SelectSubset<T, CustomerVisaUpdateArgs>
    ): Prisma__CustomerVisaClient<CustomerVisaGetPayload<T>>

    /**
     * Delete zero or more CustomerVisas.
     * @param {CustomerVisaDeleteManyArgs} args - Arguments to filter CustomerVisas to delete.
     * @example
     * // Delete a few CustomerVisas
     * const { count } = await prisma.customerVisa.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CustomerVisaDeleteManyArgs>(
      args?: SelectSubset<T, CustomerVisaDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more CustomerVisas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerVisaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CustomerVisas
     * const customerVisa = await prisma.customerVisa.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CustomerVisaUpdateManyArgs>(
      args: SelectSubset<T, CustomerVisaUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one CustomerVisa.
     * @param {CustomerVisaUpsertArgs} args - Arguments to update or create a CustomerVisa.
     * @example
     * // Update or create a CustomerVisa
     * const customerVisa = await prisma.customerVisa.upsert({
     *   create: {
     *     // ... data to create a CustomerVisa
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CustomerVisa we want to update
     *   }
     * })
    **/
    upsert<T extends CustomerVisaUpsertArgs>(
      args: SelectSubset<T, CustomerVisaUpsertArgs>
    ): Prisma__CustomerVisaClient<CustomerVisaGetPayload<T>>

    /**
     * Count the number of CustomerVisas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerVisaCountArgs} args - Arguments to filter CustomerVisas to count.
     * @example
     * // Count the number of CustomerVisas
     * const count = await prisma.customerVisa.count({
     *   where: {
     *     // ... the filter for the CustomerVisas we want to count
     *   }
     * })
    **/
    count<T extends CustomerVisaCountArgs>(
      args?: Subset<T, CustomerVisaCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomerVisaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CustomerVisa.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerVisaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomerVisaAggregateArgs>(args: Subset<T, CustomerVisaAggregateArgs>): PrismaPromise<GetCustomerVisaAggregateType<T>>

    /**
     * Group by CustomerVisa.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerVisaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CustomerVisaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CustomerVisaGroupByArgs['orderBy'] }
        : { orderBy?: CustomerVisaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CustomerVisaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomerVisaGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for CustomerVisa.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CustomerVisaClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    customer<T extends CustomerArgs= {}>(args?: Subset<T, CustomerArgs>): Prisma__CustomerClient<CustomerGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * CustomerVisa base type for findUnique actions
   */
  export type CustomerVisaFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the CustomerVisa
     * 
    **/
    select?: CustomerVisaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CustomerVisaInclude | null
    /**
     * Filter, which CustomerVisa to fetch.
     * 
    **/
    where: CustomerVisaWhereUniqueInput
  }

  /**
   * CustomerVisa: findUnique
   */
  export interface CustomerVisaFindUniqueArgs extends CustomerVisaFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * CustomerVisa findUniqueOrThrow
   */
  export type CustomerVisaFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the CustomerVisa
     * 
    **/
    select?: CustomerVisaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CustomerVisaInclude | null
    /**
     * Filter, which CustomerVisa to fetch.
     * 
    **/
    where: CustomerVisaWhereUniqueInput
  }


  /**
   * CustomerVisa base type for findFirst actions
   */
  export type CustomerVisaFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the CustomerVisa
     * 
    **/
    select?: CustomerVisaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CustomerVisaInclude | null
    /**
     * Filter, which CustomerVisa to fetch.
     * 
    **/
    where?: CustomerVisaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerVisas to fetch.
     * 
    **/
    orderBy?: Enumerable<CustomerVisaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CustomerVisas.
     * 
    **/
    cursor?: CustomerVisaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerVisas from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerVisas.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CustomerVisas.
     * 
    **/
    distinct?: Enumerable<CustomerVisaScalarFieldEnum>
  }

  /**
   * CustomerVisa: findFirst
   */
  export interface CustomerVisaFindFirstArgs extends CustomerVisaFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * CustomerVisa findFirstOrThrow
   */
  export type CustomerVisaFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the CustomerVisa
     * 
    **/
    select?: CustomerVisaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CustomerVisaInclude | null
    /**
     * Filter, which CustomerVisa to fetch.
     * 
    **/
    where?: CustomerVisaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerVisas to fetch.
     * 
    **/
    orderBy?: Enumerable<CustomerVisaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CustomerVisas.
     * 
    **/
    cursor?: CustomerVisaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerVisas from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerVisas.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CustomerVisas.
     * 
    **/
    distinct?: Enumerable<CustomerVisaScalarFieldEnum>
  }


  /**
   * CustomerVisa findMany
   */
  export type CustomerVisaFindManyArgs = {
    /**
     * Select specific fields to fetch from the CustomerVisa
     * 
    **/
    select?: CustomerVisaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CustomerVisaInclude | null
    /**
     * Filter, which CustomerVisas to fetch.
     * 
    **/
    where?: CustomerVisaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerVisas to fetch.
     * 
    **/
    orderBy?: Enumerable<CustomerVisaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CustomerVisas.
     * 
    **/
    cursor?: CustomerVisaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerVisas from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerVisas.
     * 
    **/
    skip?: number
    distinct?: Enumerable<CustomerVisaScalarFieldEnum>
  }


  /**
   * CustomerVisa create
   */
  export type CustomerVisaCreateArgs = {
    /**
     * Select specific fields to fetch from the CustomerVisa
     * 
    **/
    select?: CustomerVisaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CustomerVisaInclude | null
    /**
     * The data needed to create a CustomerVisa.
     * 
    **/
    data: XOR<CustomerVisaCreateInput, CustomerVisaUncheckedCreateInput>
  }


  /**
   * CustomerVisa createMany
   */
  export type CustomerVisaCreateManyArgs = {
    /**
     * The data used to create many CustomerVisas.
     * 
    **/
    data: Enumerable<CustomerVisaCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * CustomerVisa update
   */
  export type CustomerVisaUpdateArgs = {
    /**
     * Select specific fields to fetch from the CustomerVisa
     * 
    **/
    select?: CustomerVisaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CustomerVisaInclude | null
    /**
     * The data needed to update a CustomerVisa.
     * 
    **/
    data: XOR<CustomerVisaUpdateInput, CustomerVisaUncheckedUpdateInput>
    /**
     * Choose, which CustomerVisa to update.
     * 
    **/
    where: CustomerVisaWhereUniqueInput
  }


  /**
   * CustomerVisa updateMany
   */
  export type CustomerVisaUpdateManyArgs = {
    /**
     * The data used to update CustomerVisas.
     * 
    **/
    data: XOR<CustomerVisaUpdateManyMutationInput, CustomerVisaUncheckedUpdateManyInput>
    /**
     * Filter which CustomerVisas to update
     * 
    **/
    where?: CustomerVisaWhereInput
  }


  /**
   * CustomerVisa upsert
   */
  export type CustomerVisaUpsertArgs = {
    /**
     * Select specific fields to fetch from the CustomerVisa
     * 
    **/
    select?: CustomerVisaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CustomerVisaInclude | null
    /**
     * The filter to search for the CustomerVisa to update in case it exists.
     * 
    **/
    where: CustomerVisaWhereUniqueInput
    /**
     * In case the CustomerVisa found by the `where` argument doesn't exist, create a new CustomerVisa with this data.
     * 
    **/
    create: XOR<CustomerVisaCreateInput, CustomerVisaUncheckedCreateInput>
    /**
     * In case the CustomerVisa was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<CustomerVisaUpdateInput, CustomerVisaUncheckedUpdateInput>
  }


  /**
   * CustomerVisa delete
   */
  export type CustomerVisaDeleteArgs = {
    /**
     * Select specific fields to fetch from the CustomerVisa
     * 
    **/
    select?: CustomerVisaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CustomerVisaInclude | null
    /**
     * Filter which CustomerVisa to delete.
     * 
    **/
    where: CustomerVisaWhereUniqueInput
  }


  /**
   * CustomerVisa deleteMany
   */
  export type CustomerVisaDeleteManyArgs = {
    /**
     * Filter which CustomerVisas to delete
     * 
    **/
    where?: CustomerVisaWhereInput
  }


  /**
   * CustomerVisa without action
   */
  export type CustomerVisaArgs = {
    /**
     * Select specific fields to fetch from the CustomerVisa
     * 
    **/
    select?: CustomerVisaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CustomerVisaInclude | null
  }



  /**
   * Model CustomerWorkHistory
   */


  export type AggregateCustomerWorkHistory = {
    _count: CustomerWorkHistoryCountAggregateOutputType | null
    _avg: CustomerWorkHistoryAvgAggregateOutputType | null
    _sum: CustomerWorkHistorySumAggregateOutputType | null
    _min: CustomerWorkHistoryMinAggregateOutputType | null
    _max: CustomerWorkHistoryMaxAggregateOutputType | null
  }

  export type CustomerWorkHistoryAvgAggregateOutputType = {
    working_month: number | null
  }

  export type CustomerWorkHistorySumAggregateOutputType = {
    working_month: number | null
  }

  export type CustomerWorkHistoryMinAggregateOutputType = {
    workhistory_id: string | null
    customer_id: string | null
    company_id: string | null
    position: JobPosition | null
    enter_date: Date | null
    leave_date: Date | null
    working_month: number | null
    is_current: boolean | null
    duties: string | null
    created_at: Date | null
    updated_at: Date | null
    created_by: string | null
    updated_by: string | null
  }

  export type CustomerWorkHistoryMaxAggregateOutputType = {
    workhistory_id: string | null
    customer_id: string | null
    company_id: string | null
    position: JobPosition | null
    enter_date: Date | null
    leave_date: Date | null
    working_month: number | null
    is_current: boolean | null
    duties: string | null
    created_at: Date | null
    updated_at: Date | null
    created_by: string | null
    updated_by: string | null
  }

  export type CustomerWorkHistoryCountAggregateOutputType = {
    workhistory_id: number
    customer_id: number
    company_id: number
    company_info: number
    occupation: number
    industry: number
    position: number
    enter_date: number
    leave_date: number
    working_month: number
    is_current: number
    duties: number
    created_at: number
    updated_at: number
    created_by: number
    updated_by: number
    _all: number
  }


  export type CustomerWorkHistoryAvgAggregateInputType = {
    working_month?: true
  }

  export type CustomerWorkHistorySumAggregateInputType = {
    working_month?: true
  }

  export type CustomerWorkHistoryMinAggregateInputType = {
    workhistory_id?: true
    customer_id?: true
    company_id?: true
    position?: true
    enter_date?: true
    leave_date?: true
    working_month?: true
    is_current?: true
    duties?: true
    created_at?: true
    updated_at?: true
    created_by?: true
    updated_by?: true
  }

  export type CustomerWorkHistoryMaxAggregateInputType = {
    workhistory_id?: true
    customer_id?: true
    company_id?: true
    position?: true
    enter_date?: true
    leave_date?: true
    working_month?: true
    is_current?: true
    duties?: true
    created_at?: true
    updated_at?: true
    created_by?: true
    updated_by?: true
  }

  export type CustomerWorkHistoryCountAggregateInputType = {
    workhistory_id?: true
    customer_id?: true
    company_id?: true
    company_info?: true
    occupation?: true
    industry?: true
    position?: true
    enter_date?: true
    leave_date?: true
    working_month?: true
    is_current?: true
    duties?: true
    created_at?: true
    updated_at?: true
    created_by?: true
    updated_by?: true
    _all?: true
  }

  export type CustomerWorkHistoryAggregateArgs = {
    /**
     * Filter which CustomerWorkHistory to aggregate.
     * 
    **/
    where?: CustomerWorkHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerWorkHistories to fetch.
     * 
    **/
    orderBy?: Enumerable<CustomerWorkHistoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: CustomerWorkHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerWorkHistories from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerWorkHistories.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CustomerWorkHistories
    **/
    _count?: true | CustomerWorkHistoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CustomerWorkHistoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CustomerWorkHistorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomerWorkHistoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomerWorkHistoryMaxAggregateInputType
  }

  export type GetCustomerWorkHistoryAggregateType<T extends CustomerWorkHistoryAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomerWorkHistory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomerWorkHistory[P]>
      : GetScalarType<T[P], AggregateCustomerWorkHistory[P]>
  }




  export type CustomerWorkHistoryGroupByArgs = {
    where?: CustomerWorkHistoryWhereInput
    orderBy?: Enumerable<CustomerWorkHistoryOrderByWithAggregationInput>
    by: Array<CustomerWorkHistoryScalarFieldEnum>
    having?: CustomerWorkHistoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomerWorkHistoryCountAggregateInputType | true
    _avg?: CustomerWorkHistoryAvgAggregateInputType
    _sum?: CustomerWorkHistorySumAggregateInputType
    _min?: CustomerWorkHistoryMinAggregateInputType
    _max?: CustomerWorkHistoryMaxAggregateInputType
  }


  export type CustomerWorkHistoryGroupByOutputType = {
    workhistory_id: string
    customer_id: string
    company_id: string | null
    company_info: JsonValue | null
    occupation: JsonValue | null
    industry: JsonValue | null
    position: JobPosition | null
    enter_date: Date | null
    leave_date: Date | null
    working_month: number | null
    is_current: boolean | null
    duties: string | null
    created_at: Date
    updated_at: Date
    created_by: string | null
    updated_by: string | null
    _count: CustomerWorkHistoryCountAggregateOutputType | null
    _avg: CustomerWorkHistoryAvgAggregateOutputType | null
    _sum: CustomerWorkHistorySumAggregateOutputType | null
    _min: CustomerWorkHistoryMinAggregateOutputType | null
    _max: CustomerWorkHistoryMaxAggregateOutputType | null
  }

  type GetCustomerWorkHistoryGroupByPayload<T extends CustomerWorkHistoryGroupByArgs> = PrismaPromise<
    Array<
      PickArray<CustomerWorkHistoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomerWorkHistoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomerWorkHistoryGroupByOutputType[P]>
            : GetScalarType<T[P], CustomerWorkHistoryGroupByOutputType[P]>
        }
      >
    >


  export type CustomerWorkHistorySelect = {
    workhistory_id?: boolean
    customer_id?: boolean
    customer?: boolean | CustomerArgs
    company_id?: boolean
    company_info?: boolean
    occupation?: boolean
    industry?: boolean
    position?: boolean
    enter_date?: boolean
    leave_date?: boolean
    working_month?: boolean
    is_current?: boolean
    duties?: boolean
    created_at?: boolean
    updated_at?: boolean
    created_by?: boolean
    updated_by?: boolean
  }


  export type CustomerWorkHistoryInclude = {
    customer?: boolean | CustomerArgs
  } 

  export type CustomerWorkHistoryGetPayload<S extends boolean | null | undefined | CustomerWorkHistoryArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? CustomerWorkHistory :
    S extends undefined ? never :
    S extends { include: any } & (CustomerWorkHistoryArgs | CustomerWorkHistoryFindManyArgs)
    ? CustomerWorkHistory  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'customer' ? CustomerGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (CustomerWorkHistoryArgs | CustomerWorkHistoryFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'customer' ? CustomerGetPayload<S['select'][P]> :  P extends keyof CustomerWorkHistory ? CustomerWorkHistory[P] : never
  } 
      : CustomerWorkHistory


  type CustomerWorkHistoryCountArgs = Merge<
    Omit<CustomerWorkHistoryFindManyArgs, 'select' | 'include'> & {
      select?: CustomerWorkHistoryCountAggregateInputType | true
    }
  >

  export interface CustomerWorkHistoryDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one CustomerWorkHistory that matches the filter.
     * @param {CustomerWorkHistoryFindUniqueArgs} args - Arguments to find a CustomerWorkHistory
     * @example
     * // Get one CustomerWorkHistory
     * const customerWorkHistory = await prisma.customerWorkHistory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CustomerWorkHistoryFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CustomerWorkHistoryFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'CustomerWorkHistory'> extends True ? Prisma__CustomerWorkHistoryClient<CustomerWorkHistoryGetPayload<T>> : Prisma__CustomerWorkHistoryClient<CustomerWorkHistoryGetPayload<T> | null, null>

    /**
     * Find one CustomerWorkHistory that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CustomerWorkHistoryFindUniqueOrThrowArgs} args - Arguments to find a CustomerWorkHistory
     * @example
     * // Get one CustomerWorkHistory
     * const customerWorkHistory = await prisma.customerWorkHistory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CustomerWorkHistoryFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, CustomerWorkHistoryFindUniqueOrThrowArgs>
    ): Prisma__CustomerWorkHistoryClient<CustomerWorkHistoryGetPayload<T>>

    /**
     * Find the first CustomerWorkHistory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerWorkHistoryFindFirstArgs} args - Arguments to find a CustomerWorkHistory
     * @example
     * // Get one CustomerWorkHistory
     * const customerWorkHistory = await prisma.customerWorkHistory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CustomerWorkHistoryFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CustomerWorkHistoryFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'CustomerWorkHistory'> extends True ? Prisma__CustomerWorkHistoryClient<CustomerWorkHistoryGetPayload<T>> : Prisma__CustomerWorkHistoryClient<CustomerWorkHistoryGetPayload<T> | null, null>

    /**
     * Find the first CustomerWorkHistory that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerWorkHistoryFindFirstOrThrowArgs} args - Arguments to find a CustomerWorkHistory
     * @example
     * // Get one CustomerWorkHistory
     * const customerWorkHistory = await prisma.customerWorkHistory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CustomerWorkHistoryFindFirstOrThrowArgs>(
      args?: SelectSubset<T, CustomerWorkHistoryFindFirstOrThrowArgs>
    ): Prisma__CustomerWorkHistoryClient<CustomerWorkHistoryGetPayload<T>>

    /**
     * Find zero or more CustomerWorkHistories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerWorkHistoryFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CustomerWorkHistories
     * const customerWorkHistories = await prisma.customerWorkHistory.findMany()
     * 
     * // Get first 10 CustomerWorkHistories
     * const customerWorkHistories = await prisma.customerWorkHistory.findMany({ take: 10 })
     * 
     * // Only select the `workhistory_id`
     * const customerWorkHistoryWithWorkhistory_idOnly = await prisma.customerWorkHistory.findMany({ select: { workhistory_id: true } })
     * 
    **/
    findMany<T extends CustomerWorkHistoryFindManyArgs>(
      args?: SelectSubset<T, CustomerWorkHistoryFindManyArgs>
    ): PrismaPromise<Array<CustomerWorkHistoryGetPayload<T>>>

    /**
     * Create a CustomerWorkHistory.
     * @param {CustomerWorkHistoryCreateArgs} args - Arguments to create a CustomerWorkHistory.
     * @example
     * // Create one CustomerWorkHistory
     * const CustomerWorkHistory = await prisma.customerWorkHistory.create({
     *   data: {
     *     // ... data to create a CustomerWorkHistory
     *   }
     * })
     * 
    **/
    create<T extends CustomerWorkHistoryCreateArgs>(
      args: SelectSubset<T, CustomerWorkHistoryCreateArgs>
    ): Prisma__CustomerWorkHistoryClient<CustomerWorkHistoryGetPayload<T>>

    /**
     * Create many CustomerWorkHistories.
     *     @param {CustomerWorkHistoryCreateManyArgs} args - Arguments to create many CustomerWorkHistories.
     *     @example
     *     // Create many CustomerWorkHistories
     *     const customerWorkHistory = await prisma.customerWorkHistory.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CustomerWorkHistoryCreateManyArgs>(
      args?: SelectSubset<T, CustomerWorkHistoryCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a CustomerWorkHistory.
     * @param {CustomerWorkHistoryDeleteArgs} args - Arguments to delete one CustomerWorkHistory.
     * @example
     * // Delete one CustomerWorkHistory
     * const CustomerWorkHistory = await prisma.customerWorkHistory.delete({
     *   where: {
     *     // ... filter to delete one CustomerWorkHistory
     *   }
     * })
     * 
    **/
    delete<T extends CustomerWorkHistoryDeleteArgs>(
      args: SelectSubset<T, CustomerWorkHistoryDeleteArgs>
    ): Prisma__CustomerWorkHistoryClient<CustomerWorkHistoryGetPayload<T>>

    /**
     * Update one CustomerWorkHistory.
     * @param {CustomerWorkHistoryUpdateArgs} args - Arguments to update one CustomerWorkHistory.
     * @example
     * // Update one CustomerWorkHistory
     * const customerWorkHistory = await prisma.customerWorkHistory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CustomerWorkHistoryUpdateArgs>(
      args: SelectSubset<T, CustomerWorkHistoryUpdateArgs>
    ): Prisma__CustomerWorkHistoryClient<CustomerWorkHistoryGetPayload<T>>

    /**
     * Delete zero or more CustomerWorkHistories.
     * @param {CustomerWorkHistoryDeleteManyArgs} args - Arguments to filter CustomerWorkHistories to delete.
     * @example
     * // Delete a few CustomerWorkHistories
     * const { count } = await prisma.customerWorkHistory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CustomerWorkHistoryDeleteManyArgs>(
      args?: SelectSubset<T, CustomerWorkHistoryDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more CustomerWorkHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerWorkHistoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CustomerWorkHistories
     * const customerWorkHistory = await prisma.customerWorkHistory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CustomerWorkHistoryUpdateManyArgs>(
      args: SelectSubset<T, CustomerWorkHistoryUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one CustomerWorkHistory.
     * @param {CustomerWorkHistoryUpsertArgs} args - Arguments to update or create a CustomerWorkHistory.
     * @example
     * // Update or create a CustomerWorkHistory
     * const customerWorkHistory = await prisma.customerWorkHistory.upsert({
     *   create: {
     *     // ... data to create a CustomerWorkHistory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CustomerWorkHistory we want to update
     *   }
     * })
    **/
    upsert<T extends CustomerWorkHistoryUpsertArgs>(
      args: SelectSubset<T, CustomerWorkHistoryUpsertArgs>
    ): Prisma__CustomerWorkHistoryClient<CustomerWorkHistoryGetPayload<T>>

    /**
     * Count the number of CustomerWorkHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerWorkHistoryCountArgs} args - Arguments to filter CustomerWorkHistories to count.
     * @example
     * // Count the number of CustomerWorkHistories
     * const count = await prisma.customerWorkHistory.count({
     *   where: {
     *     // ... the filter for the CustomerWorkHistories we want to count
     *   }
     * })
    **/
    count<T extends CustomerWorkHistoryCountArgs>(
      args?: Subset<T, CustomerWorkHistoryCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomerWorkHistoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CustomerWorkHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerWorkHistoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomerWorkHistoryAggregateArgs>(args: Subset<T, CustomerWorkHistoryAggregateArgs>): PrismaPromise<GetCustomerWorkHistoryAggregateType<T>>

    /**
     * Group by CustomerWorkHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerWorkHistoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CustomerWorkHistoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CustomerWorkHistoryGroupByArgs['orderBy'] }
        : { orderBy?: CustomerWorkHistoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CustomerWorkHistoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomerWorkHistoryGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for CustomerWorkHistory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CustomerWorkHistoryClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    customer<T extends CustomerArgs= {}>(args?: Subset<T, CustomerArgs>): Prisma__CustomerClient<CustomerGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * CustomerWorkHistory base type for findUnique actions
   */
  export type CustomerWorkHistoryFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the CustomerWorkHistory
     * 
    **/
    select?: CustomerWorkHistorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CustomerWorkHistoryInclude | null
    /**
     * Filter, which CustomerWorkHistory to fetch.
     * 
    **/
    where: CustomerWorkHistoryWhereUniqueInput
  }

  /**
   * CustomerWorkHistory: findUnique
   */
  export interface CustomerWorkHistoryFindUniqueArgs extends CustomerWorkHistoryFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * CustomerWorkHistory findUniqueOrThrow
   */
  export type CustomerWorkHistoryFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the CustomerWorkHistory
     * 
    **/
    select?: CustomerWorkHistorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CustomerWorkHistoryInclude | null
    /**
     * Filter, which CustomerWorkHistory to fetch.
     * 
    **/
    where: CustomerWorkHistoryWhereUniqueInput
  }


  /**
   * CustomerWorkHistory base type for findFirst actions
   */
  export type CustomerWorkHistoryFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the CustomerWorkHistory
     * 
    **/
    select?: CustomerWorkHistorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CustomerWorkHistoryInclude | null
    /**
     * Filter, which CustomerWorkHistory to fetch.
     * 
    **/
    where?: CustomerWorkHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerWorkHistories to fetch.
     * 
    **/
    orderBy?: Enumerable<CustomerWorkHistoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CustomerWorkHistories.
     * 
    **/
    cursor?: CustomerWorkHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerWorkHistories from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerWorkHistories.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CustomerWorkHistories.
     * 
    **/
    distinct?: Enumerable<CustomerWorkHistoryScalarFieldEnum>
  }

  /**
   * CustomerWorkHistory: findFirst
   */
  export interface CustomerWorkHistoryFindFirstArgs extends CustomerWorkHistoryFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * CustomerWorkHistory findFirstOrThrow
   */
  export type CustomerWorkHistoryFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the CustomerWorkHistory
     * 
    **/
    select?: CustomerWorkHistorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CustomerWorkHistoryInclude | null
    /**
     * Filter, which CustomerWorkHistory to fetch.
     * 
    **/
    where?: CustomerWorkHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerWorkHistories to fetch.
     * 
    **/
    orderBy?: Enumerable<CustomerWorkHistoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CustomerWorkHistories.
     * 
    **/
    cursor?: CustomerWorkHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerWorkHistories from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerWorkHistories.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CustomerWorkHistories.
     * 
    **/
    distinct?: Enumerable<CustomerWorkHistoryScalarFieldEnum>
  }


  /**
   * CustomerWorkHistory findMany
   */
  export type CustomerWorkHistoryFindManyArgs = {
    /**
     * Select specific fields to fetch from the CustomerWorkHistory
     * 
    **/
    select?: CustomerWorkHistorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CustomerWorkHistoryInclude | null
    /**
     * Filter, which CustomerWorkHistories to fetch.
     * 
    **/
    where?: CustomerWorkHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerWorkHistories to fetch.
     * 
    **/
    orderBy?: Enumerable<CustomerWorkHistoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CustomerWorkHistories.
     * 
    **/
    cursor?: CustomerWorkHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerWorkHistories from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerWorkHistories.
     * 
    **/
    skip?: number
    distinct?: Enumerable<CustomerWorkHistoryScalarFieldEnum>
  }


  /**
   * CustomerWorkHistory create
   */
  export type CustomerWorkHistoryCreateArgs = {
    /**
     * Select specific fields to fetch from the CustomerWorkHistory
     * 
    **/
    select?: CustomerWorkHistorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CustomerWorkHistoryInclude | null
    /**
     * The data needed to create a CustomerWorkHistory.
     * 
    **/
    data: XOR<CustomerWorkHistoryCreateInput, CustomerWorkHistoryUncheckedCreateInput>
  }


  /**
   * CustomerWorkHistory createMany
   */
  export type CustomerWorkHistoryCreateManyArgs = {
    /**
     * The data used to create many CustomerWorkHistories.
     * 
    **/
    data: Enumerable<CustomerWorkHistoryCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * CustomerWorkHistory update
   */
  export type CustomerWorkHistoryUpdateArgs = {
    /**
     * Select specific fields to fetch from the CustomerWorkHistory
     * 
    **/
    select?: CustomerWorkHistorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CustomerWorkHistoryInclude | null
    /**
     * The data needed to update a CustomerWorkHistory.
     * 
    **/
    data: XOR<CustomerWorkHistoryUpdateInput, CustomerWorkHistoryUncheckedUpdateInput>
    /**
     * Choose, which CustomerWorkHistory to update.
     * 
    **/
    where: CustomerWorkHistoryWhereUniqueInput
  }


  /**
   * CustomerWorkHistory updateMany
   */
  export type CustomerWorkHistoryUpdateManyArgs = {
    /**
     * The data used to update CustomerWorkHistories.
     * 
    **/
    data: XOR<CustomerWorkHistoryUpdateManyMutationInput, CustomerWorkHistoryUncheckedUpdateManyInput>
    /**
     * Filter which CustomerWorkHistories to update
     * 
    **/
    where?: CustomerWorkHistoryWhereInput
  }


  /**
   * CustomerWorkHistory upsert
   */
  export type CustomerWorkHistoryUpsertArgs = {
    /**
     * Select specific fields to fetch from the CustomerWorkHistory
     * 
    **/
    select?: CustomerWorkHistorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CustomerWorkHistoryInclude | null
    /**
     * The filter to search for the CustomerWorkHistory to update in case it exists.
     * 
    **/
    where: CustomerWorkHistoryWhereUniqueInput
    /**
     * In case the CustomerWorkHistory found by the `where` argument doesn't exist, create a new CustomerWorkHistory with this data.
     * 
    **/
    create: XOR<CustomerWorkHistoryCreateInput, CustomerWorkHistoryUncheckedCreateInput>
    /**
     * In case the CustomerWorkHistory was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<CustomerWorkHistoryUpdateInput, CustomerWorkHistoryUncheckedUpdateInput>
  }


  /**
   * CustomerWorkHistory delete
   */
  export type CustomerWorkHistoryDeleteArgs = {
    /**
     * Select specific fields to fetch from the CustomerWorkHistory
     * 
    **/
    select?: CustomerWorkHistorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CustomerWorkHistoryInclude | null
    /**
     * Filter which CustomerWorkHistory to delete.
     * 
    **/
    where: CustomerWorkHistoryWhereUniqueInput
  }


  /**
   * CustomerWorkHistory deleteMany
   */
  export type CustomerWorkHistoryDeleteManyArgs = {
    /**
     * Filter which CustomerWorkHistories to delete
     * 
    **/
    where?: CustomerWorkHistoryWhereInput
  }


  /**
   * CustomerWorkHistory without action
   */
  export type CustomerWorkHistoryArgs = {
    /**
     * Select specific fields to fetch from the CustomerWorkHistory
     * 
    **/
    select?: CustomerWorkHistorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CustomerWorkHistoryInclude | null
  }



  /**
   * Model Dictionary
   */


  export type AggregateDictionary = {
    _count: DictionaryCountAggregateOutputType | null
    _avg: DictionaryAvgAggregateOutputType | null
    _sum: DictionarySumAggregateOutputType | null
    _min: DictionaryMinAggregateOutputType | null
    _max: DictionaryMaxAggregateOutputType | null
  }

  export type DictionaryAvgAggregateOutputType = {
    dictionary_id: number | null
  }

  export type DictionarySumAggregateOutputType = {
    dictionary_id: number | null
  }

  export type DictionaryMinAggregateOutputType = {
    dictionaries_id: string | null
    dictionary_id: number | null
    language_code: string | null
    dic_value: string | null
    created_at: Date | null
  }

  export type DictionaryMaxAggregateOutputType = {
    dictionaries_id: string | null
    dictionary_id: number | null
    language_code: string | null
    dic_value: string | null
    created_at: Date | null
  }

  export type DictionaryCountAggregateOutputType = {
    dictionaries_id: number
    dictionary_id: number
    language_code: number
    dic_value: number
    created_at: number
    _all: number
  }


  export type DictionaryAvgAggregateInputType = {
    dictionary_id?: true
  }

  export type DictionarySumAggregateInputType = {
    dictionary_id?: true
  }

  export type DictionaryMinAggregateInputType = {
    dictionaries_id?: true
    dictionary_id?: true
    language_code?: true
    dic_value?: true
    created_at?: true
  }

  export type DictionaryMaxAggregateInputType = {
    dictionaries_id?: true
    dictionary_id?: true
    language_code?: true
    dic_value?: true
    created_at?: true
  }

  export type DictionaryCountAggregateInputType = {
    dictionaries_id?: true
    dictionary_id?: true
    language_code?: true
    dic_value?: true
    created_at?: true
    _all?: true
  }

  export type DictionaryAggregateArgs = {
    /**
     * Filter which Dictionary to aggregate.
     * 
    **/
    where?: DictionaryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Dictionaries to fetch.
     * 
    **/
    orderBy?: Enumerable<DictionaryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: DictionaryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Dictionaries from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Dictionaries.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Dictionaries
    **/
    _count?: true | DictionaryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DictionaryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DictionarySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DictionaryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DictionaryMaxAggregateInputType
  }

  export type GetDictionaryAggregateType<T extends DictionaryAggregateArgs> = {
        [P in keyof T & keyof AggregateDictionary]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDictionary[P]>
      : GetScalarType<T[P], AggregateDictionary[P]>
  }




  export type DictionaryGroupByArgs = {
    where?: DictionaryWhereInput
    orderBy?: Enumerable<DictionaryOrderByWithAggregationInput>
    by: Array<DictionaryScalarFieldEnum>
    having?: DictionaryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DictionaryCountAggregateInputType | true
    _avg?: DictionaryAvgAggregateInputType
    _sum?: DictionarySumAggregateInputType
    _min?: DictionaryMinAggregateInputType
    _max?: DictionaryMaxAggregateInputType
  }


  export type DictionaryGroupByOutputType = {
    dictionaries_id: string
    dictionary_id: number
    language_code: string
    dic_value: string
    created_at: Date
    _count: DictionaryCountAggregateOutputType | null
    _avg: DictionaryAvgAggregateOutputType | null
    _sum: DictionarySumAggregateOutputType | null
    _min: DictionaryMinAggregateOutputType | null
    _max: DictionaryMaxAggregateOutputType | null
  }

  type GetDictionaryGroupByPayload<T extends DictionaryGroupByArgs> = PrismaPromise<
    Array<
      PickArray<DictionaryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DictionaryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DictionaryGroupByOutputType[P]>
            : GetScalarType<T[P], DictionaryGroupByOutputType[P]>
        }
      >
    >


  export type DictionarySelect = {
    dictionaries_id?: boolean
    dictionary_id?: boolean
    language_code?: boolean
    dic_value?: boolean
    created_at?: boolean
    reference_listitems?: boolean | ReferenceListItemsFindManyArgs
    _count?: boolean | DictionaryCountOutputTypeArgs
  }


  export type DictionaryInclude = {
    reference_listitems?: boolean | ReferenceListItemsFindManyArgs
    _count?: boolean | DictionaryCountOutputTypeArgs
  } 

  export type DictionaryGetPayload<S extends boolean | null | undefined | DictionaryArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Dictionary :
    S extends undefined ? never :
    S extends { include: any } & (DictionaryArgs | DictionaryFindManyArgs)
    ? Dictionary  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'reference_listitems' ? Array < ReferenceListItemsGetPayload<S['include'][P]>>  :
        P extends '_count' ? DictionaryCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (DictionaryArgs | DictionaryFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'reference_listitems' ? Array < ReferenceListItemsGetPayload<S['select'][P]>>  :
        P extends '_count' ? DictionaryCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Dictionary ? Dictionary[P] : never
  } 
      : Dictionary


  type DictionaryCountArgs = Merge<
    Omit<DictionaryFindManyArgs, 'select' | 'include'> & {
      select?: DictionaryCountAggregateInputType | true
    }
  >

  export interface DictionaryDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Dictionary that matches the filter.
     * @param {DictionaryFindUniqueArgs} args - Arguments to find a Dictionary
     * @example
     * // Get one Dictionary
     * const dictionary = await prisma.dictionary.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends DictionaryFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, DictionaryFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Dictionary'> extends True ? Prisma__DictionaryClient<DictionaryGetPayload<T>> : Prisma__DictionaryClient<DictionaryGetPayload<T> | null, null>

    /**
     * Find one Dictionary that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {DictionaryFindUniqueOrThrowArgs} args - Arguments to find a Dictionary
     * @example
     * // Get one Dictionary
     * const dictionary = await prisma.dictionary.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends DictionaryFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, DictionaryFindUniqueOrThrowArgs>
    ): Prisma__DictionaryClient<DictionaryGetPayload<T>>

    /**
     * Find the first Dictionary that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DictionaryFindFirstArgs} args - Arguments to find a Dictionary
     * @example
     * // Get one Dictionary
     * const dictionary = await prisma.dictionary.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends DictionaryFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, DictionaryFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Dictionary'> extends True ? Prisma__DictionaryClient<DictionaryGetPayload<T>> : Prisma__DictionaryClient<DictionaryGetPayload<T> | null, null>

    /**
     * Find the first Dictionary that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DictionaryFindFirstOrThrowArgs} args - Arguments to find a Dictionary
     * @example
     * // Get one Dictionary
     * const dictionary = await prisma.dictionary.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends DictionaryFindFirstOrThrowArgs>(
      args?: SelectSubset<T, DictionaryFindFirstOrThrowArgs>
    ): Prisma__DictionaryClient<DictionaryGetPayload<T>>

    /**
     * Find zero or more Dictionaries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DictionaryFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Dictionaries
     * const dictionaries = await prisma.dictionary.findMany()
     * 
     * // Get first 10 Dictionaries
     * const dictionaries = await prisma.dictionary.findMany({ take: 10 })
     * 
     * // Only select the `dictionaries_id`
     * const dictionaryWithDictionaries_idOnly = await prisma.dictionary.findMany({ select: { dictionaries_id: true } })
     * 
    **/
    findMany<T extends DictionaryFindManyArgs>(
      args?: SelectSubset<T, DictionaryFindManyArgs>
    ): PrismaPromise<Array<DictionaryGetPayload<T>>>

    /**
     * Create a Dictionary.
     * @param {DictionaryCreateArgs} args - Arguments to create a Dictionary.
     * @example
     * // Create one Dictionary
     * const Dictionary = await prisma.dictionary.create({
     *   data: {
     *     // ... data to create a Dictionary
     *   }
     * })
     * 
    **/
    create<T extends DictionaryCreateArgs>(
      args: SelectSubset<T, DictionaryCreateArgs>
    ): Prisma__DictionaryClient<DictionaryGetPayload<T>>

    /**
     * Create many Dictionaries.
     *     @param {DictionaryCreateManyArgs} args - Arguments to create many Dictionaries.
     *     @example
     *     // Create many Dictionaries
     *     const dictionary = await prisma.dictionary.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends DictionaryCreateManyArgs>(
      args?: SelectSubset<T, DictionaryCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Dictionary.
     * @param {DictionaryDeleteArgs} args - Arguments to delete one Dictionary.
     * @example
     * // Delete one Dictionary
     * const Dictionary = await prisma.dictionary.delete({
     *   where: {
     *     // ... filter to delete one Dictionary
     *   }
     * })
     * 
    **/
    delete<T extends DictionaryDeleteArgs>(
      args: SelectSubset<T, DictionaryDeleteArgs>
    ): Prisma__DictionaryClient<DictionaryGetPayload<T>>

    /**
     * Update one Dictionary.
     * @param {DictionaryUpdateArgs} args - Arguments to update one Dictionary.
     * @example
     * // Update one Dictionary
     * const dictionary = await prisma.dictionary.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends DictionaryUpdateArgs>(
      args: SelectSubset<T, DictionaryUpdateArgs>
    ): Prisma__DictionaryClient<DictionaryGetPayload<T>>

    /**
     * Delete zero or more Dictionaries.
     * @param {DictionaryDeleteManyArgs} args - Arguments to filter Dictionaries to delete.
     * @example
     * // Delete a few Dictionaries
     * const { count } = await prisma.dictionary.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends DictionaryDeleteManyArgs>(
      args?: SelectSubset<T, DictionaryDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Dictionaries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DictionaryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Dictionaries
     * const dictionary = await prisma.dictionary.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends DictionaryUpdateManyArgs>(
      args: SelectSubset<T, DictionaryUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Dictionary.
     * @param {DictionaryUpsertArgs} args - Arguments to update or create a Dictionary.
     * @example
     * // Update or create a Dictionary
     * const dictionary = await prisma.dictionary.upsert({
     *   create: {
     *     // ... data to create a Dictionary
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Dictionary we want to update
     *   }
     * })
    **/
    upsert<T extends DictionaryUpsertArgs>(
      args: SelectSubset<T, DictionaryUpsertArgs>
    ): Prisma__DictionaryClient<DictionaryGetPayload<T>>

    /**
     * Count the number of Dictionaries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DictionaryCountArgs} args - Arguments to filter Dictionaries to count.
     * @example
     * // Count the number of Dictionaries
     * const count = await prisma.dictionary.count({
     *   where: {
     *     // ... the filter for the Dictionaries we want to count
     *   }
     * })
    **/
    count<T extends DictionaryCountArgs>(
      args?: Subset<T, DictionaryCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DictionaryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Dictionary.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DictionaryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DictionaryAggregateArgs>(args: Subset<T, DictionaryAggregateArgs>): PrismaPromise<GetDictionaryAggregateType<T>>

    /**
     * Group by Dictionary.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DictionaryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DictionaryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DictionaryGroupByArgs['orderBy'] }
        : { orderBy?: DictionaryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DictionaryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDictionaryGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Dictionary.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__DictionaryClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    reference_listitems<T extends ReferenceListItemsFindManyArgs= {}>(args?: Subset<T, ReferenceListItemsFindManyArgs>): PrismaPromise<Array<ReferenceListItemsGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Dictionary base type for findUnique actions
   */
  export type DictionaryFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Dictionary
     * 
    **/
    select?: DictionarySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DictionaryInclude | null
    /**
     * Filter, which Dictionary to fetch.
     * 
    **/
    where: DictionaryWhereUniqueInput
  }

  /**
   * Dictionary: findUnique
   */
  export interface DictionaryFindUniqueArgs extends DictionaryFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Dictionary findUniqueOrThrow
   */
  export type DictionaryFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Dictionary
     * 
    **/
    select?: DictionarySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DictionaryInclude | null
    /**
     * Filter, which Dictionary to fetch.
     * 
    **/
    where: DictionaryWhereUniqueInput
  }


  /**
   * Dictionary base type for findFirst actions
   */
  export type DictionaryFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Dictionary
     * 
    **/
    select?: DictionarySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DictionaryInclude | null
    /**
     * Filter, which Dictionary to fetch.
     * 
    **/
    where?: DictionaryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Dictionaries to fetch.
     * 
    **/
    orderBy?: Enumerable<DictionaryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Dictionaries.
     * 
    **/
    cursor?: DictionaryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Dictionaries from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Dictionaries.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Dictionaries.
     * 
    **/
    distinct?: Enumerable<DictionaryScalarFieldEnum>
  }

  /**
   * Dictionary: findFirst
   */
  export interface DictionaryFindFirstArgs extends DictionaryFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Dictionary findFirstOrThrow
   */
  export type DictionaryFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Dictionary
     * 
    **/
    select?: DictionarySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DictionaryInclude | null
    /**
     * Filter, which Dictionary to fetch.
     * 
    **/
    where?: DictionaryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Dictionaries to fetch.
     * 
    **/
    orderBy?: Enumerable<DictionaryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Dictionaries.
     * 
    **/
    cursor?: DictionaryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Dictionaries from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Dictionaries.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Dictionaries.
     * 
    **/
    distinct?: Enumerable<DictionaryScalarFieldEnum>
  }


  /**
   * Dictionary findMany
   */
  export type DictionaryFindManyArgs = {
    /**
     * Select specific fields to fetch from the Dictionary
     * 
    **/
    select?: DictionarySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DictionaryInclude | null
    /**
     * Filter, which Dictionaries to fetch.
     * 
    **/
    where?: DictionaryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Dictionaries to fetch.
     * 
    **/
    orderBy?: Enumerable<DictionaryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Dictionaries.
     * 
    **/
    cursor?: DictionaryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Dictionaries from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Dictionaries.
     * 
    **/
    skip?: number
    distinct?: Enumerable<DictionaryScalarFieldEnum>
  }


  /**
   * Dictionary create
   */
  export type DictionaryCreateArgs = {
    /**
     * Select specific fields to fetch from the Dictionary
     * 
    **/
    select?: DictionarySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DictionaryInclude | null
    /**
     * The data needed to create a Dictionary.
     * 
    **/
    data: XOR<DictionaryCreateInput, DictionaryUncheckedCreateInput>
  }


  /**
   * Dictionary createMany
   */
  export type DictionaryCreateManyArgs = {
    /**
     * The data used to create many Dictionaries.
     * 
    **/
    data: Enumerable<DictionaryCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Dictionary update
   */
  export type DictionaryUpdateArgs = {
    /**
     * Select specific fields to fetch from the Dictionary
     * 
    **/
    select?: DictionarySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DictionaryInclude | null
    /**
     * The data needed to update a Dictionary.
     * 
    **/
    data: XOR<DictionaryUpdateInput, DictionaryUncheckedUpdateInput>
    /**
     * Choose, which Dictionary to update.
     * 
    **/
    where: DictionaryWhereUniqueInput
  }


  /**
   * Dictionary updateMany
   */
  export type DictionaryUpdateManyArgs = {
    /**
     * The data used to update Dictionaries.
     * 
    **/
    data: XOR<DictionaryUpdateManyMutationInput, DictionaryUncheckedUpdateManyInput>
    /**
     * Filter which Dictionaries to update
     * 
    **/
    where?: DictionaryWhereInput
  }


  /**
   * Dictionary upsert
   */
  export type DictionaryUpsertArgs = {
    /**
     * Select specific fields to fetch from the Dictionary
     * 
    **/
    select?: DictionarySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DictionaryInclude | null
    /**
     * The filter to search for the Dictionary to update in case it exists.
     * 
    **/
    where: DictionaryWhereUniqueInput
    /**
     * In case the Dictionary found by the `where` argument doesn't exist, create a new Dictionary with this data.
     * 
    **/
    create: XOR<DictionaryCreateInput, DictionaryUncheckedCreateInput>
    /**
     * In case the Dictionary was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<DictionaryUpdateInput, DictionaryUncheckedUpdateInput>
  }


  /**
   * Dictionary delete
   */
  export type DictionaryDeleteArgs = {
    /**
     * Select specific fields to fetch from the Dictionary
     * 
    **/
    select?: DictionarySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DictionaryInclude | null
    /**
     * Filter which Dictionary to delete.
     * 
    **/
    where: DictionaryWhereUniqueInput
  }


  /**
   * Dictionary deleteMany
   */
  export type DictionaryDeleteManyArgs = {
    /**
     * Filter which Dictionaries to delete
     * 
    **/
    where?: DictionaryWhereInput
  }


  /**
   * Dictionary without action
   */
  export type DictionaryArgs = {
    /**
     * Select specific fields to fetch from the Dictionary
     * 
    **/
    select?: DictionarySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DictionaryInclude | null
  }



  /**
   * Model Entity
   */


  export type AggregateEntity = {
    _count: EntityCountAggregateOutputType | null
    _avg: EntityAvgAggregateOutputType | null
    _sum: EntitySumAggregateOutputType | null
    _min: EntityMinAggregateOutputType | null
    _max: EntityMaxAggregateOutputType | null
  }

  export type EntityAvgAggregateOutputType = {
    entity_id: number | null
  }

  export type EntitySumAggregateOutputType = {
    entity_id: number | null
  }

  export type EntityMinAggregateOutputType = {
    entity_id: number | null
    name: string | null
    kana: string | null
    logo: string | null
    is_system: boolean | null
    created_at: Date | null
    updated_at: Date | null
    created_by: string | null
    updated_by: string | null
  }

  export type EntityMaxAggregateOutputType = {
    entity_id: number | null
    name: string | null
    kana: string | null
    logo: string | null
    is_system: boolean | null
    created_at: Date | null
    updated_at: Date | null
    created_by: string | null
    updated_by: string | null
  }

  export type EntityCountAggregateOutputType = {
    entity_id: number
    name: number
    kana: number
    logo: number
    socials: number
    gps: number
    contact_person: number
    contact_details: number
    is_system: number
    created_at: number
    updated_at: number
    created_by: number
    updated_by: number
    _all: number
  }


  export type EntityAvgAggregateInputType = {
    entity_id?: true
  }

  export type EntitySumAggregateInputType = {
    entity_id?: true
  }

  export type EntityMinAggregateInputType = {
    entity_id?: true
    name?: true
    kana?: true
    logo?: true
    is_system?: true
    created_at?: true
    updated_at?: true
    created_by?: true
    updated_by?: true
  }

  export type EntityMaxAggregateInputType = {
    entity_id?: true
    name?: true
    kana?: true
    logo?: true
    is_system?: true
    created_at?: true
    updated_at?: true
    created_by?: true
    updated_by?: true
  }

  export type EntityCountAggregateInputType = {
    entity_id?: true
    name?: true
    kana?: true
    logo?: true
    socials?: true
    gps?: true
    contact_person?: true
    contact_details?: true
    is_system?: true
    created_at?: true
    updated_at?: true
    created_by?: true
    updated_by?: true
    _all?: true
  }

  export type EntityAggregateArgs = {
    /**
     * Filter which Entity to aggregate.
     * 
    **/
    where?: EntityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Entities to fetch.
     * 
    **/
    orderBy?: Enumerable<EntityOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: EntityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Entities from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Entities.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Entities
    **/
    _count?: true | EntityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EntityAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EntitySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EntityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EntityMaxAggregateInputType
  }

  export type GetEntityAggregateType<T extends EntityAggregateArgs> = {
        [P in keyof T & keyof AggregateEntity]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEntity[P]>
      : GetScalarType<T[P], AggregateEntity[P]>
  }




  export type EntityGroupByArgs = {
    where?: EntityWhereInput
    orderBy?: Enumerable<EntityOrderByWithAggregationInput>
    by: Array<EntityScalarFieldEnum>
    having?: EntityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EntityCountAggregateInputType | true
    _avg?: EntityAvgAggregateInputType
    _sum?: EntitySumAggregateInputType
    _min?: EntityMinAggregateInputType
    _max?: EntityMaxAggregateInputType
  }


  export type EntityGroupByOutputType = {
    entity_id: number
    name: string
    kana: string | null
    logo: string | null
    socials: JsonValue | null
    gps: JsonValue | null
    contact_person: JsonValue | null
    contact_details: JsonValue | null
    is_system: boolean
    created_at: Date
    updated_at: Date
    created_by: string | null
    updated_by: string | null
    _count: EntityCountAggregateOutputType | null
    _avg: EntityAvgAggregateOutputType | null
    _sum: EntitySumAggregateOutputType | null
    _min: EntityMinAggregateOutputType | null
    _max: EntityMaxAggregateOutputType | null
  }

  type GetEntityGroupByPayload<T extends EntityGroupByArgs> = PrismaPromise<
    Array<
      PickArray<EntityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EntityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EntityGroupByOutputType[P]>
            : GetScalarType<T[P], EntityGroupByOutputType[P]>
        }
      >
    >


  export type EntitySelect = {
    entity_id?: boolean
    name?: boolean
    kana?: boolean
    logo?: boolean
    socials?: boolean
    gps?: boolean
    contact_person?: boolean
    contact_details?: boolean
    is_system?: boolean
    created_at?: boolean
    updated_at?: boolean
    created_by?: boolean
    updated_by?: boolean
    entity_details?: boolean | EntityDetailFindManyArgs
    entity_branches?: boolean | EntityBranchFindManyArgs
    entity_accountinfos?: boolean | EntityAccountInfoFindManyArgs
    inquiries?: boolean | InquiryFindManyArgs
    _count?: boolean | EntityCountOutputTypeArgs
  }


  export type EntityInclude = {
    entity_details?: boolean | EntityDetailFindManyArgs
    entity_branches?: boolean | EntityBranchFindManyArgs
    entity_accountinfos?: boolean | EntityAccountInfoFindManyArgs
    inquiries?: boolean | InquiryFindManyArgs
    _count?: boolean | EntityCountOutputTypeArgs
  } 

  export type EntityGetPayload<S extends boolean | null | undefined | EntityArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Entity :
    S extends undefined ? never :
    S extends { include: any } & (EntityArgs | EntityFindManyArgs)
    ? Entity  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'entity_details' ? Array < EntityDetailGetPayload<S['include'][P]>>  :
        P extends 'entity_branches' ? Array < EntityBranchGetPayload<S['include'][P]>>  :
        P extends 'entity_accountinfos' ? Array < EntityAccountInfoGetPayload<S['include'][P]>>  :
        P extends 'inquiries' ? Array < InquiryGetPayload<S['include'][P]>>  :
        P extends '_count' ? EntityCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (EntityArgs | EntityFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'entity_details' ? Array < EntityDetailGetPayload<S['select'][P]>>  :
        P extends 'entity_branches' ? Array < EntityBranchGetPayload<S['select'][P]>>  :
        P extends 'entity_accountinfos' ? Array < EntityAccountInfoGetPayload<S['select'][P]>>  :
        P extends 'inquiries' ? Array < InquiryGetPayload<S['select'][P]>>  :
        P extends '_count' ? EntityCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Entity ? Entity[P] : never
  } 
      : Entity


  type EntityCountArgs = Merge<
    Omit<EntityFindManyArgs, 'select' | 'include'> & {
      select?: EntityCountAggregateInputType | true
    }
  >

  export interface EntityDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Entity that matches the filter.
     * @param {EntityFindUniqueArgs} args - Arguments to find a Entity
     * @example
     * // Get one Entity
     * const entity = await prisma.entity.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends EntityFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, EntityFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Entity'> extends True ? Prisma__EntityClient<EntityGetPayload<T>> : Prisma__EntityClient<EntityGetPayload<T> | null, null>

    /**
     * Find one Entity that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {EntityFindUniqueOrThrowArgs} args - Arguments to find a Entity
     * @example
     * // Get one Entity
     * const entity = await prisma.entity.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends EntityFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, EntityFindUniqueOrThrowArgs>
    ): Prisma__EntityClient<EntityGetPayload<T>>

    /**
     * Find the first Entity that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EntityFindFirstArgs} args - Arguments to find a Entity
     * @example
     * // Get one Entity
     * const entity = await prisma.entity.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends EntityFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, EntityFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Entity'> extends True ? Prisma__EntityClient<EntityGetPayload<T>> : Prisma__EntityClient<EntityGetPayload<T> | null, null>

    /**
     * Find the first Entity that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EntityFindFirstOrThrowArgs} args - Arguments to find a Entity
     * @example
     * // Get one Entity
     * const entity = await prisma.entity.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends EntityFindFirstOrThrowArgs>(
      args?: SelectSubset<T, EntityFindFirstOrThrowArgs>
    ): Prisma__EntityClient<EntityGetPayload<T>>

    /**
     * Find zero or more Entities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EntityFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Entities
     * const entities = await prisma.entity.findMany()
     * 
     * // Get first 10 Entities
     * const entities = await prisma.entity.findMany({ take: 10 })
     * 
     * // Only select the `entity_id`
     * const entityWithEntity_idOnly = await prisma.entity.findMany({ select: { entity_id: true } })
     * 
    **/
    findMany<T extends EntityFindManyArgs>(
      args?: SelectSubset<T, EntityFindManyArgs>
    ): PrismaPromise<Array<EntityGetPayload<T>>>

    /**
     * Create a Entity.
     * @param {EntityCreateArgs} args - Arguments to create a Entity.
     * @example
     * // Create one Entity
     * const Entity = await prisma.entity.create({
     *   data: {
     *     // ... data to create a Entity
     *   }
     * })
     * 
    **/
    create<T extends EntityCreateArgs>(
      args: SelectSubset<T, EntityCreateArgs>
    ): Prisma__EntityClient<EntityGetPayload<T>>

    /**
     * Create many Entities.
     *     @param {EntityCreateManyArgs} args - Arguments to create many Entities.
     *     @example
     *     // Create many Entities
     *     const entity = await prisma.entity.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends EntityCreateManyArgs>(
      args?: SelectSubset<T, EntityCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Entity.
     * @param {EntityDeleteArgs} args - Arguments to delete one Entity.
     * @example
     * // Delete one Entity
     * const Entity = await prisma.entity.delete({
     *   where: {
     *     // ... filter to delete one Entity
     *   }
     * })
     * 
    **/
    delete<T extends EntityDeleteArgs>(
      args: SelectSubset<T, EntityDeleteArgs>
    ): Prisma__EntityClient<EntityGetPayload<T>>

    /**
     * Update one Entity.
     * @param {EntityUpdateArgs} args - Arguments to update one Entity.
     * @example
     * // Update one Entity
     * const entity = await prisma.entity.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends EntityUpdateArgs>(
      args: SelectSubset<T, EntityUpdateArgs>
    ): Prisma__EntityClient<EntityGetPayload<T>>

    /**
     * Delete zero or more Entities.
     * @param {EntityDeleteManyArgs} args - Arguments to filter Entities to delete.
     * @example
     * // Delete a few Entities
     * const { count } = await prisma.entity.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends EntityDeleteManyArgs>(
      args?: SelectSubset<T, EntityDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Entities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EntityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Entities
     * const entity = await prisma.entity.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends EntityUpdateManyArgs>(
      args: SelectSubset<T, EntityUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Entity.
     * @param {EntityUpsertArgs} args - Arguments to update or create a Entity.
     * @example
     * // Update or create a Entity
     * const entity = await prisma.entity.upsert({
     *   create: {
     *     // ... data to create a Entity
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Entity we want to update
     *   }
     * })
    **/
    upsert<T extends EntityUpsertArgs>(
      args: SelectSubset<T, EntityUpsertArgs>
    ): Prisma__EntityClient<EntityGetPayload<T>>

    /**
     * Count the number of Entities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EntityCountArgs} args - Arguments to filter Entities to count.
     * @example
     * // Count the number of Entities
     * const count = await prisma.entity.count({
     *   where: {
     *     // ... the filter for the Entities we want to count
     *   }
     * })
    **/
    count<T extends EntityCountArgs>(
      args?: Subset<T, EntityCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EntityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Entity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EntityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EntityAggregateArgs>(args: Subset<T, EntityAggregateArgs>): PrismaPromise<GetEntityAggregateType<T>>

    /**
     * Group by Entity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EntityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EntityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EntityGroupByArgs['orderBy'] }
        : { orderBy?: EntityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EntityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEntityGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Entity.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__EntityClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    entity_details<T extends EntityDetailFindManyArgs= {}>(args?: Subset<T, EntityDetailFindManyArgs>): PrismaPromise<Array<EntityDetailGetPayload<T>>| Null>;

    entity_branches<T extends EntityBranchFindManyArgs= {}>(args?: Subset<T, EntityBranchFindManyArgs>): PrismaPromise<Array<EntityBranchGetPayload<T>>| Null>;

    entity_accountinfos<T extends EntityAccountInfoFindManyArgs= {}>(args?: Subset<T, EntityAccountInfoFindManyArgs>): PrismaPromise<Array<EntityAccountInfoGetPayload<T>>| Null>;

    inquiries<T extends InquiryFindManyArgs= {}>(args?: Subset<T, InquiryFindManyArgs>): PrismaPromise<Array<InquiryGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Entity base type for findUnique actions
   */
  export type EntityFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Entity
     * 
    **/
    select?: EntitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EntityInclude | null
    /**
     * Filter, which Entity to fetch.
     * 
    **/
    where: EntityWhereUniqueInput
  }

  /**
   * Entity: findUnique
   */
  export interface EntityFindUniqueArgs extends EntityFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Entity findUniqueOrThrow
   */
  export type EntityFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Entity
     * 
    **/
    select?: EntitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EntityInclude | null
    /**
     * Filter, which Entity to fetch.
     * 
    **/
    where: EntityWhereUniqueInput
  }


  /**
   * Entity base type for findFirst actions
   */
  export type EntityFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Entity
     * 
    **/
    select?: EntitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EntityInclude | null
    /**
     * Filter, which Entity to fetch.
     * 
    **/
    where?: EntityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Entities to fetch.
     * 
    **/
    orderBy?: Enumerable<EntityOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Entities.
     * 
    **/
    cursor?: EntityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Entities from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Entities.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Entities.
     * 
    **/
    distinct?: Enumerable<EntityScalarFieldEnum>
  }

  /**
   * Entity: findFirst
   */
  export interface EntityFindFirstArgs extends EntityFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Entity findFirstOrThrow
   */
  export type EntityFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Entity
     * 
    **/
    select?: EntitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EntityInclude | null
    /**
     * Filter, which Entity to fetch.
     * 
    **/
    where?: EntityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Entities to fetch.
     * 
    **/
    orderBy?: Enumerable<EntityOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Entities.
     * 
    **/
    cursor?: EntityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Entities from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Entities.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Entities.
     * 
    **/
    distinct?: Enumerable<EntityScalarFieldEnum>
  }


  /**
   * Entity findMany
   */
  export type EntityFindManyArgs = {
    /**
     * Select specific fields to fetch from the Entity
     * 
    **/
    select?: EntitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EntityInclude | null
    /**
     * Filter, which Entities to fetch.
     * 
    **/
    where?: EntityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Entities to fetch.
     * 
    **/
    orderBy?: Enumerable<EntityOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Entities.
     * 
    **/
    cursor?: EntityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Entities from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Entities.
     * 
    **/
    skip?: number
    distinct?: Enumerable<EntityScalarFieldEnum>
  }


  /**
   * Entity create
   */
  export type EntityCreateArgs = {
    /**
     * Select specific fields to fetch from the Entity
     * 
    **/
    select?: EntitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EntityInclude | null
    /**
     * The data needed to create a Entity.
     * 
    **/
    data: XOR<EntityCreateInput, EntityUncheckedCreateInput>
  }


  /**
   * Entity createMany
   */
  export type EntityCreateManyArgs = {
    /**
     * The data used to create many Entities.
     * 
    **/
    data: Enumerable<EntityCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Entity update
   */
  export type EntityUpdateArgs = {
    /**
     * Select specific fields to fetch from the Entity
     * 
    **/
    select?: EntitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EntityInclude | null
    /**
     * The data needed to update a Entity.
     * 
    **/
    data: XOR<EntityUpdateInput, EntityUncheckedUpdateInput>
    /**
     * Choose, which Entity to update.
     * 
    **/
    where: EntityWhereUniqueInput
  }


  /**
   * Entity updateMany
   */
  export type EntityUpdateManyArgs = {
    /**
     * The data used to update Entities.
     * 
    **/
    data: XOR<EntityUpdateManyMutationInput, EntityUncheckedUpdateManyInput>
    /**
     * Filter which Entities to update
     * 
    **/
    where?: EntityWhereInput
  }


  /**
   * Entity upsert
   */
  export type EntityUpsertArgs = {
    /**
     * Select specific fields to fetch from the Entity
     * 
    **/
    select?: EntitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EntityInclude | null
    /**
     * The filter to search for the Entity to update in case it exists.
     * 
    **/
    where: EntityWhereUniqueInput
    /**
     * In case the Entity found by the `where` argument doesn't exist, create a new Entity with this data.
     * 
    **/
    create: XOR<EntityCreateInput, EntityUncheckedCreateInput>
    /**
     * In case the Entity was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<EntityUpdateInput, EntityUncheckedUpdateInput>
  }


  /**
   * Entity delete
   */
  export type EntityDeleteArgs = {
    /**
     * Select specific fields to fetch from the Entity
     * 
    **/
    select?: EntitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EntityInclude | null
    /**
     * Filter which Entity to delete.
     * 
    **/
    where: EntityWhereUniqueInput
  }


  /**
   * Entity deleteMany
   */
  export type EntityDeleteManyArgs = {
    /**
     * Filter which Entities to delete
     * 
    **/
    where?: EntityWhereInput
  }


  /**
   * Entity without action
   */
  export type EntityArgs = {
    /**
     * Select specific fields to fetch from the Entity
     * 
    **/
    select?: EntitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EntityInclude | null
  }



  /**
   * Model EntityAccountInfo
   */


  export type AggregateEntityAccountInfo = {
    _count: EntityAccountInfoCountAggregateOutputType | null
    _avg: EntityAccountInfoAvgAggregateOutputType | null
    _sum: EntityAccountInfoSumAggregateOutputType | null
    _min: EntityAccountInfoMinAggregateOutputType | null
    _max: EntityAccountInfoMaxAggregateOutputType | null
  }

  export type EntityAccountInfoAvgAggregateOutputType = {
    entity_id: number | null
  }

  export type EntityAccountInfoSumAggregateOutputType = {
    entity_id: number | null
  }

  export type EntityAccountInfoMinAggregateOutputType = {
    entity_accountinfo_id: string | null
    entity_id: number | null
    bank_code: string | null
    branch_code: string | null
    account_id: string | null
    is_default: boolean | null
    created_at: Date | null
    updated_at: Date | null
    updated_by: string | null
    created_by: string | null
  }

  export type EntityAccountInfoMaxAggregateOutputType = {
    entity_accountinfo_id: string | null
    entity_id: number | null
    bank_code: string | null
    branch_code: string | null
    account_id: string | null
    is_default: boolean | null
    created_at: Date | null
    updated_at: Date | null
    updated_by: string | null
    created_by: string | null
  }

  export type EntityAccountInfoCountAggregateOutputType = {
    entity_accountinfo_id: number
    entity_id: number
    bank_code: number
    branch_code: number
    account_id: number
    is_default: number
    created_at: number
    updated_at: number
    updated_by: number
    created_by: number
    _all: number
  }


  export type EntityAccountInfoAvgAggregateInputType = {
    entity_id?: true
  }

  export type EntityAccountInfoSumAggregateInputType = {
    entity_id?: true
  }

  export type EntityAccountInfoMinAggregateInputType = {
    entity_accountinfo_id?: true
    entity_id?: true
    bank_code?: true
    branch_code?: true
    account_id?: true
    is_default?: true
    created_at?: true
    updated_at?: true
    updated_by?: true
    created_by?: true
  }

  export type EntityAccountInfoMaxAggregateInputType = {
    entity_accountinfo_id?: true
    entity_id?: true
    bank_code?: true
    branch_code?: true
    account_id?: true
    is_default?: true
    created_at?: true
    updated_at?: true
    updated_by?: true
    created_by?: true
  }

  export type EntityAccountInfoCountAggregateInputType = {
    entity_accountinfo_id?: true
    entity_id?: true
    bank_code?: true
    branch_code?: true
    account_id?: true
    is_default?: true
    created_at?: true
    updated_at?: true
    updated_by?: true
    created_by?: true
    _all?: true
  }

  export type EntityAccountInfoAggregateArgs = {
    /**
     * Filter which EntityAccountInfo to aggregate.
     * 
    **/
    where?: EntityAccountInfoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EntityAccountInfos to fetch.
     * 
    **/
    orderBy?: Enumerable<EntityAccountInfoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: EntityAccountInfoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EntityAccountInfos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EntityAccountInfos.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EntityAccountInfos
    **/
    _count?: true | EntityAccountInfoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EntityAccountInfoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EntityAccountInfoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EntityAccountInfoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EntityAccountInfoMaxAggregateInputType
  }

  export type GetEntityAccountInfoAggregateType<T extends EntityAccountInfoAggregateArgs> = {
        [P in keyof T & keyof AggregateEntityAccountInfo]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEntityAccountInfo[P]>
      : GetScalarType<T[P], AggregateEntityAccountInfo[P]>
  }




  export type EntityAccountInfoGroupByArgs = {
    where?: EntityAccountInfoWhereInput
    orderBy?: Enumerable<EntityAccountInfoOrderByWithAggregationInput>
    by: Array<EntityAccountInfoScalarFieldEnum>
    having?: EntityAccountInfoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EntityAccountInfoCountAggregateInputType | true
    _avg?: EntityAccountInfoAvgAggregateInputType
    _sum?: EntityAccountInfoSumAggregateInputType
    _min?: EntityAccountInfoMinAggregateInputType
    _max?: EntityAccountInfoMaxAggregateInputType
  }


  export type EntityAccountInfoGroupByOutputType = {
    entity_accountinfo_id: string
    entity_id: number | null
    bank_code: string | null
    branch_code: string | null
    account_id: string | null
    is_default: boolean | null
    created_at: Date
    updated_at: Date
    updated_by: string | null
    created_by: string | null
    _count: EntityAccountInfoCountAggregateOutputType | null
    _avg: EntityAccountInfoAvgAggregateOutputType | null
    _sum: EntityAccountInfoSumAggregateOutputType | null
    _min: EntityAccountInfoMinAggregateOutputType | null
    _max: EntityAccountInfoMaxAggregateOutputType | null
  }

  type GetEntityAccountInfoGroupByPayload<T extends EntityAccountInfoGroupByArgs> = PrismaPromise<
    Array<
      PickArray<EntityAccountInfoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EntityAccountInfoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EntityAccountInfoGroupByOutputType[P]>
            : GetScalarType<T[P], EntityAccountInfoGroupByOutputType[P]>
        }
      >
    >


  export type EntityAccountInfoSelect = {
    entity_accountinfo_id?: boolean
    entity_id?: boolean
    entity?: boolean | EntityArgs
    bank_code?: boolean
    branch_code?: boolean
    account_id?: boolean
    is_default?: boolean
    created_at?: boolean
    updated_at?: boolean
    updated_by?: boolean
    created_by?: boolean
  }


  export type EntityAccountInfoInclude = {
    entity?: boolean | EntityArgs
  } 

  export type EntityAccountInfoGetPayload<S extends boolean | null | undefined | EntityAccountInfoArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? EntityAccountInfo :
    S extends undefined ? never :
    S extends { include: any } & (EntityAccountInfoArgs | EntityAccountInfoFindManyArgs)
    ? EntityAccountInfo  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'entity' ? EntityGetPayload<S['include'][P]> | null :  never
  } 
    : S extends { select: any } & (EntityAccountInfoArgs | EntityAccountInfoFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'entity' ? EntityGetPayload<S['select'][P]> | null :  P extends keyof EntityAccountInfo ? EntityAccountInfo[P] : never
  } 
      : EntityAccountInfo


  type EntityAccountInfoCountArgs = Merge<
    Omit<EntityAccountInfoFindManyArgs, 'select' | 'include'> & {
      select?: EntityAccountInfoCountAggregateInputType | true
    }
  >

  export interface EntityAccountInfoDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one EntityAccountInfo that matches the filter.
     * @param {EntityAccountInfoFindUniqueArgs} args - Arguments to find a EntityAccountInfo
     * @example
     * // Get one EntityAccountInfo
     * const entityAccountInfo = await prisma.entityAccountInfo.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends EntityAccountInfoFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, EntityAccountInfoFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'EntityAccountInfo'> extends True ? Prisma__EntityAccountInfoClient<EntityAccountInfoGetPayload<T>> : Prisma__EntityAccountInfoClient<EntityAccountInfoGetPayload<T> | null, null>

    /**
     * Find one EntityAccountInfo that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {EntityAccountInfoFindUniqueOrThrowArgs} args - Arguments to find a EntityAccountInfo
     * @example
     * // Get one EntityAccountInfo
     * const entityAccountInfo = await prisma.entityAccountInfo.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends EntityAccountInfoFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, EntityAccountInfoFindUniqueOrThrowArgs>
    ): Prisma__EntityAccountInfoClient<EntityAccountInfoGetPayload<T>>

    /**
     * Find the first EntityAccountInfo that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EntityAccountInfoFindFirstArgs} args - Arguments to find a EntityAccountInfo
     * @example
     * // Get one EntityAccountInfo
     * const entityAccountInfo = await prisma.entityAccountInfo.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends EntityAccountInfoFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, EntityAccountInfoFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'EntityAccountInfo'> extends True ? Prisma__EntityAccountInfoClient<EntityAccountInfoGetPayload<T>> : Prisma__EntityAccountInfoClient<EntityAccountInfoGetPayload<T> | null, null>

    /**
     * Find the first EntityAccountInfo that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EntityAccountInfoFindFirstOrThrowArgs} args - Arguments to find a EntityAccountInfo
     * @example
     * // Get one EntityAccountInfo
     * const entityAccountInfo = await prisma.entityAccountInfo.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends EntityAccountInfoFindFirstOrThrowArgs>(
      args?: SelectSubset<T, EntityAccountInfoFindFirstOrThrowArgs>
    ): Prisma__EntityAccountInfoClient<EntityAccountInfoGetPayload<T>>

    /**
     * Find zero or more EntityAccountInfos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EntityAccountInfoFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EntityAccountInfos
     * const entityAccountInfos = await prisma.entityAccountInfo.findMany()
     * 
     * // Get first 10 EntityAccountInfos
     * const entityAccountInfos = await prisma.entityAccountInfo.findMany({ take: 10 })
     * 
     * // Only select the `entity_accountinfo_id`
     * const entityAccountInfoWithEntity_accountinfo_idOnly = await prisma.entityAccountInfo.findMany({ select: { entity_accountinfo_id: true } })
     * 
    **/
    findMany<T extends EntityAccountInfoFindManyArgs>(
      args?: SelectSubset<T, EntityAccountInfoFindManyArgs>
    ): PrismaPromise<Array<EntityAccountInfoGetPayload<T>>>

    /**
     * Create a EntityAccountInfo.
     * @param {EntityAccountInfoCreateArgs} args - Arguments to create a EntityAccountInfo.
     * @example
     * // Create one EntityAccountInfo
     * const EntityAccountInfo = await prisma.entityAccountInfo.create({
     *   data: {
     *     // ... data to create a EntityAccountInfo
     *   }
     * })
     * 
    **/
    create<T extends EntityAccountInfoCreateArgs>(
      args: SelectSubset<T, EntityAccountInfoCreateArgs>
    ): Prisma__EntityAccountInfoClient<EntityAccountInfoGetPayload<T>>

    /**
     * Create many EntityAccountInfos.
     *     @param {EntityAccountInfoCreateManyArgs} args - Arguments to create many EntityAccountInfos.
     *     @example
     *     // Create many EntityAccountInfos
     *     const entityAccountInfo = await prisma.entityAccountInfo.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends EntityAccountInfoCreateManyArgs>(
      args?: SelectSubset<T, EntityAccountInfoCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a EntityAccountInfo.
     * @param {EntityAccountInfoDeleteArgs} args - Arguments to delete one EntityAccountInfo.
     * @example
     * // Delete one EntityAccountInfo
     * const EntityAccountInfo = await prisma.entityAccountInfo.delete({
     *   where: {
     *     // ... filter to delete one EntityAccountInfo
     *   }
     * })
     * 
    **/
    delete<T extends EntityAccountInfoDeleteArgs>(
      args: SelectSubset<T, EntityAccountInfoDeleteArgs>
    ): Prisma__EntityAccountInfoClient<EntityAccountInfoGetPayload<T>>

    /**
     * Update one EntityAccountInfo.
     * @param {EntityAccountInfoUpdateArgs} args - Arguments to update one EntityAccountInfo.
     * @example
     * // Update one EntityAccountInfo
     * const entityAccountInfo = await prisma.entityAccountInfo.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends EntityAccountInfoUpdateArgs>(
      args: SelectSubset<T, EntityAccountInfoUpdateArgs>
    ): Prisma__EntityAccountInfoClient<EntityAccountInfoGetPayload<T>>

    /**
     * Delete zero or more EntityAccountInfos.
     * @param {EntityAccountInfoDeleteManyArgs} args - Arguments to filter EntityAccountInfos to delete.
     * @example
     * // Delete a few EntityAccountInfos
     * const { count } = await prisma.entityAccountInfo.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends EntityAccountInfoDeleteManyArgs>(
      args?: SelectSubset<T, EntityAccountInfoDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more EntityAccountInfos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EntityAccountInfoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EntityAccountInfos
     * const entityAccountInfo = await prisma.entityAccountInfo.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends EntityAccountInfoUpdateManyArgs>(
      args: SelectSubset<T, EntityAccountInfoUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one EntityAccountInfo.
     * @param {EntityAccountInfoUpsertArgs} args - Arguments to update or create a EntityAccountInfo.
     * @example
     * // Update or create a EntityAccountInfo
     * const entityAccountInfo = await prisma.entityAccountInfo.upsert({
     *   create: {
     *     // ... data to create a EntityAccountInfo
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EntityAccountInfo we want to update
     *   }
     * })
    **/
    upsert<T extends EntityAccountInfoUpsertArgs>(
      args: SelectSubset<T, EntityAccountInfoUpsertArgs>
    ): Prisma__EntityAccountInfoClient<EntityAccountInfoGetPayload<T>>

    /**
     * Count the number of EntityAccountInfos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EntityAccountInfoCountArgs} args - Arguments to filter EntityAccountInfos to count.
     * @example
     * // Count the number of EntityAccountInfos
     * const count = await prisma.entityAccountInfo.count({
     *   where: {
     *     // ... the filter for the EntityAccountInfos we want to count
     *   }
     * })
    **/
    count<T extends EntityAccountInfoCountArgs>(
      args?: Subset<T, EntityAccountInfoCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EntityAccountInfoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EntityAccountInfo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EntityAccountInfoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EntityAccountInfoAggregateArgs>(args: Subset<T, EntityAccountInfoAggregateArgs>): PrismaPromise<GetEntityAccountInfoAggregateType<T>>

    /**
     * Group by EntityAccountInfo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EntityAccountInfoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EntityAccountInfoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EntityAccountInfoGroupByArgs['orderBy'] }
        : { orderBy?: EntityAccountInfoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EntityAccountInfoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEntityAccountInfoGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for EntityAccountInfo.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__EntityAccountInfoClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    entity<T extends EntityArgs= {}>(args?: Subset<T, EntityArgs>): Prisma__EntityClient<EntityGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * EntityAccountInfo base type for findUnique actions
   */
  export type EntityAccountInfoFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the EntityAccountInfo
     * 
    **/
    select?: EntityAccountInfoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EntityAccountInfoInclude | null
    /**
     * Filter, which EntityAccountInfo to fetch.
     * 
    **/
    where: EntityAccountInfoWhereUniqueInput
  }

  /**
   * EntityAccountInfo: findUnique
   */
  export interface EntityAccountInfoFindUniqueArgs extends EntityAccountInfoFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * EntityAccountInfo findUniqueOrThrow
   */
  export type EntityAccountInfoFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the EntityAccountInfo
     * 
    **/
    select?: EntityAccountInfoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EntityAccountInfoInclude | null
    /**
     * Filter, which EntityAccountInfo to fetch.
     * 
    **/
    where: EntityAccountInfoWhereUniqueInput
  }


  /**
   * EntityAccountInfo base type for findFirst actions
   */
  export type EntityAccountInfoFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the EntityAccountInfo
     * 
    **/
    select?: EntityAccountInfoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EntityAccountInfoInclude | null
    /**
     * Filter, which EntityAccountInfo to fetch.
     * 
    **/
    where?: EntityAccountInfoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EntityAccountInfos to fetch.
     * 
    **/
    orderBy?: Enumerable<EntityAccountInfoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EntityAccountInfos.
     * 
    **/
    cursor?: EntityAccountInfoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EntityAccountInfos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EntityAccountInfos.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EntityAccountInfos.
     * 
    **/
    distinct?: Enumerable<EntityAccountInfoScalarFieldEnum>
  }

  /**
   * EntityAccountInfo: findFirst
   */
  export interface EntityAccountInfoFindFirstArgs extends EntityAccountInfoFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * EntityAccountInfo findFirstOrThrow
   */
  export type EntityAccountInfoFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the EntityAccountInfo
     * 
    **/
    select?: EntityAccountInfoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EntityAccountInfoInclude | null
    /**
     * Filter, which EntityAccountInfo to fetch.
     * 
    **/
    where?: EntityAccountInfoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EntityAccountInfos to fetch.
     * 
    **/
    orderBy?: Enumerable<EntityAccountInfoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EntityAccountInfos.
     * 
    **/
    cursor?: EntityAccountInfoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EntityAccountInfos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EntityAccountInfos.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EntityAccountInfos.
     * 
    **/
    distinct?: Enumerable<EntityAccountInfoScalarFieldEnum>
  }


  /**
   * EntityAccountInfo findMany
   */
  export type EntityAccountInfoFindManyArgs = {
    /**
     * Select specific fields to fetch from the EntityAccountInfo
     * 
    **/
    select?: EntityAccountInfoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EntityAccountInfoInclude | null
    /**
     * Filter, which EntityAccountInfos to fetch.
     * 
    **/
    where?: EntityAccountInfoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EntityAccountInfos to fetch.
     * 
    **/
    orderBy?: Enumerable<EntityAccountInfoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EntityAccountInfos.
     * 
    **/
    cursor?: EntityAccountInfoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EntityAccountInfos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EntityAccountInfos.
     * 
    **/
    skip?: number
    distinct?: Enumerable<EntityAccountInfoScalarFieldEnum>
  }


  /**
   * EntityAccountInfo create
   */
  export type EntityAccountInfoCreateArgs = {
    /**
     * Select specific fields to fetch from the EntityAccountInfo
     * 
    **/
    select?: EntityAccountInfoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EntityAccountInfoInclude | null
    /**
     * The data needed to create a EntityAccountInfo.
     * 
    **/
    data: XOR<EntityAccountInfoCreateInput, EntityAccountInfoUncheckedCreateInput>
  }


  /**
   * EntityAccountInfo createMany
   */
  export type EntityAccountInfoCreateManyArgs = {
    /**
     * The data used to create many EntityAccountInfos.
     * 
    **/
    data: Enumerable<EntityAccountInfoCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * EntityAccountInfo update
   */
  export type EntityAccountInfoUpdateArgs = {
    /**
     * Select specific fields to fetch from the EntityAccountInfo
     * 
    **/
    select?: EntityAccountInfoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EntityAccountInfoInclude | null
    /**
     * The data needed to update a EntityAccountInfo.
     * 
    **/
    data: XOR<EntityAccountInfoUpdateInput, EntityAccountInfoUncheckedUpdateInput>
    /**
     * Choose, which EntityAccountInfo to update.
     * 
    **/
    where: EntityAccountInfoWhereUniqueInput
  }


  /**
   * EntityAccountInfo updateMany
   */
  export type EntityAccountInfoUpdateManyArgs = {
    /**
     * The data used to update EntityAccountInfos.
     * 
    **/
    data: XOR<EntityAccountInfoUpdateManyMutationInput, EntityAccountInfoUncheckedUpdateManyInput>
    /**
     * Filter which EntityAccountInfos to update
     * 
    **/
    where?: EntityAccountInfoWhereInput
  }


  /**
   * EntityAccountInfo upsert
   */
  export type EntityAccountInfoUpsertArgs = {
    /**
     * Select specific fields to fetch from the EntityAccountInfo
     * 
    **/
    select?: EntityAccountInfoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EntityAccountInfoInclude | null
    /**
     * The filter to search for the EntityAccountInfo to update in case it exists.
     * 
    **/
    where: EntityAccountInfoWhereUniqueInput
    /**
     * In case the EntityAccountInfo found by the `where` argument doesn't exist, create a new EntityAccountInfo with this data.
     * 
    **/
    create: XOR<EntityAccountInfoCreateInput, EntityAccountInfoUncheckedCreateInput>
    /**
     * In case the EntityAccountInfo was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<EntityAccountInfoUpdateInput, EntityAccountInfoUncheckedUpdateInput>
  }


  /**
   * EntityAccountInfo delete
   */
  export type EntityAccountInfoDeleteArgs = {
    /**
     * Select specific fields to fetch from the EntityAccountInfo
     * 
    **/
    select?: EntityAccountInfoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EntityAccountInfoInclude | null
    /**
     * Filter which EntityAccountInfo to delete.
     * 
    **/
    where: EntityAccountInfoWhereUniqueInput
  }


  /**
   * EntityAccountInfo deleteMany
   */
  export type EntityAccountInfoDeleteManyArgs = {
    /**
     * Filter which EntityAccountInfos to delete
     * 
    **/
    where?: EntityAccountInfoWhereInput
  }


  /**
   * EntityAccountInfo without action
   */
  export type EntityAccountInfoArgs = {
    /**
     * Select specific fields to fetch from the EntityAccountInfo
     * 
    **/
    select?: EntityAccountInfoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EntityAccountInfoInclude | null
  }



  /**
   * Model EntityBranch
   */


  export type AggregateEntityBranch = {
    _count: EntityBranchCountAggregateOutputType | null
    _avg: EntityBranchAvgAggregateOutputType | null
    _sum: EntityBranchSumAggregateOutputType | null
    _min: EntityBranchMinAggregateOutputType | null
    _max: EntityBranchMaxAggregateOutputType | null
  }

  export type EntityBranchAvgAggregateOutputType = {
    branch_id: number | null
    entity_id: number | null
  }

  export type EntityBranchSumAggregateOutputType = {
    branch_id: number | null
    entity_id: number | null
  }

  export type EntityBranchMinAggregateOutputType = {
    branch_id: number | null
    branch_name: string | null
    kana: string | null
    is_jeadquarter: boolean | null
    image: string | null
    post_code: string | null
    city: string | null
    district: string | null
    address: string | null
    address1: string | null
    nearest_station: string | null
    created_at: Date | null
    updated_at: Date | null
    created_by: string | null
    updated_by: string | null
    entity_id: number | null
  }

  export type EntityBranchMaxAggregateOutputType = {
    branch_id: number | null
    branch_name: string | null
    kana: string | null
    is_jeadquarter: boolean | null
    image: string | null
    post_code: string | null
    city: string | null
    district: string | null
    address: string | null
    address1: string | null
    nearest_station: string | null
    created_at: Date | null
    updated_at: Date | null
    created_by: string | null
    updated_by: string | null
    entity_id: number | null
  }

  export type EntityBranchCountAggregateOutputType = {
    branch_id: number
    branch_name: number
    kana: number
    is_jeadquarter: number
    image: number
    prefecture: number
    post_code: number
    city: number
    district: number
    address: number
    address1: number
    nearest_station: number
    socials: number
    gps: number
    contact_person: number
    contact_details: number
    created_at: number
    updated_at: number
    created_by: number
    updated_by: number
    entity_id: number
    _all: number
  }


  export type EntityBranchAvgAggregateInputType = {
    branch_id?: true
    entity_id?: true
  }

  export type EntityBranchSumAggregateInputType = {
    branch_id?: true
    entity_id?: true
  }

  export type EntityBranchMinAggregateInputType = {
    branch_id?: true
    branch_name?: true
    kana?: true
    is_jeadquarter?: true
    image?: true
    post_code?: true
    city?: true
    district?: true
    address?: true
    address1?: true
    nearest_station?: true
    created_at?: true
    updated_at?: true
    created_by?: true
    updated_by?: true
    entity_id?: true
  }

  export type EntityBranchMaxAggregateInputType = {
    branch_id?: true
    branch_name?: true
    kana?: true
    is_jeadquarter?: true
    image?: true
    post_code?: true
    city?: true
    district?: true
    address?: true
    address1?: true
    nearest_station?: true
    created_at?: true
    updated_at?: true
    created_by?: true
    updated_by?: true
    entity_id?: true
  }

  export type EntityBranchCountAggregateInputType = {
    branch_id?: true
    branch_name?: true
    kana?: true
    is_jeadquarter?: true
    image?: true
    prefecture?: true
    post_code?: true
    city?: true
    district?: true
    address?: true
    address1?: true
    nearest_station?: true
    socials?: true
    gps?: true
    contact_person?: true
    contact_details?: true
    created_at?: true
    updated_at?: true
    created_by?: true
    updated_by?: true
    entity_id?: true
    _all?: true
  }

  export type EntityBranchAggregateArgs = {
    /**
     * Filter which EntityBranch to aggregate.
     * 
    **/
    where?: EntityBranchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EntityBranches to fetch.
     * 
    **/
    orderBy?: Enumerable<EntityBranchOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: EntityBranchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EntityBranches from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EntityBranches.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EntityBranches
    **/
    _count?: true | EntityBranchCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EntityBranchAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EntityBranchSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EntityBranchMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EntityBranchMaxAggregateInputType
  }

  export type GetEntityBranchAggregateType<T extends EntityBranchAggregateArgs> = {
        [P in keyof T & keyof AggregateEntityBranch]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEntityBranch[P]>
      : GetScalarType<T[P], AggregateEntityBranch[P]>
  }




  export type EntityBranchGroupByArgs = {
    where?: EntityBranchWhereInput
    orderBy?: Enumerable<EntityBranchOrderByWithAggregationInput>
    by: Array<EntityBranchScalarFieldEnum>
    having?: EntityBranchScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EntityBranchCountAggregateInputType | true
    _avg?: EntityBranchAvgAggregateInputType
    _sum?: EntityBranchSumAggregateInputType
    _min?: EntityBranchMinAggregateInputType
    _max?: EntityBranchMaxAggregateInputType
  }


  export type EntityBranchGroupByOutputType = {
    branch_id: number
    branch_name: string | null
    kana: string | null
    is_jeadquarter: boolean
    image: string | null
    prefecture: JsonValue | null
    post_code: string | null
    city: string | null
    district: string | null
    address: string | null
    address1: string | null
    nearest_station: string | null
    socials: JsonValue | null
    gps: JsonValue | null
    contact_person: JsonValue | null
    contact_details: JsonValue | null
    created_at: Date
    updated_at: Date
    created_by: string | null
    updated_by: string | null
    entity_id: number
    _count: EntityBranchCountAggregateOutputType | null
    _avg: EntityBranchAvgAggregateOutputType | null
    _sum: EntityBranchSumAggregateOutputType | null
    _min: EntityBranchMinAggregateOutputType | null
    _max: EntityBranchMaxAggregateOutputType | null
  }

  type GetEntityBranchGroupByPayload<T extends EntityBranchGroupByArgs> = PrismaPromise<
    Array<
      PickArray<EntityBranchGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EntityBranchGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EntityBranchGroupByOutputType[P]>
            : GetScalarType<T[P], EntityBranchGroupByOutputType[P]>
        }
      >
    >


  export type EntityBranchSelect = {
    branch_id?: boolean
    branch_name?: boolean
    kana?: boolean
    is_jeadquarter?: boolean
    image?: boolean
    prefecture?: boolean
    post_code?: boolean
    city?: boolean
    district?: boolean
    address?: boolean
    address1?: boolean
    nearest_station?: boolean
    socials?: boolean
    gps?: boolean
    contact_person?: boolean
    contact_details?: boolean
    created_at?: boolean
    updated_at?: boolean
    created_by?: boolean
    updated_by?: boolean
    entity?: boolean | EntityArgs
    entity_id?: boolean
    jobs?: boolean | JobFindManyArgs
    _count?: boolean | EntityBranchCountOutputTypeArgs
  }


  export type EntityBranchInclude = {
    entity?: boolean | EntityArgs
    jobs?: boolean | JobFindManyArgs
    _count?: boolean | EntityBranchCountOutputTypeArgs
  } 

  export type EntityBranchGetPayload<S extends boolean | null | undefined | EntityBranchArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? EntityBranch :
    S extends undefined ? never :
    S extends { include: any } & (EntityBranchArgs | EntityBranchFindManyArgs)
    ? EntityBranch  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'entity' ? EntityGetPayload<S['include'][P]> :
        P extends 'jobs' ? Array < JobGetPayload<S['include'][P]>>  :
        P extends '_count' ? EntityBranchCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (EntityBranchArgs | EntityBranchFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'entity' ? EntityGetPayload<S['select'][P]> :
        P extends 'jobs' ? Array < JobGetPayload<S['select'][P]>>  :
        P extends '_count' ? EntityBranchCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof EntityBranch ? EntityBranch[P] : never
  } 
      : EntityBranch


  type EntityBranchCountArgs = Merge<
    Omit<EntityBranchFindManyArgs, 'select' | 'include'> & {
      select?: EntityBranchCountAggregateInputType | true
    }
  >

  export interface EntityBranchDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one EntityBranch that matches the filter.
     * @param {EntityBranchFindUniqueArgs} args - Arguments to find a EntityBranch
     * @example
     * // Get one EntityBranch
     * const entityBranch = await prisma.entityBranch.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends EntityBranchFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, EntityBranchFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'EntityBranch'> extends True ? Prisma__EntityBranchClient<EntityBranchGetPayload<T>> : Prisma__EntityBranchClient<EntityBranchGetPayload<T> | null, null>

    /**
     * Find one EntityBranch that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {EntityBranchFindUniqueOrThrowArgs} args - Arguments to find a EntityBranch
     * @example
     * // Get one EntityBranch
     * const entityBranch = await prisma.entityBranch.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends EntityBranchFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, EntityBranchFindUniqueOrThrowArgs>
    ): Prisma__EntityBranchClient<EntityBranchGetPayload<T>>

    /**
     * Find the first EntityBranch that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EntityBranchFindFirstArgs} args - Arguments to find a EntityBranch
     * @example
     * // Get one EntityBranch
     * const entityBranch = await prisma.entityBranch.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends EntityBranchFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, EntityBranchFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'EntityBranch'> extends True ? Prisma__EntityBranchClient<EntityBranchGetPayload<T>> : Prisma__EntityBranchClient<EntityBranchGetPayload<T> | null, null>

    /**
     * Find the first EntityBranch that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EntityBranchFindFirstOrThrowArgs} args - Arguments to find a EntityBranch
     * @example
     * // Get one EntityBranch
     * const entityBranch = await prisma.entityBranch.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends EntityBranchFindFirstOrThrowArgs>(
      args?: SelectSubset<T, EntityBranchFindFirstOrThrowArgs>
    ): Prisma__EntityBranchClient<EntityBranchGetPayload<T>>

    /**
     * Find zero or more EntityBranches that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EntityBranchFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EntityBranches
     * const entityBranches = await prisma.entityBranch.findMany()
     * 
     * // Get first 10 EntityBranches
     * const entityBranches = await prisma.entityBranch.findMany({ take: 10 })
     * 
     * // Only select the `branch_id`
     * const entityBranchWithBranch_idOnly = await prisma.entityBranch.findMany({ select: { branch_id: true } })
     * 
    **/
    findMany<T extends EntityBranchFindManyArgs>(
      args?: SelectSubset<T, EntityBranchFindManyArgs>
    ): PrismaPromise<Array<EntityBranchGetPayload<T>>>

    /**
     * Create a EntityBranch.
     * @param {EntityBranchCreateArgs} args - Arguments to create a EntityBranch.
     * @example
     * // Create one EntityBranch
     * const EntityBranch = await prisma.entityBranch.create({
     *   data: {
     *     // ... data to create a EntityBranch
     *   }
     * })
     * 
    **/
    create<T extends EntityBranchCreateArgs>(
      args: SelectSubset<T, EntityBranchCreateArgs>
    ): Prisma__EntityBranchClient<EntityBranchGetPayload<T>>

    /**
     * Create many EntityBranches.
     *     @param {EntityBranchCreateManyArgs} args - Arguments to create many EntityBranches.
     *     @example
     *     // Create many EntityBranches
     *     const entityBranch = await prisma.entityBranch.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends EntityBranchCreateManyArgs>(
      args?: SelectSubset<T, EntityBranchCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a EntityBranch.
     * @param {EntityBranchDeleteArgs} args - Arguments to delete one EntityBranch.
     * @example
     * // Delete one EntityBranch
     * const EntityBranch = await prisma.entityBranch.delete({
     *   where: {
     *     // ... filter to delete one EntityBranch
     *   }
     * })
     * 
    **/
    delete<T extends EntityBranchDeleteArgs>(
      args: SelectSubset<T, EntityBranchDeleteArgs>
    ): Prisma__EntityBranchClient<EntityBranchGetPayload<T>>

    /**
     * Update one EntityBranch.
     * @param {EntityBranchUpdateArgs} args - Arguments to update one EntityBranch.
     * @example
     * // Update one EntityBranch
     * const entityBranch = await prisma.entityBranch.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends EntityBranchUpdateArgs>(
      args: SelectSubset<T, EntityBranchUpdateArgs>
    ): Prisma__EntityBranchClient<EntityBranchGetPayload<T>>

    /**
     * Delete zero or more EntityBranches.
     * @param {EntityBranchDeleteManyArgs} args - Arguments to filter EntityBranches to delete.
     * @example
     * // Delete a few EntityBranches
     * const { count } = await prisma.entityBranch.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends EntityBranchDeleteManyArgs>(
      args?: SelectSubset<T, EntityBranchDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more EntityBranches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EntityBranchUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EntityBranches
     * const entityBranch = await prisma.entityBranch.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends EntityBranchUpdateManyArgs>(
      args: SelectSubset<T, EntityBranchUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one EntityBranch.
     * @param {EntityBranchUpsertArgs} args - Arguments to update or create a EntityBranch.
     * @example
     * // Update or create a EntityBranch
     * const entityBranch = await prisma.entityBranch.upsert({
     *   create: {
     *     // ... data to create a EntityBranch
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EntityBranch we want to update
     *   }
     * })
    **/
    upsert<T extends EntityBranchUpsertArgs>(
      args: SelectSubset<T, EntityBranchUpsertArgs>
    ): Prisma__EntityBranchClient<EntityBranchGetPayload<T>>

    /**
     * Count the number of EntityBranches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EntityBranchCountArgs} args - Arguments to filter EntityBranches to count.
     * @example
     * // Count the number of EntityBranches
     * const count = await prisma.entityBranch.count({
     *   where: {
     *     // ... the filter for the EntityBranches we want to count
     *   }
     * })
    **/
    count<T extends EntityBranchCountArgs>(
      args?: Subset<T, EntityBranchCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EntityBranchCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EntityBranch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EntityBranchAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EntityBranchAggregateArgs>(args: Subset<T, EntityBranchAggregateArgs>): PrismaPromise<GetEntityBranchAggregateType<T>>

    /**
     * Group by EntityBranch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EntityBranchGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EntityBranchGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EntityBranchGroupByArgs['orderBy'] }
        : { orderBy?: EntityBranchGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EntityBranchGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEntityBranchGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for EntityBranch.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__EntityBranchClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    entity<T extends EntityArgs= {}>(args?: Subset<T, EntityArgs>): Prisma__EntityClient<EntityGetPayload<T> | Null>;

    jobs<T extends JobFindManyArgs= {}>(args?: Subset<T, JobFindManyArgs>): PrismaPromise<Array<JobGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * EntityBranch base type for findUnique actions
   */
  export type EntityBranchFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the EntityBranch
     * 
    **/
    select?: EntityBranchSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EntityBranchInclude | null
    /**
     * Filter, which EntityBranch to fetch.
     * 
    **/
    where: EntityBranchWhereUniqueInput
  }

  /**
   * EntityBranch: findUnique
   */
  export interface EntityBranchFindUniqueArgs extends EntityBranchFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * EntityBranch findUniqueOrThrow
   */
  export type EntityBranchFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the EntityBranch
     * 
    **/
    select?: EntityBranchSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EntityBranchInclude | null
    /**
     * Filter, which EntityBranch to fetch.
     * 
    **/
    where: EntityBranchWhereUniqueInput
  }


  /**
   * EntityBranch base type for findFirst actions
   */
  export type EntityBranchFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the EntityBranch
     * 
    **/
    select?: EntityBranchSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EntityBranchInclude | null
    /**
     * Filter, which EntityBranch to fetch.
     * 
    **/
    where?: EntityBranchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EntityBranches to fetch.
     * 
    **/
    orderBy?: Enumerable<EntityBranchOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EntityBranches.
     * 
    **/
    cursor?: EntityBranchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EntityBranches from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EntityBranches.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EntityBranches.
     * 
    **/
    distinct?: Enumerable<EntityBranchScalarFieldEnum>
  }

  /**
   * EntityBranch: findFirst
   */
  export interface EntityBranchFindFirstArgs extends EntityBranchFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * EntityBranch findFirstOrThrow
   */
  export type EntityBranchFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the EntityBranch
     * 
    **/
    select?: EntityBranchSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EntityBranchInclude | null
    /**
     * Filter, which EntityBranch to fetch.
     * 
    **/
    where?: EntityBranchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EntityBranches to fetch.
     * 
    **/
    orderBy?: Enumerable<EntityBranchOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EntityBranches.
     * 
    **/
    cursor?: EntityBranchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EntityBranches from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EntityBranches.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EntityBranches.
     * 
    **/
    distinct?: Enumerable<EntityBranchScalarFieldEnum>
  }


  /**
   * EntityBranch findMany
   */
  export type EntityBranchFindManyArgs = {
    /**
     * Select specific fields to fetch from the EntityBranch
     * 
    **/
    select?: EntityBranchSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EntityBranchInclude | null
    /**
     * Filter, which EntityBranches to fetch.
     * 
    **/
    where?: EntityBranchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EntityBranches to fetch.
     * 
    **/
    orderBy?: Enumerable<EntityBranchOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EntityBranches.
     * 
    **/
    cursor?: EntityBranchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EntityBranches from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EntityBranches.
     * 
    **/
    skip?: number
    distinct?: Enumerable<EntityBranchScalarFieldEnum>
  }


  /**
   * EntityBranch create
   */
  export type EntityBranchCreateArgs = {
    /**
     * Select specific fields to fetch from the EntityBranch
     * 
    **/
    select?: EntityBranchSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EntityBranchInclude | null
    /**
     * The data needed to create a EntityBranch.
     * 
    **/
    data: XOR<EntityBranchCreateInput, EntityBranchUncheckedCreateInput>
  }


  /**
   * EntityBranch createMany
   */
  export type EntityBranchCreateManyArgs = {
    /**
     * The data used to create many EntityBranches.
     * 
    **/
    data: Enumerable<EntityBranchCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * EntityBranch update
   */
  export type EntityBranchUpdateArgs = {
    /**
     * Select specific fields to fetch from the EntityBranch
     * 
    **/
    select?: EntityBranchSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EntityBranchInclude | null
    /**
     * The data needed to update a EntityBranch.
     * 
    **/
    data: XOR<EntityBranchUpdateInput, EntityBranchUncheckedUpdateInput>
    /**
     * Choose, which EntityBranch to update.
     * 
    **/
    where: EntityBranchWhereUniqueInput
  }


  /**
   * EntityBranch updateMany
   */
  export type EntityBranchUpdateManyArgs = {
    /**
     * The data used to update EntityBranches.
     * 
    **/
    data: XOR<EntityBranchUpdateManyMutationInput, EntityBranchUncheckedUpdateManyInput>
    /**
     * Filter which EntityBranches to update
     * 
    **/
    where?: EntityBranchWhereInput
  }


  /**
   * EntityBranch upsert
   */
  export type EntityBranchUpsertArgs = {
    /**
     * Select specific fields to fetch from the EntityBranch
     * 
    **/
    select?: EntityBranchSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EntityBranchInclude | null
    /**
     * The filter to search for the EntityBranch to update in case it exists.
     * 
    **/
    where: EntityBranchWhereUniqueInput
    /**
     * In case the EntityBranch found by the `where` argument doesn't exist, create a new EntityBranch with this data.
     * 
    **/
    create: XOR<EntityBranchCreateInput, EntityBranchUncheckedCreateInput>
    /**
     * In case the EntityBranch was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<EntityBranchUpdateInput, EntityBranchUncheckedUpdateInput>
  }


  /**
   * EntityBranch delete
   */
  export type EntityBranchDeleteArgs = {
    /**
     * Select specific fields to fetch from the EntityBranch
     * 
    **/
    select?: EntityBranchSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EntityBranchInclude | null
    /**
     * Filter which EntityBranch to delete.
     * 
    **/
    where: EntityBranchWhereUniqueInput
  }


  /**
   * EntityBranch deleteMany
   */
  export type EntityBranchDeleteManyArgs = {
    /**
     * Filter which EntityBranches to delete
     * 
    **/
    where?: EntityBranchWhereInput
  }


  /**
   * EntityBranch without action
   */
  export type EntityBranchArgs = {
    /**
     * Select specific fields to fetch from the EntityBranch
     * 
    **/
    select?: EntityBranchSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EntityBranchInclude | null
  }



  /**
   * Model EntityDetail
   */


  export type AggregateEntityDetail = {
    _count: EntityDetailCountAggregateOutputType | null
    _avg: EntityDetailAvgAggregateOutputType | null
    _sum: EntityDetailSumAggregateOutputType | null
    _min: EntityDetailMinAggregateOutputType | null
    _max: EntityDetailMaxAggregateOutputType | null
  }

  export type EntityDetailAvgAggregateOutputType = {
    entity_id: number | null
    capital: number | null
    numberof_employees: number | null
    average_age: number | null
    foreign_capitalratio: number | null
    related_company: number | null
  }

  export type EntityDetailSumAggregateOutputType = {
    entity_id: number | null
    capital: number | null
    numberof_employees: number | null
    average_age: number | null
    foreign_capitalratio: number | null
    related_company: number | null
  }

  export type EntityDetailMinAggregateOutputType = {
    entity_detail_id: string | null
    entity_id: number | null
    establishment: Date | null
    capital: number | null
    numberof_employees: number | null
    representative_telephone: string | null
    representative: string | null
    average_age: number | null
    foreign_capitalratio: number | null
    homepage: string | null
    business_summary: string | null
    organizational_structure: string | null
    company_sales: string | null
    workplace_environment: string | null
    related_company: number | null
    recruitment_personname: string | null
    memo: string | null
    business_status: string | null
    created_at: Date | null
    updated_at: Date | null
    created_by: string | null
    updated_by: string | null
  }

  export type EntityDetailMaxAggregateOutputType = {
    entity_detail_id: string | null
    entity_id: number | null
    establishment: Date | null
    capital: number | null
    numberof_employees: number | null
    representative_telephone: string | null
    representative: string | null
    average_age: number | null
    foreign_capitalratio: number | null
    homepage: string | null
    business_summary: string | null
    organizational_structure: string | null
    company_sales: string | null
    workplace_environment: string | null
    related_company: number | null
    recruitment_personname: string | null
    memo: string | null
    business_status: string | null
    created_at: Date | null
    updated_at: Date | null
    created_by: string | null
    updated_by: string | null
  }

  export type EntityDetailCountAggregateOutputType = {
    entity_detail_id: number
    entity_id: number
    establishment: number
    capital: number
    numberof_employees: number
    business_performance: number
    representative_telephone: number
    representative: number
    average_age: number
    foreign_capitalratio: number
    homepage: number
    business_summary: number
    organizational_structure: number
    company_sales: number
    workplace_environment: number
    shareholder: number
    related_company: number
    recruitment_personname: number
    memo: number
    business_status: number
    created_at: number
    updated_at: number
    created_by: number
    updated_by: number
    _all: number
  }


  export type EntityDetailAvgAggregateInputType = {
    entity_id?: true
    capital?: true
    numberof_employees?: true
    average_age?: true
    foreign_capitalratio?: true
    related_company?: true
  }

  export type EntityDetailSumAggregateInputType = {
    entity_id?: true
    capital?: true
    numberof_employees?: true
    average_age?: true
    foreign_capitalratio?: true
    related_company?: true
  }

  export type EntityDetailMinAggregateInputType = {
    entity_detail_id?: true
    entity_id?: true
    establishment?: true
    capital?: true
    numberof_employees?: true
    representative_telephone?: true
    representative?: true
    average_age?: true
    foreign_capitalratio?: true
    homepage?: true
    business_summary?: true
    organizational_structure?: true
    company_sales?: true
    workplace_environment?: true
    related_company?: true
    recruitment_personname?: true
    memo?: true
    business_status?: true
    created_at?: true
    updated_at?: true
    created_by?: true
    updated_by?: true
  }

  export type EntityDetailMaxAggregateInputType = {
    entity_detail_id?: true
    entity_id?: true
    establishment?: true
    capital?: true
    numberof_employees?: true
    representative_telephone?: true
    representative?: true
    average_age?: true
    foreign_capitalratio?: true
    homepage?: true
    business_summary?: true
    organizational_structure?: true
    company_sales?: true
    workplace_environment?: true
    related_company?: true
    recruitment_personname?: true
    memo?: true
    business_status?: true
    created_at?: true
    updated_at?: true
    created_by?: true
    updated_by?: true
  }

  export type EntityDetailCountAggregateInputType = {
    entity_detail_id?: true
    entity_id?: true
    establishment?: true
    capital?: true
    numberof_employees?: true
    business_performance?: true
    representative_telephone?: true
    representative?: true
    average_age?: true
    foreign_capitalratio?: true
    homepage?: true
    business_summary?: true
    organizational_structure?: true
    company_sales?: true
    workplace_environment?: true
    shareholder?: true
    related_company?: true
    recruitment_personname?: true
    memo?: true
    business_status?: true
    created_at?: true
    updated_at?: true
    created_by?: true
    updated_by?: true
    _all?: true
  }

  export type EntityDetailAggregateArgs = {
    /**
     * Filter which EntityDetail to aggregate.
     * 
    **/
    where?: EntityDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EntityDetails to fetch.
     * 
    **/
    orderBy?: Enumerable<EntityDetailOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: EntityDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EntityDetails from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EntityDetails.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EntityDetails
    **/
    _count?: true | EntityDetailCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EntityDetailAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EntityDetailSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EntityDetailMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EntityDetailMaxAggregateInputType
  }

  export type GetEntityDetailAggregateType<T extends EntityDetailAggregateArgs> = {
        [P in keyof T & keyof AggregateEntityDetail]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEntityDetail[P]>
      : GetScalarType<T[P], AggregateEntityDetail[P]>
  }




  export type EntityDetailGroupByArgs = {
    where?: EntityDetailWhereInput
    orderBy?: Enumerable<EntityDetailOrderByWithAggregationInput>
    by: Array<EntityDetailScalarFieldEnum>
    having?: EntityDetailScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EntityDetailCountAggregateInputType | true
    _avg?: EntityDetailAvgAggregateInputType
    _sum?: EntityDetailSumAggregateInputType
    _min?: EntityDetailMinAggregateInputType
    _max?: EntityDetailMaxAggregateInputType
  }


  export type EntityDetailGroupByOutputType = {
    entity_detail_id: string
    entity_id: number | null
    establishment: Date | null
    capital: number | null
    numberof_employees: number | null
    business_performance: JsonValue | null
    representative_telephone: string | null
    representative: string | null
    average_age: number | null
    foreign_capitalratio: number | null
    homepage: string | null
    business_summary: string | null
    organizational_structure: string | null
    company_sales: string | null
    workplace_environment: string | null
    shareholder: JsonValue | null
    related_company: number | null
    recruitment_personname: string | null
    memo: string | null
    business_status: string | null
    created_at: Date
    updated_at: Date
    created_by: string | null
    updated_by: string | null
    _count: EntityDetailCountAggregateOutputType | null
    _avg: EntityDetailAvgAggregateOutputType | null
    _sum: EntityDetailSumAggregateOutputType | null
    _min: EntityDetailMinAggregateOutputType | null
    _max: EntityDetailMaxAggregateOutputType | null
  }

  type GetEntityDetailGroupByPayload<T extends EntityDetailGroupByArgs> = PrismaPromise<
    Array<
      PickArray<EntityDetailGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EntityDetailGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EntityDetailGroupByOutputType[P]>
            : GetScalarType<T[P], EntityDetailGroupByOutputType[P]>
        }
      >
    >


  export type EntityDetailSelect = {
    entity_detail_id?: boolean
    entity_id?: boolean
    entity?: boolean | EntityArgs
    establishment?: boolean
    capital?: boolean
    numberof_employees?: boolean
    business_performance?: boolean
    representative_telephone?: boolean
    representative?: boolean
    average_age?: boolean
    foreign_capitalratio?: boolean
    homepage?: boolean
    business_summary?: boolean
    organizational_structure?: boolean
    company_sales?: boolean
    workplace_environment?: boolean
    shareholder?: boolean
    related_company?: boolean
    recruitment_personname?: boolean
    memo?: boolean
    business_status?: boolean
    created_at?: boolean
    updated_at?: boolean
    created_by?: boolean
    updated_by?: boolean
  }


  export type EntityDetailInclude = {
    entity?: boolean | EntityArgs
  } 

  export type EntityDetailGetPayload<S extends boolean | null | undefined | EntityDetailArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? EntityDetail :
    S extends undefined ? never :
    S extends { include: any } & (EntityDetailArgs | EntityDetailFindManyArgs)
    ? EntityDetail  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'entity' ? EntityGetPayload<S['include'][P]> | null :  never
  } 
    : S extends { select: any } & (EntityDetailArgs | EntityDetailFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'entity' ? EntityGetPayload<S['select'][P]> | null :  P extends keyof EntityDetail ? EntityDetail[P] : never
  } 
      : EntityDetail


  type EntityDetailCountArgs = Merge<
    Omit<EntityDetailFindManyArgs, 'select' | 'include'> & {
      select?: EntityDetailCountAggregateInputType | true
    }
  >

  export interface EntityDetailDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one EntityDetail that matches the filter.
     * @param {EntityDetailFindUniqueArgs} args - Arguments to find a EntityDetail
     * @example
     * // Get one EntityDetail
     * const entityDetail = await prisma.entityDetail.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends EntityDetailFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, EntityDetailFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'EntityDetail'> extends True ? Prisma__EntityDetailClient<EntityDetailGetPayload<T>> : Prisma__EntityDetailClient<EntityDetailGetPayload<T> | null, null>

    /**
     * Find one EntityDetail that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {EntityDetailFindUniqueOrThrowArgs} args - Arguments to find a EntityDetail
     * @example
     * // Get one EntityDetail
     * const entityDetail = await prisma.entityDetail.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends EntityDetailFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, EntityDetailFindUniqueOrThrowArgs>
    ): Prisma__EntityDetailClient<EntityDetailGetPayload<T>>

    /**
     * Find the first EntityDetail that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EntityDetailFindFirstArgs} args - Arguments to find a EntityDetail
     * @example
     * // Get one EntityDetail
     * const entityDetail = await prisma.entityDetail.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends EntityDetailFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, EntityDetailFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'EntityDetail'> extends True ? Prisma__EntityDetailClient<EntityDetailGetPayload<T>> : Prisma__EntityDetailClient<EntityDetailGetPayload<T> | null, null>

    /**
     * Find the first EntityDetail that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EntityDetailFindFirstOrThrowArgs} args - Arguments to find a EntityDetail
     * @example
     * // Get one EntityDetail
     * const entityDetail = await prisma.entityDetail.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends EntityDetailFindFirstOrThrowArgs>(
      args?: SelectSubset<T, EntityDetailFindFirstOrThrowArgs>
    ): Prisma__EntityDetailClient<EntityDetailGetPayload<T>>

    /**
     * Find zero or more EntityDetails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EntityDetailFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EntityDetails
     * const entityDetails = await prisma.entityDetail.findMany()
     * 
     * // Get first 10 EntityDetails
     * const entityDetails = await prisma.entityDetail.findMany({ take: 10 })
     * 
     * // Only select the `entity_detail_id`
     * const entityDetailWithEntity_detail_idOnly = await prisma.entityDetail.findMany({ select: { entity_detail_id: true } })
     * 
    **/
    findMany<T extends EntityDetailFindManyArgs>(
      args?: SelectSubset<T, EntityDetailFindManyArgs>
    ): PrismaPromise<Array<EntityDetailGetPayload<T>>>

    /**
     * Create a EntityDetail.
     * @param {EntityDetailCreateArgs} args - Arguments to create a EntityDetail.
     * @example
     * // Create one EntityDetail
     * const EntityDetail = await prisma.entityDetail.create({
     *   data: {
     *     // ... data to create a EntityDetail
     *   }
     * })
     * 
    **/
    create<T extends EntityDetailCreateArgs>(
      args: SelectSubset<T, EntityDetailCreateArgs>
    ): Prisma__EntityDetailClient<EntityDetailGetPayload<T>>

    /**
     * Create many EntityDetails.
     *     @param {EntityDetailCreateManyArgs} args - Arguments to create many EntityDetails.
     *     @example
     *     // Create many EntityDetails
     *     const entityDetail = await prisma.entityDetail.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends EntityDetailCreateManyArgs>(
      args?: SelectSubset<T, EntityDetailCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a EntityDetail.
     * @param {EntityDetailDeleteArgs} args - Arguments to delete one EntityDetail.
     * @example
     * // Delete one EntityDetail
     * const EntityDetail = await prisma.entityDetail.delete({
     *   where: {
     *     // ... filter to delete one EntityDetail
     *   }
     * })
     * 
    **/
    delete<T extends EntityDetailDeleteArgs>(
      args: SelectSubset<T, EntityDetailDeleteArgs>
    ): Prisma__EntityDetailClient<EntityDetailGetPayload<T>>

    /**
     * Update one EntityDetail.
     * @param {EntityDetailUpdateArgs} args - Arguments to update one EntityDetail.
     * @example
     * // Update one EntityDetail
     * const entityDetail = await prisma.entityDetail.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends EntityDetailUpdateArgs>(
      args: SelectSubset<T, EntityDetailUpdateArgs>
    ): Prisma__EntityDetailClient<EntityDetailGetPayload<T>>

    /**
     * Delete zero or more EntityDetails.
     * @param {EntityDetailDeleteManyArgs} args - Arguments to filter EntityDetails to delete.
     * @example
     * // Delete a few EntityDetails
     * const { count } = await prisma.entityDetail.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends EntityDetailDeleteManyArgs>(
      args?: SelectSubset<T, EntityDetailDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more EntityDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EntityDetailUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EntityDetails
     * const entityDetail = await prisma.entityDetail.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends EntityDetailUpdateManyArgs>(
      args: SelectSubset<T, EntityDetailUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one EntityDetail.
     * @param {EntityDetailUpsertArgs} args - Arguments to update or create a EntityDetail.
     * @example
     * // Update or create a EntityDetail
     * const entityDetail = await prisma.entityDetail.upsert({
     *   create: {
     *     // ... data to create a EntityDetail
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EntityDetail we want to update
     *   }
     * })
    **/
    upsert<T extends EntityDetailUpsertArgs>(
      args: SelectSubset<T, EntityDetailUpsertArgs>
    ): Prisma__EntityDetailClient<EntityDetailGetPayload<T>>

    /**
     * Count the number of EntityDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EntityDetailCountArgs} args - Arguments to filter EntityDetails to count.
     * @example
     * // Count the number of EntityDetails
     * const count = await prisma.entityDetail.count({
     *   where: {
     *     // ... the filter for the EntityDetails we want to count
     *   }
     * })
    **/
    count<T extends EntityDetailCountArgs>(
      args?: Subset<T, EntityDetailCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EntityDetailCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EntityDetail.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EntityDetailAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EntityDetailAggregateArgs>(args: Subset<T, EntityDetailAggregateArgs>): PrismaPromise<GetEntityDetailAggregateType<T>>

    /**
     * Group by EntityDetail.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EntityDetailGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EntityDetailGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EntityDetailGroupByArgs['orderBy'] }
        : { orderBy?: EntityDetailGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EntityDetailGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEntityDetailGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for EntityDetail.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__EntityDetailClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    entity<T extends EntityArgs= {}>(args?: Subset<T, EntityArgs>): Prisma__EntityClient<EntityGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * EntityDetail base type for findUnique actions
   */
  export type EntityDetailFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the EntityDetail
     * 
    **/
    select?: EntityDetailSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EntityDetailInclude | null
    /**
     * Filter, which EntityDetail to fetch.
     * 
    **/
    where: EntityDetailWhereUniqueInput
  }

  /**
   * EntityDetail: findUnique
   */
  export interface EntityDetailFindUniqueArgs extends EntityDetailFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * EntityDetail findUniqueOrThrow
   */
  export type EntityDetailFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the EntityDetail
     * 
    **/
    select?: EntityDetailSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EntityDetailInclude | null
    /**
     * Filter, which EntityDetail to fetch.
     * 
    **/
    where: EntityDetailWhereUniqueInput
  }


  /**
   * EntityDetail base type for findFirst actions
   */
  export type EntityDetailFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the EntityDetail
     * 
    **/
    select?: EntityDetailSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EntityDetailInclude | null
    /**
     * Filter, which EntityDetail to fetch.
     * 
    **/
    where?: EntityDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EntityDetails to fetch.
     * 
    **/
    orderBy?: Enumerable<EntityDetailOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EntityDetails.
     * 
    **/
    cursor?: EntityDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EntityDetails from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EntityDetails.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EntityDetails.
     * 
    **/
    distinct?: Enumerable<EntityDetailScalarFieldEnum>
  }

  /**
   * EntityDetail: findFirst
   */
  export interface EntityDetailFindFirstArgs extends EntityDetailFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * EntityDetail findFirstOrThrow
   */
  export type EntityDetailFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the EntityDetail
     * 
    **/
    select?: EntityDetailSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EntityDetailInclude | null
    /**
     * Filter, which EntityDetail to fetch.
     * 
    **/
    where?: EntityDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EntityDetails to fetch.
     * 
    **/
    orderBy?: Enumerable<EntityDetailOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EntityDetails.
     * 
    **/
    cursor?: EntityDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EntityDetails from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EntityDetails.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EntityDetails.
     * 
    **/
    distinct?: Enumerable<EntityDetailScalarFieldEnum>
  }


  /**
   * EntityDetail findMany
   */
  export type EntityDetailFindManyArgs = {
    /**
     * Select specific fields to fetch from the EntityDetail
     * 
    **/
    select?: EntityDetailSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EntityDetailInclude | null
    /**
     * Filter, which EntityDetails to fetch.
     * 
    **/
    where?: EntityDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EntityDetails to fetch.
     * 
    **/
    orderBy?: Enumerable<EntityDetailOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EntityDetails.
     * 
    **/
    cursor?: EntityDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EntityDetails from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EntityDetails.
     * 
    **/
    skip?: number
    distinct?: Enumerable<EntityDetailScalarFieldEnum>
  }


  /**
   * EntityDetail create
   */
  export type EntityDetailCreateArgs = {
    /**
     * Select specific fields to fetch from the EntityDetail
     * 
    **/
    select?: EntityDetailSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EntityDetailInclude | null
    /**
     * The data needed to create a EntityDetail.
     * 
    **/
    data: XOR<EntityDetailCreateInput, EntityDetailUncheckedCreateInput>
  }


  /**
   * EntityDetail createMany
   */
  export type EntityDetailCreateManyArgs = {
    /**
     * The data used to create many EntityDetails.
     * 
    **/
    data: Enumerable<EntityDetailCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * EntityDetail update
   */
  export type EntityDetailUpdateArgs = {
    /**
     * Select specific fields to fetch from the EntityDetail
     * 
    **/
    select?: EntityDetailSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EntityDetailInclude | null
    /**
     * The data needed to update a EntityDetail.
     * 
    **/
    data: XOR<EntityDetailUpdateInput, EntityDetailUncheckedUpdateInput>
    /**
     * Choose, which EntityDetail to update.
     * 
    **/
    where: EntityDetailWhereUniqueInput
  }


  /**
   * EntityDetail updateMany
   */
  export type EntityDetailUpdateManyArgs = {
    /**
     * The data used to update EntityDetails.
     * 
    **/
    data: XOR<EntityDetailUpdateManyMutationInput, EntityDetailUncheckedUpdateManyInput>
    /**
     * Filter which EntityDetails to update
     * 
    **/
    where?: EntityDetailWhereInput
  }


  /**
   * EntityDetail upsert
   */
  export type EntityDetailUpsertArgs = {
    /**
     * Select specific fields to fetch from the EntityDetail
     * 
    **/
    select?: EntityDetailSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EntityDetailInclude | null
    /**
     * The filter to search for the EntityDetail to update in case it exists.
     * 
    **/
    where: EntityDetailWhereUniqueInput
    /**
     * In case the EntityDetail found by the `where` argument doesn't exist, create a new EntityDetail with this data.
     * 
    **/
    create: XOR<EntityDetailCreateInput, EntityDetailUncheckedCreateInput>
    /**
     * In case the EntityDetail was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<EntityDetailUpdateInput, EntityDetailUncheckedUpdateInput>
  }


  /**
   * EntityDetail delete
   */
  export type EntityDetailDeleteArgs = {
    /**
     * Select specific fields to fetch from the EntityDetail
     * 
    **/
    select?: EntityDetailSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EntityDetailInclude | null
    /**
     * Filter which EntityDetail to delete.
     * 
    **/
    where: EntityDetailWhereUniqueInput
  }


  /**
   * EntityDetail deleteMany
   */
  export type EntityDetailDeleteManyArgs = {
    /**
     * Filter which EntityDetails to delete
     * 
    **/
    where?: EntityDetailWhereInput
  }


  /**
   * EntityDetail without action
   */
  export type EntityDetailArgs = {
    /**
     * Select specific fields to fetch from the EntityDetail
     * 
    **/
    select?: EntityDetailSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EntityDetailInclude | null
  }



  /**
   * Model Files
   */


  export type AggregateFiles = {
    _count: FilesCountAggregateOutputType | null
    _min: FilesMinAggregateOutputType | null
    _max: FilesMaxAggregateOutputType | null
  }

  export type FilesMinAggregateOutputType = {
    file_id: string | null
    file_name: string | null
    target_id: string | null
    file_path: string | null
    file_type: FileType | null
    fiel_source: FileSource | null
    created_at: Date | null
    created_by: string | null
  }

  export type FilesMaxAggregateOutputType = {
    file_id: string | null
    file_name: string | null
    target_id: string | null
    file_path: string | null
    file_type: FileType | null
    fiel_source: FileSource | null
    created_at: Date | null
    created_by: string | null
  }

  export type FilesCountAggregateOutputType = {
    file_id: number
    file_name: number
    target_id: number
    file_path: number
    file_type: number
    fiel_source: number
    created_at: number
    created_by: number
    _all: number
  }


  export type FilesMinAggregateInputType = {
    file_id?: true
    file_name?: true
    target_id?: true
    file_path?: true
    file_type?: true
    fiel_source?: true
    created_at?: true
    created_by?: true
  }

  export type FilesMaxAggregateInputType = {
    file_id?: true
    file_name?: true
    target_id?: true
    file_path?: true
    file_type?: true
    fiel_source?: true
    created_at?: true
    created_by?: true
  }

  export type FilesCountAggregateInputType = {
    file_id?: true
    file_name?: true
    target_id?: true
    file_path?: true
    file_type?: true
    fiel_source?: true
    created_at?: true
    created_by?: true
    _all?: true
  }

  export type FilesAggregateArgs = {
    /**
     * Filter which Files to aggregate.
     * 
    **/
    where?: FilesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Files to fetch.
     * 
    **/
    orderBy?: Enumerable<FilesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: FilesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Files from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Files.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Files
    **/
    _count?: true | FilesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FilesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FilesMaxAggregateInputType
  }

  export type GetFilesAggregateType<T extends FilesAggregateArgs> = {
        [P in keyof T & keyof AggregateFiles]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFiles[P]>
      : GetScalarType<T[P], AggregateFiles[P]>
  }




  export type FilesGroupByArgs = {
    where?: FilesWhereInput
    orderBy?: Enumerable<FilesOrderByWithAggregationInput>
    by: Array<FilesScalarFieldEnum>
    having?: FilesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FilesCountAggregateInputType | true
    _min?: FilesMinAggregateInputType
    _max?: FilesMaxAggregateInputType
  }


  export type FilesGroupByOutputType = {
    file_id: string
    file_name: string
    target_id: string
    file_path: string
    file_type: FileType
    fiel_source: FileSource
    created_at: Date
    created_by: string
    _count: FilesCountAggregateOutputType | null
    _min: FilesMinAggregateOutputType | null
    _max: FilesMaxAggregateOutputType | null
  }

  type GetFilesGroupByPayload<T extends FilesGroupByArgs> = PrismaPromise<
    Array<
      PickArray<FilesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FilesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FilesGroupByOutputType[P]>
            : GetScalarType<T[P], FilesGroupByOutputType[P]>
        }
      >
    >


  export type FilesSelect = {
    file_id?: boolean
    file_name?: boolean
    target_id?: boolean
    file_path?: boolean
    file_type?: boolean
    fiel_source?: boolean
    created_at?: boolean
    created_by?: boolean
  }


  export type FilesGetPayload<S extends boolean | null | undefined | FilesArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Files :
    S extends undefined ? never :
    S extends { include: any } & (FilesArgs | FilesFindManyArgs)
    ? Files 
    : S extends { select: any } & (FilesArgs | FilesFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof Files ? Files[P] : never
  } 
      : Files


  type FilesCountArgs = Merge<
    Omit<FilesFindManyArgs, 'select' | 'include'> & {
      select?: FilesCountAggregateInputType | true
    }
  >

  export interface FilesDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Files that matches the filter.
     * @param {FilesFindUniqueArgs} args - Arguments to find a Files
     * @example
     * // Get one Files
     * const files = await prisma.files.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends FilesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, FilesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Files'> extends True ? Prisma__FilesClient<FilesGetPayload<T>> : Prisma__FilesClient<FilesGetPayload<T> | null, null>

    /**
     * Find one Files that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {FilesFindUniqueOrThrowArgs} args - Arguments to find a Files
     * @example
     * // Get one Files
     * const files = await prisma.files.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends FilesFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, FilesFindUniqueOrThrowArgs>
    ): Prisma__FilesClient<FilesGetPayload<T>>

    /**
     * Find the first Files that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FilesFindFirstArgs} args - Arguments to find a Files
     * @example
     * // Get one Files
     * const files = await prisma.files.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends FilesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, FilesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Files'> extends True ? Prisma__FilesClient<FilesGetPayload<T>> : Prisma__FilesClient<FilesGetPayload<T> | null, null>

    /**
     * Find the first Files that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FilesFindFirstOrThrowArgs} args - Arguments to find a Files
     * @example
     * // Get one Files
     * const files = await prisma.files.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends FilesFindFirstOrThrowArgs>(
      args?: SelectSubset<T, FilesFindFirstOrThrowArgs>
    ): Prisma__FilesClient<FilesGetPayload<T>>

    /**
     * Find zero or more Files that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FilesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Files
     * const files = await prisma.files.findMany()
     * 
     * // Get first 10 Files
     * const files = await prisma.files.findMany({ take: 10 })
     * 
     * // Only select the `file_id`
     * const filesWithFile_idOnly = await prisma.files.findMany({ select: { file_id: true } })
     * 
    **/
    findMany<T extends FilesFindManyArgs>(
      args?: SelectSubset<T, FilesFindManyArgs>
    ): PrismaPromise<Array<FilesGetPayload<T>>>

    /**
     * Create a Files.
     * @param {FilesCreateArgs} args - Arguments to create a Files.
     * @example
     * // Create one Files
     * const Files = await prisma.files.create({
     *   data: {
     *     // ... data to create a Files
     *   }
     * })
     * 
    **/
    create<T extends FilesCreateArgs>(
      args: SelectSubset<T, FilesCreateArgs>
    ): Prisma__FilesClient<FilesGetPayload<T>>

    /**
     * Create many Files.
     *     @param {FilesCreateManyArgs} args - Arguments to create many Files.
     *     @example
     *     // Create many Files
     *     const files = await prisma.files.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends FilesCreateManyArgs>(
      args?: SelectSubset<T, FilesCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Files.
     * @param {FilesDeleteArgs} args - Arguments to delete one Files.
     * @example
     * // Delete one Files
     * const Files = await prisma.files.delete({
     *   where: {
     *     // ... filter to delete one Files
     *   }
     * })
     * 
    **/
    delete<T extends FilesDeleteArgs>(
      args: SelectSubset<T, FilesDeleteArgs>
    ): Prisma__FilesClient<FilesGetPayload<T>>

    /**
     * Update one Files.
     * @param {FilesUpdateArgs} args - Arguments to update one Files.
     * @example
     * // Update one Files
     * const files = await prisma.files.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends FilesUpdateArgs>(
      args: SelectSubset<T, FilesUpdateArgs>
    ): Prisma__FilesClient<FilesGetPayload<T>>

    /**
     * Delete zero or more Files.
     * @param {FilesDeleteManyArgs} args - Arguments to filter Files to delete.
     * @example
     * // Delete a few Files
     * const { count } = await prisma.files.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends FilesDeleteManyArgs>(
      args?: SelectSubset<T, FilesDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Files.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FilesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Files
     * const files = await prisma.files.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends FilesUpdateManyArgs>(
      args: SelectSubset<T, FilesUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Files.
     * @param {FilesUpsertArgs} args - Arguments to update or create a Files.
     * @example
     * // Update or create a Files
     * const files = await prisma.files.upsert({
     *   create: {
     *     // ... data to create a Files
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Files we want to update
     *   }
     * })
    **/
    upsert<T extends FilesUpsertArgs>(
      args: SelectSubset<T, FilesUpsertArgs>
    ): Prisma__FilesClient<FilesGetPayload<T>>

    /**
     * Count the number of Files.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FilesCountArgs} args - Arguments to filter Files to count.
     * @example
     * // Count the number of Files
     * const count = await prisma.files.count({
     *   where: {
     *     // ... the filter for the Files we want to count
     *   }
     * })
    **/
    count<T extends FilesCountArgs>(
      args?: Subset<T, FilesCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FilesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Files.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FilesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FilesAggregateArgs>(args: Subset<T, FilesAggregateArgs>): PrismaPromise<GetFilesAggregateType<T>>

    /**
     * Group by Files.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FilesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FilesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FilesGroupByArgs['orderBy'] }
        : { orderBy?: FilesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FilesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFilesGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Files.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__FilesClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Files base type for findUnique actions
   */
  export type FilesFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Files
     * 
    **/
    select?: FilesSelect | null
    /**
     * Filter, which Files to fetch.
     * 
    **/
    where: FilesWhereUniqueInput
  }

  /**
   * Files: findUnique
   */
  export interface FilesFindUniqueArgs extends FilesFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Files findUniqueOrThrow
   */
  export type FilesFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Files
     * 
    **/
    select?: FilesSelect | null
    /**
     * Filter, which Files to fetch.
     * 
    **/
    where: FilesWhereUniqueInput
  }


  /**
   * Files base type for findFirst actions
   */
  export type FilesFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Files
     * 
    **/
    select?: FilesSelect | null
    /**
     * Filter, which Files to fetch.
     * 
    **/
    where?: FilesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Files to fetch.
     * 
    **/
    orderBy?: Enumerable<FilesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Files.
     * 
    **/
    cursor?: FilesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Files from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Files.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Files.
     * 
    **/
    distinct?: Enumerable<FilesScalarFieldEnum>
  }

  /**
   * Files: findFirst
   */
  export interface FilesFindFirstArgs extends FilesFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Files findFirstOrThrow
   */
  export type FilesFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Files
     * 
    **/
    select?: FilesSelect | null
    /**
     * Filter, which Files to fetch.
     * 
    **/
    where?: FilesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Files to fetch.
     * 
    **/
    orderBy?: Enumerable<FilesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Files.
     * 
    **/
    cursor?: FilesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Files from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Files.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Files.
     * 
    **/
    distinct?: Enumerable<FilesScalarFieldEnum>
  }


  /**
   * Files findMany
   */
  export type FilesFindManyArgs = {
    /**
     * Select specific fields to fetch from the Files
     * 
    **/
    select?: FilesSelect | null
    /**
     * Filter, which Files to fetch.
     * 
    **/
    where?: FilesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Files to fetch.
     * 
    **/
    orderBy?: Enumerable<FilesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Files.
     * 
    **/
    cursor?: FilesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Files from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Files.
     * 
    **/
    skip?: number
    distinct?: Enumerable<FilesScalarFieldEnum>
  }


  /**
   * Files create
   */
  export type FilesCreateArgs = {
    /**
     * Select specific fields to fetch from the Files
     * 
    **/
    select?: FilesSelect | null
    /**
     * The data needed to create a Files.
     * 
    **/
    data: XOR<FilesCreateInput, FilesUncheckedCreateInput>
  }


  /**
   * Files createMany
   */
  export type FilesCreateManyArgs = {
    /**
     * The data used to create many Files.
     * 
    **/
    data: Enumerable<FilesCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Files update
   */
  export type FilesUpdateArgs = {
    /**
     * Select specific fields to fetch from the Files
     * 
    **/
    select?: FilesSelect | null
    /**
     * The data needed to update a Files.
     * 
    **/
    data: XOR<FilesUpdateInput, FilesUncheckedUpdateInput>
    /**
     * Choose, which Files to update.
     * 
    **/
    where: FilesWhereUniqueInput
  }


  /**
   * Files updateMany
   */
  export type FilesUpdateManyArgs = {
    /**
     * The data used to update Files.
     * 
    **/
    data: XOR<FilesUpdateManyMutationInput, FilesUncheckedUpdateManyInput>
    /**
     * Filter which Files to update
     * 
    **/
    where?: FilesWhereInput
  }


  /**
   * Files upsert
   */
  export type FilesUpsertArgs = {
    /**
     * Select specific fields to fetch from the Files
     * 
    **/
    select?: FilesSelect | null
    /**
     * The filter to search for the Files to update in case it exists.
     * 
    **/
    where: FilesWhereUniqueInput
    /**
     * In case the Files found by the `where` argument doesn't exist, create a new Files with this data.
     * 
    **/
    create: XOR<FilesCreateInput, FilesUncheckedCreateInput>
    /**
     * In case the Files was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<FilesUpdateInput, FilesUncheckedUpdateInput>
  }


  /**
   * Files delete
   */
  export type FilesDeleteArgs = {
    /**
     * Select specific fields to fetch from the Files
     * 
    **/
    select?: FilesSelect | null
    /**
     * Filter which Files to delete.
     * 
    **/
    where: FilesWhereUniqueInput
  }


  /**
   * Files deleteMany
   */
  export type FilesDeleteManyArgs = {
    /**
     * Filter which Files to delete
     * 
    **/
    where?: FilesWhereInput
  }


  /**
   * Files without action
   */
  export type FilesArgs = {
    /**
     * Select specific fields to fetch from the Files
     * 
    **/
    select?: FilesSelect | null
  }



  /**
   * Model Inquiry
   */


  export type AggregateInquiry = {
    _count: InquiryCountAggregateOutputType | null
    _avg: InquiryAvgAggregateOutputType | null
    _sum: InquirySumAggregateOutputType | null
    _min: InquiryMinAggregateOutputType | null
    _max: InquiryMaxAggregateOutputType | null
  }

  export type InquiryAvgAggregateOutputType = {
    entity_id: number | null
  }

  export type InquirySumAggregateOutputType = {
    entity_id: number | null
  }

  export type InquiryMinAggregateOutputType = {
    inquire_id: string | null
    parent_id: string | null
    fromuser_id: string | null
    entity_id: number | null
    assigned_user_id: string | null
    subject: string | null
    body: string | null
    inquiry_status: InquiryStatus | null
    is_read: boolean | null
    is_answer: boolean | null
    created_at: Date | null
    updated_at: Date | null
    created_by: string | null
  }

  export type InquiryMaxAggregateOutputType = {
    inquire_id: string | null
    parent_id: string | null
    fromuser_id: string | null
    entity_id: number | null
    assigned_user_id: string | null
    subject: string | null
    body: string | null
    inquiry_status: InquiryStatus | null
    is_read: boolean | null
    is_answer: boolean | null
    created_at: Date | null
    updated_at: Date | null
    created_by: string | null
  }

  export type InquiryCountAggregateOutputType = {
    inquire_id: number
    parent_id: number
    fromuser_id: number
    entity_id: number
    assigned_user_id: number
    subject: number
    body: number
    inquiry_status: number
    is_read: number
    is_answer: number
    created_at: number
    updated_at: number
    created_by: number
    _all: number
  }


  export type InquiryAvgAggregateInputType = {
    entity_id?: true
  }

  export type InquirySumAggregateInputType = {
    entity_id?: true
  }

  export type InquiryMinAggregateInputType = {
    inquire_id?: true
    parent_id?: true
    fromuser_id?: true
    entity_id?: true
    assigned_user_id?: true
    subject?: true
    body?: true
    inquiry_status?: true
    is_read?: true
    is_answer?: true
    created_at?: true
    updated_at?: true
    created_by?: true
  }

  export type InquiryMaxAggregateInputType = {
    inquire_id?: true
    parent_id?: true
    fromuser_id?: true
    entity_id?: true
    assigned_user_id?: true
    subject?: true
    body?: true
    inquiry_status?: true
    is_read?: true
    is_answer?: true
    created_at?: true
    updated_at?: true
    created_by?: true
  }

  export type InquiryCountAggregateInputType = {
    inquire_id?: true
    parent_id?: true
    fromuser_id?: true
    entity_id?: true
    assigned_user_id?: true
    subject?: true
    body?: true
    inquiry_status?: true
    is_read?: true
    is_answer?: true
    created_at?: true
    updated_at?: true
    created_by?: true
    _all?: true
  }

  export type InquiryAggregateArgs = {
    /**
     * Filter which Inquiry to aggregate.
     * 
    **/
    where?: InquiryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Inquiries to fetch.
     * 
    **/
    orderBy?: Enumerable<InquiryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: InquiryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Inquiries from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Inquiries.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Inquiries
    **/
    _count?: true | InquiryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InquiryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InquirySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InquiryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InquiryMaxAggregateInputType
  }

  export type GetInquiryAggregateType<T extends InquiryAggregateArgs> = {
        [P in keyof T & keyof AggregateInquiry]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInquiry[P]>
      : GetScalarType<T[P], AggregateInquiry[P]>
  }




  export type InquiryGroupByArgs = {
    where?: InquiryWhereInput
    orderBy?: Enumerable<InquiryOrderByWithAggregationInput>
    by: Array<InquiryScalarFieldEnum>
    having?: InquiryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InquiryCountAggregateInputType | true
    _avg?: InquiryAvgAggregateInputType
    _sum?: InquirySumAggregateInputType
    _min?: InquiryMinAggregateInputType
    _max?: InquiryMaxAggregateInputType
  }


  export type InquiryGroupByOutputType = {
    inquire_id: string
    parent_id: string | null
    fromuser_id: string | null
    entity_id: number | null
    assigned_user_id: string | null
    subject: string
    body: string
    inquiry_status: InquiryStatus | null
    is_read: boolean
    is_answer: boolean
    created_at: Date
    updated_at: Date
    created_by: string | null
    _count: InquiryCountAggregateOutputType | null
    _avg: InquiryAvgAggregateOutputType | null
    _sum: InquirySumAggregateOutputType | null
    _min: InquiryMinAggregateOutputType | null
    _max: InquiryMaxAggregateOutputType | null
  }

  type GetInquiryGroupByPayload<T extends InquiryGroupByArgs> = PrismaPromise<
    Array<
      PickArray<InquiryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InquiryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InquiryGroupByOutputType[P]>
            : GetScalarType<T[P], InquiryGroupByOutputType[P]>
        }
      >
    >


  export type InquirySelect = {
    inquire_id?: boolean
    parent_id?: boolean
    fromuser_id?: boolean
    fromuser?: boolean | UserArgs
    entity_id?: boolean
    entity?: boolean | EntityArgs
    assigned_user_id?: boolean
    assignUser?: boolean | UserArgs
    subject?: boolean
    body?: boolean
    inquiry_status?: boolean
    is_read?: boolean
    is_answer?: boolean
    created_at?: boolean
    updated_at?: boolean
    created_by?: boolean
  }


  export type InquiryInclude = {
    fromuser?: boolean | UserArgs
    entity?: boolean | EntityArgs
    assignUser?: boolean | UserArgs
  } 

  export type InquiryGetPayload<S extends boolean | null | undefined | InquiryArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Inquiry :
    S extends undefined ? never :
    S extends { include: any } & (InquiryArgs | InquiryFindManyArgs)
    ? Inquiry  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'fromuser' ? UserGetPayload<S['include'][P]> | null :
        P extends 'entity' ? EntityGetPayload<S['include'][P]> | null :
        P extends 'assignUser' ? UserGetPayload<S['include'][P]> | null :  never
  } 
    : S extends { select: any } & (InquiryArgs | InquiryFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'fromuser' ? UserGetPayload<S['select'][P]> | null :
        P extends 'entity' ? EntityGetPayload<S['select'][P]> | null :
        P extends 'assignUser' ? UserGetPayload<S['select'][P]> | null :  P extends keyof Inquiry ? Inquiry[P] : never
  } 
      : Inquiry


  type InquiryCountArgs = Merge<
    Omit<InquiryFindManyArgs, 'select' | 'include'> & {
      select?: InquiryCountAggregateInputType | true
    }
  >

  export interface InquiryDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Inquiry that matches the filter.
     * @param {InquiryFindUniqueArgs} args - Arguments to find a Inquiry
     * @example
     * // Get one Inquiry
     * const inquiry = await prisma.inquiry.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends InquiryFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, InquiryFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Inquiry'> extends True ? Prisma__InquiryClient<InquiryGetPayload<T>> : Prisma__InquiryClient<InquiryGetPayload<T> | null, null>

    /**
     * Find one Inquiry that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {InquiryFindUniqueOrThrowArgs} args - Arguments to find a Inquiry
     * @example
     * // Get one Inquiry
     * const inquiry = await prisma.inquiry.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends InquiryFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, InquiryFindUniqueOrThrowArgs>
    ): Prisma__InquiryClient<InquiryGetPayload<T>>

    /**
     * Find the first Inquiry that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InquiryFindFirstArgs} args - Arguments to find a Inquiry
     * @example
     * // Get one Inquiry
     * const inquiry = await prisma.inquiry.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends InquiryFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, InquiryFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Inquiry'> extends True ? Prisma__InquiryClient<InquiryGetPayload<T>> : Prisma__InquiryClient<InquiryGetPayload<T> | null, null>

    /**
     * Find the first Inquiry that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InquiryFindFirstOrThrowArgs} args - Arguments to find a Inquiry
     * @example
     * // Get one Inquiry
     * const inquiry = await prisma.inquiry.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends InquiryFindFirstOrThrowArgs>(
      args?: SelectSubset<T, InquiryFindFirstOrThrowArgs>
    ): Prisma__InquiryClient<InquiryGetPayload<T>>

    /**
     * Find zero or more Inquiries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InquiryFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Inquiries
     * const inquiries = await prisma.inquiry.findMany()
     * 
     * // Get first 10 Inquiries
     * const inquiries = await prisma.inquiry.findMany({ take: 10 })
     * 
     * // Only select the `inquire_id`
     * const inquiryWithInquire_idOnly = await prisma.inquiry.findMany({ select: { inquire_id: true } })
     * 
    **/
    findMany<T extends InquiryFindManyArgs>(
      args?: SelectSubset<T, InquiryFindManyArgs>
    ): PrismaPromise<Array<InquiryGetPayload<T>>>

    /**
     * Create a Inquiry.
     * @param {InquiryCreateArgs} args - Arguments to create a Inquiry.
     * @example
     * // Create one Inquiry
     * const Inquiry = await prisma.inquiry.create({
     *   data: {
     *     // ... data to create a Inquiry
     *   }
     * })
     * 
    **/
    create<T extends InquiryCreateArgs>(
      args: SelectSubset<T, InquiryCreateArgs>
    ): Prisma__InquiryClient<InquiryGetPayload<T>>

    /**
     * Create many Inquiries.
     *     @param {InquiryCreateManyArgs} args - Arguments to create many Inquiries.
     *     @example
     *     // Create many Inquiries
     *     const inquiry = await prisma.inquiry.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends InquiryCreateManyArgs>(
      args?: SelectSubset<T, InquiryCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Inquiry.
     * @param {InquiryDeleteArgs} args - Arguments to delete one Inquiry.
     * @example
     * // Delete one Inquiry
     * const Inquiry = await prisma.inquiry.delete({
     *   where: {
     *     // ... filter to delete one Inquiry
     *   }
     * })
     * 
    **/
    delete<T extends InquiryDeleteArgs>(
      args: SelectSubset<T, InquiryDeleteArgs>
    ): Prisma__InquiryClient<InquiryGetPayload<T>>

    /**
     * Update one Inquiry.
     * @param {InquiryUpdateArgs} args - Arguments to update one Inquiry.
     * @example
     * // Update one Inquiry
     * const inquiry = await prisma.inquiry.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends InquiryUpdateArgs>(
      args: SelectSubset<T, InquiryUpdateArgs>
    ): Prisma__InquiryClient<InquiryGetPayload<T>>

    /**
     * Delete zero or more Inquiries.
     * @param {InquiryDeleteManyArgs} args - Arguments to filter Inquiries to delete.
     * @example
     * // Delete a few Inquiries
     * const { count } = await prisma.inquiry.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends InquiryDeleteManyArgs>(
      args?: SelectSubset<T, InquiryDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Inquiries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InquiryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Inquiries
     * const inquiry = await prisma.inquiry.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends InquiryUpdateManyArgs>(
      args: SelectSubset<T, InquiryUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Inquiry.
     * @param {InquiryUpsertArgs} args - Arguments to update or create a Inquiry.
     * @example
     * // Update or create a Inquiry
     * const inquiry = await prisma.inquiry.upsert({
     *   create: {
     *     // ... data to create a Inquiry
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Inquiry we want to update
     *   }
     * })
    **/
    upsert<T extends InquiryUpsertArgs>(
      args: SelectSubset<T, InquiryUpsertArgs>
    ): Prisma__InquiryClient<InquiryGetPayload<T>>

    /**
     * Count the number of Inquiries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InquiryCountArgs} args - Arguments to filter Inquiries to count.
     * @example
     * // Count the number of Inquiries
     * const count = await prisma.inquiry.count({
     *   where: {
     *     // ... the filter for the Inquiries we want to count
     *   }
     * })
    **/
    count<T extends InquiryCountArgs>(
      args?: Subset<T, InquiryCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InquiryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Inquiry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InquiryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InquiryAggregateArgs>(args: Subset<T, InquiryAggregateArgs>): PrismaPromise<GetInquiryAggregateType<T>>

    /**
     * Group by Inquiry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InquiryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InquiryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InquiryGroupByArgs['orderBy'] }
        : { orderBy?: InquiryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InquiryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInquiryGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Inquiry.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__InquiryClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    fromuser<T extends UserArgs= {}>(args?: Subset<T, UserArgs>): Prisma__UserClient<UserGetPayload<T> | Null>;

    entity<T extends EntityArgs= {}>(args?: Subset<T, EntityArgs>): Prisma__EntityClient<EntityGetPayload<T> | Null>;

    assignUser<T extends UserArgs= {}>(args?: Subset<T, UserArgs>): Prisma__UserClient<UserGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Inquiry base type for findUnique actions
   */
  export type InquiryFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Inquiry
     * 
    **/
    select?: InquirySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: InquiryInclude | null
    /**
     * Filter, which Inquiry to fetch.
     * 
    **/
    where: InquiryWhereUniqueInput
  }

  /**
   * Inquiry: findUnique
   */
  export interface InquiryFindUniqueArgs extends InquiryFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Inquiry findUniqueOrThrow
   */
  export type InquiryFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Inquiry
     * 
    **/
    select?: InquirySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: InquiryInclude | null
    /**
     * Filter, which Inquiry to fetch.
     * 
    **/
    where: InquiryWhereUniqueInput
  }


  /**
   * Inquiry base type for findFirst actions
   */
  export type InquiryFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Inquiry
     * 
    **/
    select?: InquirySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: InquiryInclude | null
    /**
     * Filter, which Inquiry to fetch.
     * 
    **/
    where?: InquiryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Inquiries to fetch.
     * 
    **/
    orderBy?: Enumerable<InquiryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Inquiries.
     * 
    **/
    cursor?: InquiryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Inquiries from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Inquiries.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Inquiries.
     * 
    **/
    distinct?: Enumerable<InquiryScalarFieldEnum>
  }

  /**
   * Inquiry: findFirst
   */
  export interface InquiryFindFirstArgs extends InquiryFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Inquiry findFirstOrThrow
   */
  export type InquiryFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Inquiry
     * 
    **/
    select?: InquirySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: InquiryInclude | null
    /**
     * Filter, which Inquiry to fetch.
     * 
    **/
    where?: InquiryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Inquiries to fetch.
     * 
    **/
    orderBy?: Enumerable<InquiryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Inquiries.
     * 
    **/
    cursor?: InquiryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Inquiries from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Inquiries.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Inquiries.
     * 
    **/
    distinct?: Enumerable<InquiryScalarFieldEnum>
  }


  /**
   * Inquiry findMany
   */
  export type InquiryFindManyArgs = {
    /**
     * Select specific fields to fetch from the Inquiry
     * 
    **/
    select?: InquirySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: InquiryInclude | null
    /**
     * Filter, which Inquiries to fetch.
     * 
    **/
    where?: InquiryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Inquiries to fetch.
     * 
    **/
    orderBy?: Enumerable<InquiryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Inquiries.
     * 
    **/
    cursor?: InquiryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Inquiries from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Inquiries.
     * 
    **/
    skip?: number
    distinct?: Enumerable<InquiryScalarFieldEnum>
  }


  /**
   * Inquiry create
   */
  export type InquiryCreateArgs = {
    /**
     * Select specific fields to fetch from the Inquiry
     * 
    **/
    select?: InquirySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: InquiryInclude | null
    /**
     * The data needed to create a Inquiry.
     * 
    **/
    data: XOR<InquiryCreateInput, InquiryUncheckedCreateInput>
  }


  /**
   * Inquiry createMany
   */
  export type InquiryCreateManyArgs = {
    /**
     * The data used to create many Inquiries.
     * 
    **/
    data: Enumerable<InquiryCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Inquiry update
   */
  export type InquiryUpdateArgs = {
    /**
     * Select specific fields to fetch from the Inquiry
     * 
    **/
    select?: InquirySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: InquiryInclude | null
    /**
     * The data needed to update a Inquiry.
     * 
    **/
    data: XOR<InquiryUpdateInput, InquiryUncheckedUpdateInput>
    /**
     * Choose, which Inquiry to update.
     * 
    **/
    where: InquiryWhereUniqueInput
  }


  /**
   * Inquiry updateMany
   */
  export type InquiryUpdateManyArgs = {
    /**
     * The data used to update Inquiries.
     * 
    **/
    data: XOR<InquiryUpdateManyMutationInput, InquiryUncheckedUpdateManyInput>
    /**
     * Filter which Inquiries to update
     * 
    **/
    where?: InquiryWhereInput
  }


  /**
   * Inquiry upsert
   */
  export type InquiryUpsertArgs = {
    /**
     * Select specific fields to fetch from the Inquiry
     * 
    **/
    select?: InquirySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: InquiryInclude | null
    /**
     * The filter to search for the Inquiry to update in case it exists.
     * 
    **/
    where: InquiryWhereUniqueInput
    /**
     * In case the Inquiry found by the `where` argument doesn't exist, create a new Inquiry with this data.
     * 
    **/
    create: XOR<InquiryCreateInput, InquiryUncheckedCreateInput>
    /**
     * In case the Inquiry was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<InquiryUpdateInput, InquiryUncheckedUpdateInput>
  }


  /**
   * Inquiry delete
   */
  export type InquiryDeleteArgs = {
    /**
     * Select specific fields to fetch from the Inquiry
     * 
    **/
    select?: InquirySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: InquiryInclude | null
    /**
     * Filter which Inquiry to delete.
     * 
    **/
    where: InquiryWhereUniqueInput
  }


  /**
   * Inquiry deleteMany
   */
  export type InquiryDeleteManyArgs = {
    /**
     * Filter which Inquiries to delete
     * 
    **/
    where?: InquiryWhereInput
  }


  /**
   * Inquiry without action
   */
  export type InquiryArgs = {
    /**
     * Select specific fields to fetch from the Inquiry
     * 
    **/
    select?: InquirySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: InquiryInclude | null
  }



  /**
   * Model Job
   */


  export type AggregateJob = {
    _count: JobCountAggregateOutputType | null
    _avg: JobAvgAggregateOutputType | null
    _sum: JobSumAggregateOutputType | null
    _min: JobMinAggregateOutputType | null
    _max: JobMaxAggregateOutputType | null
  }

  export type JobAvgAggregateOutputType = {
    experienced_count: number | null
    age_min: number | null
    age_max: number | null
    japanese_percentage: number | null
    salary_min: number | null
    salary_max: number | null
    entity_branch_id: number | null
  }

  export type JobSumAggregateOutputType = {
    experienced_count: number | null
    age_min: number | null
    age_max: number | null
    japanese_percentage: number | null
    salary_min: number | null
    salary_max: number | null
    entity_branch_id: number | null
  }

  export type JobMinAggregateOutputType = {
    job_id: string | null
    created_at: Date | null
    updated_at: Date | null
    created_by: string | null
    updated_by: string | null
    job_publish: JobPublish | null
    location_details: string | null
    benefit_other: string | null
    employment_status: EmploymentStatus | null
    japanese_level: LanguageLevel | null
    english_level: LanguageLevel | null
    experienced_count: number | null
    age_min: number | null
    age_max: number | null
    set_age_reason: string | null
    recruitment_type: ReqriutmentType | null
    job_title: string | null
    job_description: string | null
    japanese_percentage: number | null
    must_condition: string | null
    want_condition: string | null
    position_name: string | null
    working_hour: string | null
    salary_type: SalaryType | null
    salary_min: number | null
    salary_max: number | null
    salary_detail: string | null
    day_off: string | null
    progress_detail: string | null
    entity_branch_id: number | null
    expire_date: Date | null
  }

  export type JobMaxAggregateOutputType = {
    job_id: string | null
    created_at: Date | null
    updated_at: Date | null
    created_by: string | null
    updated_by: string | null
    job_publish: JobPublish | null
    location_details: string | null
    benefit_other: string | null
    employment_status: EmploymentStatus | null
    japanese_level: LanguageLevel | null
    english_level: LanguageLevel | null
    experienced_count: number | null
    age_min: number | null
    age_max: number | null
    set_age_reason: string | null
    recruitment_type: ReqriutmentType | null
    job_title: string | null
    job_description: string | null
    japanese_percentage: number | null
    must_condition: string | null
    want_condition: string | null
    position_name: string | null
    working_hour: string | null
    salary_type: SalaryType | null
    salary_min: number | null
    salary_max: number | null
    salary_detail: string | null
    day_off: string | null
    progress_detail: string | null
    entity_branch_id: number | null
    expire_date: Date | null
  }

  export type JobCountAggregateOutputType = {
    job_id: number
    created_at: number
    updated_at: number
    created_by: number
    updated_by: number
    job_publish: number
    location_details: number
    career_level: number
    benefit_other: number
    smoke: number
    employment_status: number
    japanese_level: number
    english_level: number
    experienced_count: number
    age_min: number
    age_max: number
    set_age_reason: number
    recruitment_type: number
    job_title: number
    job_description: number
    japanese_percentage: number
    must_condition: number
    want_condition: number
    position_name: number
    working_hour: number
    salary_type: number
    salary_min: number
    salary_max: number
    salary_detail: number
    day_off: number
    progress_detail: number
    entity_branch_id: number
    expire_date: number
    _all: number
  }


  export type JobAvgAggregateInputType = {
    experienced_count?: true
    age_min?: true
    age_max?: true
    japanese_percentage?: true
    salary_min?: true
    salary_max?: true
    entity_branch_id?: true
  }

  export type JobSumAggregateInputType = {
    experienced_count?: true
    age_min?: true
    age_max?: true
    japanese_percentage?: true
    salary_min?: true
    salary_max?: true
    entity_branch_id?: true
  }

  export type JobMinAggregateInputType = {
    job_id?: true
    created_at?: true
    updated_at?: true
    created_by?: true
    updated_by?: true
    job_publish?: true
    location_details?: true
    benefit_other?: true
    employment_status?: true
    japanese_level?: true
    english_level?: true
    experienced_count?: true
    age_min?: true
    age_max?: true
    set_age_reason?: true
    recruitment_type?: true
    job_title?: true
    job_description?: true
    japanese_percentage?: true
    must_condition?: true
    want_condition?: true
    position_name?: true
    working_hour?: true
    salary_type?: true
    salary_min?: true
    salary_max?: true
    salary_detail?: true
    day_off?: true
    progress_detail?: true
    entity_branch_id?: true
    expire_date?: true
  }

  export type JobMaxAggregateInputType = {
    job_id?: true
    created_at?: true
    updated_at?: true
    created_by?: true
    updated_by?: true
    job_publish?: true
    location_details?: true
    benefit_other?: true
    employment_status?: true
    japanese_level?: true
    english_level?: true
    experienced_count?: true
    age_min?: true
    age_max?: true
    set_age_reason?: true
    recruitment_type?: true
    job_title?: true
    job_description?: true
    japanese_percentage?: true
    must_condition?: true
    want_condition?: true
    position_name?: true
    working_hour?: true
    salary_type?: true
    salary_min?: true
    salary_max?: true
    salary_detail?: true
    day_off?: true
    progress_detail?: true
    entity_branch_id?: true
    expire_date?: true
  }

  export type JobCountAggregateInputType = {
    job_id?: true
    created_at?: true
    updated_at?: true
    created_by?: true
    updated_by?: true
    job_publish?: true
    location_details?: true
    career_level?: true
    benefit_other?: true
    smoke?: true
    employment_status?: true
    japanese_level?: true
    english_level?: true
    experienced_count?: true
    age_min?: true
    age_max?: true
    set_age_reason?: true
    recruitment_type?: true
    job_title?: true
    job_description?: true
    japanese_percentage?: true
    must_condition?: true
    want_condition?: true
    position_name?: true
    working_hour?: true
    salary_type?: true
    salary_min?: true
    salary_max?: true
    salary_detail?: true
    day_off?: true
    progress_detail?: true
    entity_branch_id?: true
    expire_date?: true
    _all?: true
  }

  export type JobAggregateArgs = {
    /**
     * Filter which Job to aggregate.
     * 
    **/
    where?: JobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Jobs to fetch.
     * 
    **/
    orderBy?: Enumerable<JobOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: JobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Jobs from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Jobs.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Jobs
    **/
    _count?: true | JobCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: JobAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: JobSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: JobMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: JobMaxAggregateInputType
  }

  export type GetJobAggregateType<T extends JobAggregateArgs> = {
        [P in keyof T & keyof AggregateJob]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateJob[P]>
      : GetScalarType<T[P], AggregateJob[P]>
  }




  export type JobGroupByArgs = {
    where?: JobWhereInput
    orderBy?: Enumerable<JobOrderByWithAggregationInput>
    by: Array<JobScalarFieldEnum>
    having?: JobScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: JobCountAggregateInputType | true
    _avg?: JobAvgAggregateInputType
    _sum?: JobSumAggregateInputType
    _min?: JobMinAggregateInputType
    _max?: JobMaxAggregateInputType
  }


  export type JobGroupByOutputType = {
    job_id: string
    created_at: Date
    updated_at: Date
    created_by: string
    updated_by: string | null
    job_publish: JobPublish
    location_details: string | null
    career_level: JobPosition[]
    benefit_other: string | null
    smoke: Smoke[]
    employment_status: EmploymentStatus
    japanese_level: LanguageLevel
    english_level: LanguageLevel
    experienced_count: number
    age_min: number | null
    age_max: number | null
    set_age_reason: string | null
    recruitment_type: ReqriutmentType | null
    job_title: string
    job_description: string
    japanese_percentage: number | null
    must_condition: string
    want_condition: string | null
    position_name: string | null
    working_hour: string
    salary_type: SalaryType
    salary_min: number | null
    salary_max: number | null
    salary_detail: string
    day_off: string | null
    progress_detail: string
    entity_branch_id: number
    expire_date: Date | null
    _count: JobCountAggregateOutputType | null
    _avg: JobAvgAggregateOutputType | null
    _sum: JobSumAggregateOutputType | null
    _min: JobMinAggregateOutputType | null
    _max: JobMaxAggregateOutputType | null
  }

  type GetJobGroupByPayload<T extends JobGroupByArgs> = PrismaPromise<
    Array<
      PickArray<JobGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof JobGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], JobGroupByOutputType[P]>
            : GetScalarType<T[P], JobGroupByOutputType[P]>
        }
      >
    >


  export type JobSelect = {
    job_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    created_by?: boolean
    updated_by?: boolean
    job_publish?: boolean
    job_references?: boolean | JobReferenceListFindManyArgs
    location_details?: boolean
    career_level?: boolean
    benefit_other?: boolean
    smoke?: boolean
    employment_status?: boolean
    japanese_level?: boolean
    english_level?: boolean
    job_other_languages?: boolean | JobOtherLanguageFindManyArgs
    experienced_count?: boolean
    age_min?: boolean
    age_max?: boolean
    set_age_reason?: boolean
    recruitment_type?: boolean
    job_title?: boolean
    job_description?: boolean
    japanese_percentage?: boolean
    must_condition?: boolean
    want_condition?: boolean
    position_name?: boolean
    working_hour?: boolean
    salary_type?: boolean
    salary_min?: boolean
    salary_max?: boolean
    salary_detail?: boolean
    day_off?: boolean
    progress_detail?: boolean
    entity_branch_id?: boolean
    expire_date?: boolean
    entity_branch?: boolean | EntityBranchArgs
    job_candidates?: boolean | JobCandidateFindManyArgs
    JobRequirement?: boolean | JobRequirementFindManyArgs
    _count?: boolean | JobCountOutputTypeArgs
  }


  export type JobInclude = {
    job_references?: boolean | JobReferenceListFindManyArgs
    job_other_languages?: boolean | JobOtherLanguageFindManyArgs
    entity_branch?: boolean | EntityBranchArgs
    job_candidates?: boolean | JobCandidateFindManyArgs
    JobRequirement?: boolean | JobRequirementFindManyArgs
    _count?: boolean | JobCountOutputTypeArgs
  } 

  export type JobGetPayload<S extends boolean | null | undefined | JobArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Job :
    S extends undefined ? never :
    S extends { include: any } & (JobArgs | JobFindManyArgs)
    ? Job  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'job_references' ? Array < JobReferenceListGetPayload<S['include'][P]>>  :
        P extends 'job_other_languages' ? Array < JobOtherLanguageGetPayload<S['include'][P]>>  :
        P extends 'entity_branch' ? EntityBranchGetPayload<S['include'][P]> | null :
        P extends 'job_candidates' ? Array < JobCandidateGetPayload<S['include'][P]>>  :
        P extends 'JobRequirement' ? Array < JobRequirementGetPayload<S['include'][P]>>  :
        P extends '_count' ? JobCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (JobArgs | JobFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'job_references' ? Array < JobReferenceListGetPayload<S['select'][P]>>  :
        P extends 'job_other_languages' ? Array < JobOtherLanguageGetPayload<S['select'][P]>>  :
        P extends 'entity_branch' ? EntityBranchGetPayload<S['select'][P]> | null :
        P extends 'job_candidates' ? Array < JobCandidateGetPayload<S['select'][P]>>  :
        P extends 'JobRequirement' ? Array < JobRequirementGetPayload<S['select'][P]>>  :
        P extends '_count' ? JobCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Job ? Job[P] : never
  } 
      : Job


  type JobCountArgs = Merge<
    Omit<JobFindManyArgs, 'select' | 'include'> & {
      select?: JobCountAggregateInputType | true
    }
  >

  export interface JobDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Job that matches the filter.
     * @param {JobFindUniqueArgs} args - Arguments to find a Job
     * @example
     * // Get one Job
     * const job = await prisma.job.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends JobFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, JobFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Job'> extends True ? Prisma__JobClient<JobGetPayload<T>> : Prisma__JobClient<JobGetPayload<T> | null, null>

    /**
     * Find one Job that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {JobFindUniqueOrThrowArgs} args - Arguments to find a Job
     * @example
     * // Get one Job
     * const job = await prisma.job.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends JobFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, JobFindUniqueOrThrowArgs>
    ): Prisma__JobClient<JobGetPayload<T>>

    /**
     * Find the first Job that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobFindFirstArgs} args - Arguments to find a Job
     * @example
     * // Get one Job
     * const job = await prisma.job.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends JobFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, JobFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Job'> extends True ? Prisma__JobClient<JobGetPayload<T>> : Prisma__JobClient<JobGetPayload<T> | null, null>

    /**
     * Find the first Job that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobFindFirstOrThrowArgs} args - Arguments to find a Job
     * @example
     * // Get one Job
     * const job = await prisma.job.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends JobFindFirstOrThrowArgs>(
      args?: SelectSubset<T, JobFindFirstOrThrowArgs>
    ): Prisma__JobClient<JobGetPayload<T>>

    /**
     * Find zero or more Jobs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Jobs
     * const jobs = await prisma.job.findMany()
     * 
     * // Get first 10 Jobs
     * const jobs = await prisma.job.findMany({ take: 10 })
     * 
     * // Only select the `job_id`
     * const jobWithJob_idOnly = await prisma.job.findMany({ select: { job_id: true } })
     * 
    **/
    findMany<T extends JobFindManyArgs>(
      args?: SelectSubset<T, JobFindManyArgs>
    ): PrismaPromise<Array<JobGetPayload<T>>>

    /**
     * Create a Job.
     * @param {JobCreateArgs} args - Arguments to create a Job.
     * @example
     * // Create one Job
     * const Job = await prisma.job.create({
     *   data: {
     *     // ... data to create a Job
     *   }
     * })
     * 
    **/
    create<T extends JobCreateArgs>(
      args: SelectSubset<T, JobCreateArgs>
    ): Prisma__JobClient<JobGetPayload<T>>

    /**
     * Create many Jobs.
     *     @param {JobCreateManyArgs} args - Arguments to create many Jobs.
     *     @example
     *     // Create many Jobs
     *     const job = await prisma.job.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends JobCreateManyArgs>(
      args?: SelectSubset<T, JobCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Job.
     * @param {JobDeleteArgs} args - Arguments to delete one Job.
     * @example
     * // Delete one Job
     * const Job = await prisma.job.delete({
     *   where: {
     *     // ... filter to delete one Job
     *   }
     * })
     * 
    **/
    delete<T extends JobDeleteArgs>(
      args: SelectSubset<T, JobDeleteArgs>
    ): Prisma__JobClient<JobGetPayload<T>>

    /**
     * Update one Job.
     * @param {JobUpdateArgs} args - Arguments to update one Job.
     * @example
     * // Update one Job
     * const job = await prisma.job.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends JobUpdateArgs>(
      args: SelectSubset<T, JobUpdateArgs>
    ): Prisma__JobClient<JobGetPayload<T>>

    /**
     * Delete zero or more Jobs.
     * @param {JobDeleteManyArgs} args - Arguments to filter Jobs to delete.
     * @example
     * // Delete a few Jobs
     * const { count } = await prisma.job.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends JobDeleteManyArgs>(
      args?: SelectSubset<T, JobDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Jobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Jobs
     * const job = await prisma.job.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends JobUpdateManyArgs>(
      args: SelectSubset<T, JobUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Job.
     * @param {JobUpsertArgs} args - Arguments to update or create a Job.
     * @example
     * // Update or create a Job
     * const job = await prisma.job.upsert({
     *   create: {
     *     // ... data to create a Job
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Job we want to update
     *   }
     * })
    **/
    upsert<T extends JobUpsertArgs>(
      args: SelectSubset<T, JobUpsertArgs>
    ): Prisma__JobClient<JobGetPayload<T>>

    /**
     * Count the number of Jobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobCountArgs} args - Arguments to filter Jobs to count.
     * @example
     * // Count the number of Jobs
     * const count = await prisma.job.count({
     *   where: {
     *     // ... the filter for the Jobs we want to count
     *   }
     * })
    **/
    count<T extends JobCountArgs>(
      args?: Subset<T, JobCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], JobCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Job.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends JobAggregateArgs>(args: Subset<T, JobAggregateArgs>): PrismaPromise<GetJobAggregateType<T>>

    /**
     * Group by Job.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends JobGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: JobGroupByArgs['orderBy'] }
        : { orderBy?: JobGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, JobGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetJobGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Job.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__JobClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    job_references<T extends JobReferenceListFindManyArgs= {}>(args?: Subset<T, JobReferenceListFindManyArgs>): PrismaPromise<Array<JobReferenceListGetPayload<T>>| Null>;

    job_other_languages<T extends JobOtherLanguageFindManyArgs= {}>(args?: Subset<T, JobOtherLanguageFindManyArgs>): PrismaPromise<Array<JobOtherLanguageGetPayload<T>>| Null>;

    entity_branch<T extends EntityBranchArgs= {}>(args?: Subset<T, EntityBranchArgs>): Prisma__EntityBranchClient<EntityBranchGetPayload<T> | Null>;

    job_candidates<T extends JobCandidateFindManyArgs= {}>(args?: Subset<T, JobCandidateFindManyArgs>): PrismaPromise<Array<JobCandidateGetPayload<T>>| Null>;

    JobRequirement<T extends JobRequirementFindManyArgs= {}>(args?: Subset<T, JobRequirementFindManyArgs>): PrismaPromise<Array<JobRequirementGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Job base type for findUnique actions
   */
  export type JobFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Job
     * 
    **/
    select?: JobSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: JobInclude | null
    /**
     * Filter, which Job to fetch.
     * 
    **/
    where: JobWhereUniqueInput
  }

  /**
   * Job: findUnique
   */
  export interface JobFindUniqueArgs extends JobFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Job findUniqueOrThrow
   */
  export type JobFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Job
     * 
    **/
    select?: JobSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: JobInclude | null
    /**
     * Filter, which Job to fetch.
     * 
    **/
    where: JobWhereUniqueInput
  }


  /**
   * Job base type for findFirst actions
   */
  export type JobFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Job
     * 
    **/
    select?: JobSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: JobInclude | null
    /**
     * Filter, which Job to fetch.
     * 
    **/
    where?: JobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Jobs to fetch.
     * 
    **/
    orderBy?: Enumerable<JobOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Jobs.
     * 
    **/
    cursor?: JobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Jobs from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Jobs.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Jobs.
     * 
    **/
    distinct?: Enumerable<JobScalarFieldEnum>
  }

  /**
   * Job: findFirst
   */
  export interface JobFindFirstArgs extends JobFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Job findFirstOrThrow
   */
  export type JobFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Job
     * 
    **/
    select?: JobSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: JobInclude | null
    /**
     * Filter, which Job to fetch.
     * 
    **/
    where?: JobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Jobs to fetch.
     * 
    **/
    orderBy?: Enumerable<JobOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Jobs.
     * 
    **/
    cursor?: JobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Jobs from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Jobs.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Jobs.
     * 
    **/
    distinct?: Enumerable<JobScalarFieldEnum>
  }


  /**
   * Job findMany
   */
  export type JobFindManyArgs = {
    /**
     * Select specific fields to fetch from the Job
     * 
    **/
    select?: JobSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: JobInclude | null
    /**
     * Filter, which Jobs to fetch.
     * 
    **/
    where?: JobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Jobs to fetch.
     * 
    **/
    orderBy?: Enumerable<JobOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Jobs.
     * 
    **/
    cursor?: JobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Jobs from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Jobs.
     * 
    **/
    skip?: number
    distinct?: Enumerable<JobScalarFieldEnum>
  }


  /**
   * Job create
   */
  export type JobCreateArgs = {
    /**
     * Select specific fields to fetch from the Job
     * 
    **/
    select?: JobSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: JobInclude | null
    /**
     * The data needed to create a Job.
     * 
    **/
    data: XOR<JobCreateInput, JobUncheckedCreateInput>
  }


  /**
   * Job createMany
   */
  export type JobCreateManyArgs = {
    /**
     * The data used to create many Jobs.
     * 
    **/
    data: Enumerable<JobCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Job update
   */
  export type JobUpdateArgs = {
    /**
     * Select specific fields to fetch from the Job
     * 
    **/
    select?: JobSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: JobInclude | null
    /**
     * The data needed to update a Job.
     * 
    **/
    data: XOR<JobUpdateInput, JobUncheckedUpdateInput>
    /**
     * Choose, which Job to update.
     * 
    **/
    where: JobWhereUniqueInput
  }


  /**
   * Job updateMany
   */
  export type JobUpdateManyArgs = {
    /**
     * The data used to update Jobs.
     * 
    **/
    data: XOR<JobUpdateManyMutationInput, JobUncheckedUpdateManyInput>
    /**
     * Filter which Jobs to update
     * 
    **/
    where?: JobWhereInput
  }


  /**
   * Job upsert
   */
  export type JobUpsertArgs = {
    /**
     * Select specific fields to fetch from the Job
     * 
    **/
    select?: JobSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: JobInclude | null
    /**
     * The filter to search for the Job to update in case it exists.
     * 
    **/
    where: JobWhereUniqueInput
    /**
     * In case the Job found by the `where` argument doesn't exist, create a new Job with this data.
     * 
    **/
    create: XOR<JobCreateInput, JobUncheckedCreateInput>
    /**
     * In case the Job was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<JobUpdateInput, JobUncheckedUpdateInput>
  }


  /**
   * Job delete
   */
  export type JobDeleteArgs = {
    /**
     * Select specific fields to fetch from the Job
     * 
    **/
    select?: JobSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: JobInclude | null
    /**
     * Filter which Job to delete.
     * 
    **/
    where: JobWhereUniqueInput
  }


  /**
   * Job deleteMany
   */
  export type JobDeleteManyArgs = {
    /**
     * Filter which Jobs to delete
     * 
    **/
    where?: JobWhereInput
  }


  /**
   * Job without action
   */
  export type JobArgs = {
    /**
     * Select specific fields to fetch from the Job
     * 
    **/
    select?: JobSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: JobInclude | null
  }



  /**
   * Model JobOtherLanguage
   */


  export type AggregateJobOtherLanguage = {
    _count: JobOtherLanguageCountAggregateOutputType | null
    _avg: JobOtherLanguageAvgAggregateOutputType | null
    _sum: JobOtherLanguageSumAggregateOutputType | null
    _min: JobOtherLanguageMinAggregateOutputType | null
    _max: JobOtherLanguageMaxAggregateOutputType | null
  }

  export type JobOtherLanguageAvgAggregateOutputType = {
    language_id: number | null
  }

  export type JobOtherLanguageSumAggregateOutputType = {
    language_id: number | null
  }

  export type JobOtherLanguageMinAggregateOutputType = {
    job_other_language_id: string | null
    language_id: number | null
    language_level: LanguageLevel | null
    job_id: string | null
  }

  export type JobOtherLanguageMaxAggregateOutputType = {
    job_other_language_id: string | null
    language_id: number | null
    language_level: LanguageLevel | null
    job_id: string | null
  }

  export type JobOtherLanguageCountAggregateOutputType = {
    job_other_language_id: number
    language_id: number
    language_level: number
    job_id: number
    _all: number
  }


  export type JobOtherLanguageAvgAggregateInputType = {
    language_id?: true
  }

  export type JobOtherLanguageSumAggregateInputType = {
    language_id?: true
  }

  export type JobOtherLanguageMinAggregateInputType = {
    job_other_language_id?: true
    language_id?: true
    language_level?: true
    job_id?: true
  }

  export type JobOtherLanguageMaxAggregateInputType = {
    job_other_language_id?: true
    language_id?: true
    language_level?: true
    job_id?: true
  }

  export type JobOtherLanguageCountAggregateInputType = {
    job_other_language_id?: true
    language_id?: true
    language_level?: true
    job_id?: true
    _all?: true
  }

  export type JobOtherLanguageAggregateArgs = {
    /**
     * Filter which JobOtherLanguage to aggregate.
     * 
    **/
    where?: JobOtherLanguageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobOtherLanguages to fetch.
     * 
    **/
    orderBy?: Enumerable<JobOtherLanguageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: JobOtherLanguageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JobOtherLanguages from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobOtherLanguages.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned JobOtherLanguages
    **/
    _count?: true | JobOtherLanguageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: JobOtherLanguageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: JobOtherLanguageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: JobOtherLanguageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: JobOtherLanguageMaxAggregateInputType
  }

  export type GetJobOtherLanguageAggregateType<T extends JobOtherLanguageAggregateArgs> = {
        [P in keyof T & keyof AggregateJobOtherLanguage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateJobOtherLanguage[P]>
      : GetScalarType<T[P], AggregateJobOtherLanguage[P]>
  }




  export type JobOtherLanguageGroupByArgs = {
    where?: JobOtherLanguageWhereInput
    orderBy?: Enumerable<JobOtherLanguageOrderByWithAggregationInput>
    by: Array<JobOtherLanguageScalarFieldEnum>
    having?: JobOtherLanguageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: JobOtherLanguageCountAggregateInputType | true
    _avg?: JobOtherLanguageAvgAggregateInputType
    _sum?: JobOtherLanguageSumAggregateInputType
    _min?: JobOtherLanguageMinAggregateInputType
    _max?: JobOtherLanguageMaxAggregateInputType
  }


  export type JobOtherLanguageGroupByOutputType = {
    job_other_language_id: string
    language_id: number
    language_level: LanguageLevel
    job_id: string
    _count: JobOtherLanguageCountAggregateOutputType | null
    _avg: JobOtherLanguageAvgAggregateOutputType | null
    _sum: JobOtherLanguageSumAggregateOutputType | null
    _min: JobOtherLanguageMinAggregateOutputType | null
    _max: JobOtherLanguageMaxAggregateOutputType | null
  }

  type GetJobOtherLanguageGroupByPayload<T extends JobOtherLanguageGroupByArgs> = PrismaPromise<
    Array<
      PickArray<JobOtherLanguageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof JobOtherLanguageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], JobOtherLanguageGroupByOutputType[P]>
            : GetScalarType<T[P], JobOtherLanguageGroupByOutputType[P]>
        }
      >
    >


  export type JobOtherLanguageSelect = {
    job_other_language_id?: boolean
    language_id?: boolean
    language_level?: boolean
    job_id?: boolean
    job?: boolean | JobArgs
  }


  export type JobOtherLanguageInclude = {
    job?: boolean | JobArgs
  } 

  export type JobOtherLanguageGetPayload<S extends boolean | null | undefined | JobOtherLanguageArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? JobOtherLanguage :
    S extends undefined ? never :
    S extends { include: any } & (JobOtherLanguageArgs | JobOtherLanguageFindManyArgs)
    ? JobOtherLanguage  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'job' ? JobGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (JobOtherLanguageArgs | JobOtherLanguageFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'job' ? JobGetPayload<S['select'][P]> :  P extends keyof JobOtherLanguage ? JobOtherLanguage[P] : never
  } 
      : JobOtherLanguage


  type JobOtherLanguageCountArgs = Merge<
    Omit<JobOtherLanguageFindManyArgs, 'select' | 'include'> & {
      select?: JobOtherLanguageCountAggregateInputType | true
    }
  >

  export interface JobOtherLanguageDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one JobOtherLanguage that matches the filter.
     * @param {JobOtherLanguageFindUniqueArgs} args - Arguments to find a JobOtherLanguage
     * @example
     * // Get one JobOtherLanguage
     * const jobOtherLanguage = await prisma.jobOtherLanguage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends JobOtherLanguageFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, JobOtherLanguageFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'JobOtherLanguage'> extends True ? Prisma__JobOtherLanguageClient<JobOtherLanguageGetPayload<T>> : Prisma__JobOtherLanguageClient<JobOtherLanguageGetPayload<T> | null, null>

    /**
     * Find one JobOtherLanguage that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {JobOtherLanguageFindUniqueOrThrowArgs} args - Arguments to find a JobOtherLanguage
     * @example
     * // Get one JobOtherLanguage
     * const jobOtherLanguage = await prisma.jobOtherLanguage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends JobOtherLanguageFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, JobOtherLanguageFindUniqueOrThrowArgs>
    ): Prisma__JobOtherLanguageClient<JobOtherLanguageGetPayload<T>>

    /**
     * Find the first JobOtherLanguage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobOtherLanguageFindFirstArgs} args - Arguments to find a JobOtherLanguage
     * @example
     * // Get one JobOtherLanguage
     * const jobOtherLanguage = await prisma.jobOtherLanguage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends JobOtherLanguageFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, JobOtherLanguageFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'JobOtherLanguage'> extends True ? Prisma__JobOtherLanguageClient<JobOtherLanguageGetPayload<T>> : Prisma__JobOtherLanguageClient<JobOtherLanguageGetPayload<T> | null, null>

    /**
     * Find the first JobOtherLanguage that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobOtherLanguageFindFirstOrThrowArgs} args - Arguments to find a JobOtherLanguage
     * @example
     * // Get one JobOtherLanguage
     * const jobOtherLanguage = await prisma.jobOtherLanguage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends JobOtherLanguageFindFirstOrThrowArgs>(
      args?: SelectSubset<T, JobOtherLanguageFindFirstOrThrowArgs>
    ): Prisma__JobOtherLanguageClient<JobOtherLanguageGetPayload<T>>

    /**
     * Find zero or more JobOtherLanguages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobOtherLanguageFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all JobOtherLanguages
     * const jobOtherLanguages = await prisma.jobOtherLanguage.findMany()
     * 
     * // Get first 10 JobOtherLanguages
     * const jobOtherLanguages = await prisma.jobOtherLanguage.findMany({ take: 10 })
     * 
     * // Only select the `job_other_language_id`
     * const jobOtherLanguageWithJob_other_language_idOnly = await prisma.jobOtherLanguage.findMany({ select: { job_other_language_id: true } })
     * 
    **/
    findMany<T extends JobOtherLanguageFindManyArgs>(
      args?: SelectSubset<T, JobOtherLanguageFindManyArgs>
    ): PrismaPromise<Array<JobOtherLanguageGetPayload<T>>>

    /**
     * Create a JobOtherLanguage.
     * @param {JobOtherLanguageCreateArgs} args - Arguments to create a JobOtherLanguage.
     * @example
     * // Create one JobOtherLanguage
     * const JobOtherLanguage = await prisma.jobOtherLanguage.create({
     *   data: {
     *     // ... data to create a JobOtherLanguage
     *   }
     * })
     * 
    **/
    create<T extends JobOtherLanguageCreateArgs>(
      args: SelectSubset<T, JobOtherLanguageCreateArgs>
    ): Prisma__JobOtherLanguageClient<JobOtherLanguageGetPayload<T>>

    /**
     * Create many JobOtherLanguages.
     *     @param {JobOtherLanguageCreateManyArgs} args - Arguments to create many JobOtherLanguages.
     *     @example
     *     // Create many JobOtherLanguages
     *     const jobOtherLanguage = await prisma.jobOtherLanguage.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends JobOtherLanguageCreateManyArgs>(
      args?: SelectSubset<T, JobOtherLanguageCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a JobOtherLanguage.
     * @param {JobOtherLanguageDeleteArgs} args - Arguments to delete one JobOtherLanguage.
     * @example
     * // Delete one JobOtherLanguage
     * const JobOtherLanguage = await prisma.jobOtherLanguage.delete({
     *   where: {
     *     // ... filter to delete one JobOtherLanguage
     *   }
     * })
     * 
    **/
    delete<T extends JobOtherLanguageDeleteArgs>(
      args: SelectSubset<T, JobOtherLanguageDeleteArgs>
    ): Prisma__JobOtherLanguageClient<JobOtherLanguageGetPayload<T>>

    /**
     * Update one JobOtherLanguage.
     * @param {JobOtherLanguageUpdateArgs} args - Arguments to update one JobOtherLanguage.
     * @example
     * // Update one JobOtherLanguage
     * const jobOtherLanguage = await prisma.jobOtherLanguage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends JobOtherLanguageUpdateArgs>(
      args: SelectSubset<T, JobOtherLanguageUpdateArgs>
    ): Prisma__JobOtherLanguageClient<JobOtherLanguageGetPayload<T>>

    /**
     * Delete zero or more JobOtherLanguages.
     * @param {JobOtherLanguageDeleteManyArgs} args - Arguments to filter JobOtherLanguages to delete.
     * @example
     * // Delete a few JobOtherLanguages
     * const { count } = await prisma.jobOtherLanguage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends JobOtherLanguageDeleteManyArgs>(
      args?: SelectSubset<T, JobOtherLanguageDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more JobOtherLanguages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobOtherLanguageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many JobOtherLanguages
     * const jobOtherLanguage = await prisma.jobOtherLanguage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends JobOtherLanguageUpdateManyArgs>(
      args: SelectSubset<T, JobOtherLanguageUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one JobOtherLanguage.
     * @param {JobOtherLanguageUpsertArgs} args - Arguments to update or create a JobOtherLanguage.
     * @example
     * // Update or create a JobOtherLanguage
     * const jobOtherLanguage = await prisma.jobOtherLanguage.upsert({
     *   create: {
     *     // ... data to create a JobOtherLanguage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the JobOtherLanguage we want to update
     *   }
     * })
    **/
    upsert<T extends JobOtherLanguageUpsertArgs>(
      args: SelectSubset<T, JobOtherLanguageUpsertArgs>
    ): Prisma__JobOtherLanguageClient<JobOtherLanguageGetPayload<T>>

    /**
     * Count the number of JobOtherLanguages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobOtherLanguageCountArgs} args - Arguments to filter JobOtherLanguages to count.
     * @example
     * // Count the number of JobOtherLanguages
     * const count = await prisma.jobOtherLanguage.count({
     *   where: {
     *     // ... the filter for the JobOtherLanguages we want to count
     *   }
     * })
    **/
    count<T extends JobOtherLanguageCountArgs>(
      args?: Subset<T, JobOtherLanguageCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], JobOtherLanguageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a JobOtherLanguage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobOtherLanguageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends JobOtherLanguageAggregateArgs>(args: Subset<T, JobOtherLanguageAggregateArgs>): PrismaPromise<GetJobOtherLanguageAggregateType<T>>

    /**
     * Group by JobOtherLanguage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobOtherLanguageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends JobOtherLanguageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: JobOtherLanguageGroupByArgs['orderBy'] }
        : { orderBy?: JobOtherLanguageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, JobOtherLanguageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetJobOtherLanguageGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for JobOtherLanguage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__JobOtherLanguageClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    job<T extends JobArgs= {}>(args?: Subset<T, JobArgs>): Prisma__JobClient<JobGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * JobOtherLanguage base type for findUnique actions
   */
  export type JobOtherLanguageFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the JobOtherLanguage
     * 
    **/
    select?: JobOtherLanguageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: JobOtherLanguageInclude | null
    /**
     * Filter, which JobOtherLanguage to fetch.
     * 
    **/
    where: JobOtherLanguageWhereUniqueInput
  }

  /**
   * JobOtherLanguage: findUnique
   */
  export interface JobOtherLanguageFindUniqueArgs extends JobOtherLanguageFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * JobOtherLanguage findUniqueOrThrow
   */
  export type JobOtherLanguageFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the JobOtherLanguage
     * 
    **/
    select?: JobOtherLanguageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: JobOtherLanguageInclude | null
    /**
     * Filter, which JobOtherLanguage to fetch.
     * 
    **/
    where: JobOtherLanguageWhereUniqueInput
  }


  /**
   * JobOtherLanguage base type for findFirst actions
   */
  export type JobOtherLanguageFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the JobOtherLanguage
     * 
    **/
    select?: JobOtherLanguageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: JobOtherLanguageInclude | null
    /**
     * Filter, which JobOtherLanguage to fetch.
     * 
    **/
    where?: JobOtherLanguageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobOtherLanguages to fetch.
     * 
    **/
    orderBy?: Enumerable<JobOtherLanguageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JobOtherLanguages.
     * 
    **/
    cursor?: JobOtherLanguageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JobOtherLanguages from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobOtherLanguages.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JobOtherLanguages.
     * 
    **/
    distinct?: Enumerable<JobOtherLanguageScalarFieldEnum>
  }

  /**
   * JobOtherLanguage: findFirst
   */
  export interface JobOtherLanguageFindFirstArgs extends JobOtherLanguageFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * JobOtherLanguage findFirstOrThrow
   */
  export type JobOtherLanguageFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the JobOtherLanguage
     * 
    **/
    select?: JobOtherLanguageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: JobOtherLanguageInclude | null
    /**
     * Filter, which JobOtherLanguage to fetch.
     * 
    **/
    where?: JobOtherLanguageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobOtherLanguages to fetch.
     * 
    **/
    orderBy?: Enumerable<JobOtherLanguageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JobOtherLanguages.
     * 
    **/
    cursor?: JobOtherLanguageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JobOtherLanguages from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobOtherLanguages.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JobOtherLanguages.
     * 
    **/
    distinct?: Enumerable<JobOtherLanguageScalarFieldEnum>
  }


  /**
   * JobOtherLanguage findMany
   */
  export type JobOtherLanguageFindManyArgs = {
    /**
     * Select specific fields to fetch from the JobOtherLanguage
     * 
    **/
    select?: JobOtherLanguageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: JobOtherLanguageInclude | null
    /**
     * Filter, which JobOtherLanguages to fetch.
     * 
    **/
    where?: JobOtherLanguageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobOtherLanguages to fetch.
     * 
    **/
    orderBy?: Enumerable<JobOtherLanguageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing JobOtherLanguages.
     * 
    **/
    cursor?: JobOtherLanguageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JobOtherLanguages from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobOtherLanguages.
     * 
    **/
    skip?: number
    distinct?: Enumerable<JobOtherLanguageScalarFieldEnum>
  }


  /**
   * JobOtherLanguage create
   */
  export type JobOtherLanguageCreateArgs = {
    /**
     * Select specific fields to fetch from the JobOtherLanguage
     * 
    **/
    select?: JobOtherLanguageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: JobOtherLanguageInclude | null
    /**
     * The data needed to create a JobOtherLanguage.
     * 
    **/
    data: XOR<JobOtherLanguageCreateInput, JobOtherLanguageUncheckedCreateInput>
  }


  /**
   * JobOtherLanguage createMany
   */
  export type JobOtherLanguageCreateManyArgs = {
    /**
     * The data used to create many JobOtherLanguages.
     * 
    **/
    data: Enumerable<JobOtherLanguageCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * JobOtherLanguage update
   */
  export type JobOtherLanguageUpdateArgs = {
    /**
     * Select specific fields to fetch from the JobOtherLanguage
     * 
    **/
    select?: JobOtherLanguageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: JobOtherLanguageInclude | null
    /**
     * The data needed to update a JobOtherLanguage.
     * 
    **/
    data: XOR<JobOtherLanguageUpdateInput, JobOtherLanguageUncheckedUpdateInput>
    /**
     * Choose, which JobOtherLanguage to update.
     * 
    **/
    where: JobOtherLanguageWhereUniqueInput
  }


  /**
   * JobOtherLanguage updateMany
   */
  export type JobOtherLanguageUpdateManyArgs = {
    /**
     * The data used to update JobOtherLanguages.
     * 
    **/
    data: XOR<JobOtherLanguageUpdateManyMutationInput, JobOtherLanguageUncheckedUpdateManyInput>
    /**
     * Filter which JobOtherLanguages to update
     * 
    **/
    where?: JobOtherLanguageWhereInput
  }


  /**
   * JobOtherLanguage upsert
   */
  export type JobOtherLanguageUpsertArgs = {
    /**
     * Select specific fields to fetch from the JobOtherLanguage
     * 
    **/
    select?: JobOtherLanguageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: JobOtherLanguageInclude | null
    /**
     * The filter to search for the JobOtherLanguage to update in case it exists.
     * 
    **/
    where: JobOtherLanguageWhereUniqueInput
    /**
     * In case the JobOtherLanguage found by the `where` argument doesn't exist, create a new JobOtherLanguage with this data.
     * 
    **/
    create: XOR<JobOtherLanguageCreateInput, JobOtherLanguageUncheckedCreateInput>
    /**
     * In case the JobOtherLanguage was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<JobOtherLanguageUpdateInput, JobOtherLanguageUncheckedUpdateInput>
  }


  /**
   * JobOtherLanguage delete
   */
  export type JobOtherLanguageDeleteArgs = {
    /**
     * Select specific fields to fetch from the JobOtherLanguage
     * 
    **/
    select?: JobOtherLanguageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: JobOtherLanguageInclude | null
    /**
     * Filter which JobOtherLanguage to delete.
     * 
    **/
    where: JobOtherLanguageWhereUniqueInput
  }


  /**
   * JobOtherLanguage deleteMany
   */
  export type JobOtherLanguageDeleteManyArgs = {
    /**
     * Filter which JobOtherLanguages to delete
     * 
    **/
    where?: JobOtherLanguageWhereInput
  }


  /**
   * JobOtherLanguage without action
   */
  export type JobOtherLanguageArgs = {
    /**
     * Select specific fields to fetch from the JobOtherLanguage
     * 
    **/
    select?: JobOtherLanguageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: JobOtherLanguageInclude | null
  }



  /**
   * Model JobReferenceList
   */


  export type AggregateJobReferenceList = {
    _count: JobReferenceListCountAggregateOutputType | null
    _avg: JobReferenceListAvgAggregateOutputType | null
    _sum: JobReferenceListSumAggregateOutputType | null
    _min: JobReferenceListMinAggregateOutputType | null
    _max: JobReferenceListMaxAggregateOutputType | null
  }

  export type JobReferenceListAvgAggregateOutputType = {
    reference_list_id: number | null
    reference_list_item_id: number | null
  }

  export type JobReferenceListSumAggregateOutputType = {
    reference_list_id: number | null
    reference_list_item_id: number | null
  }

  export type JobReferenceListMinAggregateOutputType = {
    job_reference_id: string | null
    job_id: string | null
    reference_list_id: number | null
    reference_list_item_id: number | null
  }

  export type JobReferenceListMaxAggregateOutputType = {
    job_reference_id: string | null
    job_id: string | null
    reference_list_id: number | null
    reference_list_item_id: number | null
  }

  export type JobReferenceListCountAggregateOutputType = {
    job_reference_id: number
    job_id: number
    reference_list_id: number
    reference_list_item_id: number
    _all: number
  }


  export type JobReferenceListAvgAggregateInputType = {
    reference_list_id?: true
    reference_list_item_id?: true
  }

  export type JobReferenceListSumAggregateInputType = {
    reference_list_id?: true
    reference_list_item_id?: true
  }

  export type JobReferenceListMinAggregateInputType = {
    job_reference_id?: true
    job_id?: true
    reference_list_id?: true
    reference_list_item_id?: true
  }

  export type JobReferenceListMaxAggregateInputType = {
    job_reference_id?: true
    job_id?: true
    reference_list_id?: true
    reference_list_item_id?: true
  }

  export type JobReferenceListCountAggregateInputType = {
    job_reference_id?: true
    job_id?: true
    reference_list_id?: true
    reference_list_item_id?: true
    _all?: true
  }

  export type JobReferenceListAggregateArgs = {
    /**
     * Filter which JobReferenceList to aggregate.
     * 
    **/
    where?: JobReferenceListWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobReferenceLists to fetch.
     * 
    **/
    orderBy?: Enumerable<JobReferenceListOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: JobReferenceListWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JobReferenceLists from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobReferenceLists.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned JobReferenceLists
    **/
    _count?: true | JobReferenceListCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: JobReferenceListAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: JobReferenceListSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: JobReferenceListMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: JobReferenceListMaxAggregateInputType
  }

  export type GetJobReferenceListAggregateType<T extends JobReferenceListAggregateArgs> = {
        [P in keyof T & keyof AggregateJobReferenceList]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateJobReferenceList[P]>
      : GetScalarType<T[P], AggregateJobReferenceList[P]>
  }




  export type JobReferenceListGroupByArgs = {
    where?: JobReferenceListWhereInput
    orderBy?: Enumerable<JobReferenceListOrderByWithAggregationInput>
    by: Array<JobReferenceListScalarFieldEnum>
    having?: JobReferenceListScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: JobReferenceListCountAggregateInputType | true
    _avg?: JobReferenceListAvgAggregateInputType
    _sum?: JobReferenceListSumAggregateInputType
    _min?: JobReferenceListMinAggregateInputType
    _max?: JobReferenceListMaxAggregateInputType
  }


  export type JobReferenceListGroupByOutputType = {
    job_reference_id: string
    job_id: string
    reference_list_id: number
    reference_list_item_id: number
    _count: JobReferenceListCountAggregateOutputType | null
    _avg: JobReferenceListAvgAggregateOutputType | null
    _sum: JobReferenceListSumAggregateOutputType | null
    _min: JobReferenceListMinAggregateOutputType | null
    _max: JobReferenceListMaxAggregateOutputType | null
  }

  type GetJobReferenceListGroupByPayload<T extends JobReferenceListGroupByArgs> = PrismaPromise<
    Array<
      PickArray<JobReferenceListGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof JobReferenceListGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], JobReferenceListGroupByOutputType[P]>
            : GetScalarType<T[P], JobReferenceListGroupByOutputType[P]>
        }
      >
    >


  export type JobReferenceListSelect = {
    job_reference_id?: boolean
    job_id?: boolean
    reference_list_id?: boolean
    reference_list_item_id?: boolean
    job?: boolean | JobArgs
    reference_list?: boolean | ReferenceListArgs
    reference_list_item?: boolean | ReferenceListItemsArgs
  }


  export type JobReferenceListInclude = {
    job?: boolean | JobArgs
    reference_list?: boolean | ReferenceListArgs
    reference_list_item?: boolean | ReferenceListItemsArgs
  } 

  export type JobReferenceListGetPayload<S extends boolean | null | undefined | JobReferenceListArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? JobReferenceList :
    S extends undefined ? never :
    S extends { include: any } & (JobReferenceListArgs | JobReferenceListFindManyArgs)
    ? JobReferenceList  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'job' ? JobGetPayload<S['include'][P]> :
        P extends 'reference_list' ? ReferenceListGetPayload<S['include'][P]> :
        P extends 'reference_list_item' ? ReferenceListItemsGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (JobReferenceListArgs | JobReferenceListFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'job' ? JobGetPayload<S['select'][P]> :
        P extends 'reference_list' ? ReferenceListGetPayload<S['select'][P]> :
        P extends 'reference_list_item' ? ReferenceListItemsGetPayload<S['select'][P]> :  P extends keyof JobReferenceList ? JobReferenceList[P] : never
  } 
      : JobReferenceList


  type JobReferenceListCountArgs = Merge<
    Omit<JobReferenceListFindManyArgs, 'select' | 'include'> & {
      select?: JobReferenceListCountAggregateInputType | true
    }
  >

  export interface JobReferenceListDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one JobReferenceList that matches the filter.
     * @param {JobReferenceListFindUniqueArgs} args - Arguments to find a JobReferenceList
     * @example
     * // Get one JobReferenceList
     * const jobReferenceList = await prisma.jobReferenceList.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends JobReferenceListFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, JobReferenceListFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'JobReferenceList'> extends True ? Prisma__JobReferenceListClient<JobReferenceListGetPayload<T>> : Prisma__JobReferenceListClient<JobReferenceListGetPayload<T> | null, null>

    /**
     * Find one JobReferenceList that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {JobReferenceListFindUniqueOrThrowArgs} args - Arguments to find a JobReferenceList
     * @example
     * // Get one JobReferenceList
     * const jobReferenceList = await prisma.jobReferenceList.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends JobReferenceListFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, JobReferenceListFindUniqueOrThrowArgs>
    ): Prisma__JobReferenceListClient<JobReferenceListGetPayload<T>>

    /**
     * Find the first JobReferenceList that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobReferenceListFindFirstArgs} args - Arguments to find a JobReferenceList
     * @example
     * // Get one JobReferenceList
     * const jobReferenceList = await prisma.jobReferenceList.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends JobReferenceListFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, JobReferenceListFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'JobReferenceList'> extends True ? Prisma__JobReferenceListClient<JobReferenceListGetPayload<T>> : Prisma__JobReferenceListClient<JobReferenceListGetPayload<T> | null, null>

    /**
     * Find the first JobReferenceList that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobReferenceListFindFirstOrThrowArgs} args - Arguments to find a JobReferenceList
     * @example
     * // Get one JobReferenceList
     * const jobReferenceList = await prisma.jobReferenceList.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends JobReferenceListFindFirstOrThrowArgs>(
      args?: SelectSubset<T, JobReferenceListFindFirstOrThrowArgs>
    ): Prisma__JobReferenceListClient<JobReferenceListGetPayload<T>>

    /**
     * Find zero or more JobReferenceLists that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobReferenceListFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all JobReferenceLists
     * const jobReferenceLists = await prisma.jobReferenceList.findMany()
     * 
     * // Get first 10 JobReferenceLists
     * const jobReferenceLists = await prisma.jobReferenceList.findMany({ take: 10 })
     * 
     * // Only select the `job_reference_id`
     * const jobReferenceListWithJob_reference_idOnly = await prisma.jobReferenceList.findMany({ select: { job_reference_id: true } })
     * 
    **/
    findMany<T extends JobReferenceListFindManyArgs>(
      args?: SelectSubset<T, JobReferenceListFindManyArgs>
    ): PrismaPromise<Array<JobReferenceListGetPayload<T>>>

    /**
     * Create a JobReferenceList.
     * @param {JobReferenceListCreateArgs} args - Arguments to create a JobReferenceList.
     * @example
     * // Create one JobReferenceList
     * const JobReferenceList = await prisma.jobReferenceList.create({
     *   data: {
     *     // ... data to create a JobReferenceList
     *   }
     * })
     * 
    **/
    create<T extends JobReferenceListCreateArgs>(
      args: SelectSubset<T, JobReferenceListCreateArgs>
    ): Prisma__JobReferenceListClient<JobReferenceListGetPayload<T>>

    /**
     * Create many JobReferenceLists.
     *     @param {JobReferenceListCreateManyArgs} args - Arguments to create many JobReferenceLists.
     *     @example
     *     // Create many JobReferenceLists
     *     const jobReferenceList = await prisma.jobReferenceList.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends JobReferenceListCreateManyArgs>(
      args?: SelectSubset<T, JobReferenceListCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a JobReferenceList.
     * @param {JobReferenceListDeleteArgs} args - Arguments to delete one JobReferenceList.
     * @example
     * // Delete one JobReferenceList
     * const JobReferenceList = await prisma.jobReferenceList.delete({
     *   where: {
     *     // ... filter to delete one JobReferenceList
     *   }
     * })
     * 
    **/
    delete<T extends JobReferenceListDeleteArgs>(
      args: SelectSubset<T, JobReferenceListDeleteArgs>
    ): Prisma__JobReferenceListClient<JobReferenceListGetPayload<T>>

    /**
     * Update one JobReferenceList.
     * @param {JobReferenceListUpdateArgs} args - Arguments to update one JobReferenceList.
     * @example
     * // Update one JobReferenceList
     * const jobReferenceList = await prisma.jobReferenceList.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends JobReferenceListUpdateArgs>(
      args: SelectSubset<T, JobReferenceListUpdateArgs>
    ): Prisma__JobReferenceListClient<JobReferenceListGetPayload<T>>

    /**
     * Delete zero or more JobReferenceLists.
     * @param {JobReferenceListDeleteManyArgs} args - Arguments to filter JobReferenceLists to delete.
     * @example
     * // Delete a few JobReferenceLists
     * const { count } = await prisma.jobReferenceList.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends JobReferenceListDeleteManyArgs>(
      args?: SelectSubset<T, JobReferenceListDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more JobReferenceLists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobReferenceListUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many JobReferenceLists
     * const jobReferenceList = await prisma.jobReferenceList.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends JobReferenceListUpdateManyArgs>(
      args: SelectSubset<T, JobReferenceListUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one JobReferenceList.
     * @param {JobReferenceListUpsertArgs} args - Arguments to update or create a JobReferenceList.
     * @example
     * // Update or create a JobReferenceList
     * const jobReferenceList = await prisma.jobReferenceList.upsert({
     *   create: {
     *     // ... data to create a JobReferenceList
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the JobReferenceList we want to update
     *   }
     * })
    **/
    upsert<T extends JobReferenceListUpsertArgs>(
      args: SelectSubset<T, JobReferenceListUpsertArgs>
    ): Prisma__JobReferenceListClient<JobReferenceListGetPayload<T>>

    /**
     * Count the number of JobReferenceLists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobReferenceListCountArgs} args - Arguments to filter JobReferenceLists to count.
     * @example
     * // Count the number of JobReferenceLists
     * const count = await prisma.jobReferenceList.count({
     *   where: {
     *     // ... the filter for the JobReferenceLists we want to count
     *   }
     * })
    **/
    count<T extends JobReferenceListCountArgs>(
      args?: Subset<T, JobReferenceListCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], JobReferenceListCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a JobReferenceList.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobReferenceListAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends JobReferenceListAggregateArgs>(args: Subset<T, JobReferenceListAggregateArgs>): PrismaPromise<GetJobReferenceListAggregateType<T>>

    /**
     * Group by JobReferenceList.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobReferenceListGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends JobReferenceListGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: JobReferenceListGroupByArgs['orderBy'] }
        : { orderBy?: JobReferenceListGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, JobReferenceListGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetJobReferenceListGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for JobReferenceList.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__JobReferenceListClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    job<T extends JobArgs= {}>(args?: Subset<T, JobArgs>): Prisma__JobClient<JobGetPayload<T> | Null>;

    reference_list<T extends ReferenceListArgs= {}>(args?: Subset<T, ReferenceListArgs>): Prisma__ReferenceListClient<ReferenceListGetPayload<T> | Null>;

    reference_list_item<T extends ReferenceListItemsArgs= {}>(args?: Subset<T, ReferenceListItemsArgs>): Prisma__ReferenceListItemsClient<ReferenceListItemsGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * JobReferenceList base type for findUnique actions
   */
  export type JobReferenceListFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the JobReferenceList
     * 
    **/
    select?: JobReferenceListSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: JobReferenceListInclude | null
    /**
     * Filter, which JobReferenceList to fetch.
     * 
    **/
    where: JobReferenceListWhereUniqueInput
  }

  /**
   * JobReferenceList: findUnique
   */
  export interface JobReferenceListFindUniqueArgs extends JobReferenceListFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * JobReferenceList findUniqueOrThrow
   */
  export type JobReferenceListFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the JobReferenceList
     * 
    **/
    select?: JobReferenceListSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: JobReferenceListInclude | null
    /**
     * Filter, which JobReferenceList to fetch.
     * 
    **/
    where: JobReferenceListWhereUniqueInput
  }


  /**
   * JobReferenceList base type for findFirst actions
   */
  export type JobReferenceListFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the JobReferenceList
     * 
    **/
    select?: JobReferenceListSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: JobReferenceListInclude | null
    /**
     * Filter, which JobReferenceList to fetch.
     * 
    **/
    where?: JobReferenceListWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobReferenceLists to fetch.
     * 
    **/
    orderBy?: Enumerable<JobReferenceListOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JobReferenceLists.
     * 
    **/
    cursor?: JobReferenceListWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JobReferenceLists from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobReferenceLists.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JobReferenceLists.
     * 
    **/
    distinct?: Enumerable<JobReferenceListScalarFieldEnum>
  }

  /**
   * JobReferenceList: findFirst
   */
  export interface JobReferenceListFindFirstArgs extends JobReferenceListFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * JobReferenceList findFirstOrThrow
   */
  export type JobReferenceListFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the JobReferenceList
     * 
    **/
    select?: JobReferenceListSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: JobReferenceListInclude | null
    /**
     * Filter, which JobReferenceList to fetch.
     * 
    **/
    where?: JobReferenceListWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobReferenceLists to fetch.
     * 
    **/
    orderBy?: Enumerable<JobReferenceListOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JobReferenceLists.
     * 
    **/
    cursor?: JobReferenceListWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JobReferenceLists from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobReferenceLists.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JobReferenceLists.
     * 
    **/
    distinct?: Enumerable<JobReferenceListScalarFieldEnum>
  }


  /**
   * JobReferenceList findMany
   */
  export type JobReferenceListFindManyArgs = {
    /**
     * Select specific fields to fetch from the JobReferenceList
     * 
    **/
    select?: JobReferenceListSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: JobReferenceListInclude | null
    /**
     * Filter, which JobReferenceLists to fetch.
     * 
    **/
    where?: JobReferenceListWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobReferenceLists to fetch.
     * 
    **/
    orderBy?: Enumerable<JobReferenceListOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing JobReferenceLists.
     * 
    **/
    cursor?: JobReferenceListWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JobReferenceLists from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobReferenceLists.
     * 
    **/
    skip?: number
    distinct?: Enumerable<JobReferenceListScalarFieldEnum>
  }


  /**
   * JobReferenceList create
   */
  export type JobReferenceListCreateArgs = {
    /**
     * Select specific fields to fetch from the JobReferenceList
     * 
    **/
    select?: JobReferenceListSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: JobReferenceListInclude | null
    /**
     * The data needed to create a JobReferenceList.
     * 
    **/
    data: XOR<JobReferenceListCreateInput, JobReferenceListUncheckedCreateInput>
  }


  /**
   * JobReferenceList createMany
   */
  export type JobReferenceListCreateManyArgs = {
    /**
     * The data used to create many JobReferenceLists.
     * 
    **/
    data: Enumerable<JobReferenceListCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * JobReferenceList update
   */
  export type JobReferenceListUpdateArgs = {
    /**
     * Select specific fields to fetch from the JobReferenceList
     * 
    **/
    select?: JobReferenceListSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: JobReferenceListInclude | null
    /**
     * The data needed to update a JobReferenceList.
     * 
    **/
    data: XOR<JobReferenceListUpdateInput, JobReferenceListUncheckedUpdateInput>
    /**
     * Choose, which JobReferenceList to update.
     * 
    **/
    where: JobReferenceListWhereUniqueInput
  }


  /**
   * JobReferenceList updateMany
   */
  export type JobReferenceListUpdateManyArgs = {
    /**
     * The data used to update JobReferenceLists.
     * 
    **/
    data: XOR<JobReferenceListUpdateManyMutationInput, JobReferenceListUncheckedUpdateManyInput>
    /**
     * Filter which JobReferenceLists to update
     * 
    **/
    where?: JobReferenceListWhereInput
  }


  /**
   * JobReferenceList upsert
   */
  export type JobReferenceListUpsertArgs = {
    /**
     * Select specific fields to fetch from the JobReferenceList
     * 
    **/
    select?: JobReferenceListSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: JobReferenceListInclude | null
    /**
     * The filter to search for the JobReferenceList to update in case it exists.
     * 
    **/
    where: JobReferenceListWhereUniqueInput
    /**
     * In case the JobReferenceList found by the `where` argument doesn't exist, create a new JobReferenceList with this data.
     * 
    **/
    create: XOR<JobReferenceListCreateInput, JobReferenceListUncheckedCreateInput>
    /**
     * In case the JobReferenceList was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<JobReferenceListUpdateInput, JobReferenceListUncheckedUpdateInput>
  }


  /**
   * JobReferenceList delete
   */
  export type JobReferenceListDeleteArgs = {
    /**
     * Select specific fields to fetch from the JobReferenceList
     * 
    **/
    select?: JobReferenceListSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: JobReferenceListInclude | null
    /**
     * Filter which JobReferenceList to delete.
     * 
    **/
    where: JobReferenceListWhereUniqueInput
  }


  /**
   * JobReferenceList deleteMany
   */
  export type JobReferenceListDeleteManyArgs = {
    /**
     * Filter which JobReferenceLists to delete
     * 
    **/
    where?: JobReferenceListWhereInput
  }


  /**
   * JobReferenceList without action
   */
  export type JobReferenceListArgs = {
    /**
     * Select specific fields to fetch from the JobReferenceList
     * 
    **/
    select?: JobReferenceListSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: JobReferenceListInclude | null
  }



  /**
   * Model JobCandidate
   */


  export type AggregateJobCandidate = {
    _count: JobCandidateCountAggregateOutputType | null
    _avg: JobCandidateAvgAggregateOutputType | null
    _sum: JobCandidateSumAggregateOutputType | null
    _min: JobCandidateMinAggregateOutputType | null
    _max: JobCandidateMaxAggregateOutputType | null
  }

  export type JobCandidateAvgAggregateOutputType = {
    candidate_status: number | null
  }

  export type JobCandidateSumAggregateOutputType = {
    candidate_status: number | null
  }

  export type JobCandidateMinAggregateOutputType = {
    job_candidate_id: string | null
    job_id: string | null
    customer_id: string | null
    candidate_status: number | null
    created_at: Date | null
    updated_at: Date | null
    created_by: string | null
    updated_by: string | null
  }

  export type JobCandidateMaxAggregateOutputType = {
    job_candidate_id: string | null
    job_id: string | null
    customer_id: string | null
    candidate_status: number | null
    created_at: Date | null
    updated_at: Date | null
    created_by: string | null
    updated_by: string | null
  }

  export type JobCandidateCountAggregateOutputType = {
    job_candidate_id: number
    job_id: number
    customer_id: number
    candidate_status: number
    created_at: number
    updated_at: number
    created_by: number
    updated_by: number
    _all: number
  }


  export type JobCandidateAvgAggregateInputType = {
    candidate_status?: true
  }

  export type JobCandidateSumAggregateInputType = {
    candidate_status?: true
  }

  export type JobCandidateMinAggregateInputType = {
    job_candidate_id?: true
    job_id?: true
    customer_id?: true
    candidate_status?: true
    created_at?: true
    updated_at?: true
    created_by?: true
    updated_by?: true
  }

  export type JobCandidateMaxAggregateInputType = {
    job_candidate_id?: true
    job_id?: true
    customer_id?: true
    candidate_status?: true
    created_at?: true
    updated_at?: true
    created_by?: true
    updated_by?: true
  }

  export type JobCandidateCountAggregateInputType = {
    job_candidate_id?: true
    job_id?: true
    customer_id?: true
    candidate_status?: true
    created_at?: true
    updated_at?: true
    created_by?: true
    updated_by?: true
    _all?: true
  }

  export type JobCandidateAggregateArgs = {
    /**
     * Filter which JobCandidate to aggregate.
     * 
    **/
    where?: JobCandidateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobCandidates to fetch.
     * 
    **/
    orderBy?: Enumerable<JobCandidateOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: JobCandidateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JobCandidates from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobCandidates.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned JobCandidates
    **/
    _count?: true | JobCandidateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: JobCandidateAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: JobCandidateSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: JobCandidateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: JobCandidateMaxAggregateInputType
  }

  export type GetJobCandidateAggregateType<T extends JobCandidateAggregateArgs> = {
        [P in keyof T & keyof AggregateJobCandidate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateJobCandidate[P]>
      : GetScalarType<T[P], AggregateJobCandidate[P]>
  }




  export type JobCandidateGroupByArgs = {
    where?: JobCandidateWhereInput
    orderBy?: Enumerable<JobCandidateOrderByWithAggregationInput>
    by: Array<JobCandidateScalarFieldEnum>
    having?: JobCandidateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: JobCandidateCountAggregateInputType | true
    _avg?: JobCandidateAvgAggregateInputType
    _sum?: JobCandidateSumAggregateInputType
    _min?: JobCandidateMinAggregateInputType
    _max?: JobCandidateMaxAggregateInputType
  }


  export type JobCandidateGroupByOutputType = {
    job_candidate_id: string
    job_id: string
    customer_id: string
    candidate_status: number
    created_at: Date
    updated_at: Date
    created_by: string | null
    updated_by: string | null
    _count: JobCandidateCountAggregateOutputType | null
    _avg: JobCandidateAvgAggregateOutputType | null
    _sum: JobCandidateSumAggregateOutputType | null
    _min: JobCandidateMinAggregateOutputType | null
    _max: JobCandidateMaxAggregateOutputType | null
  }

  type GetJobCandidateGroupByPayload<T extends JobCandidateGroupByArgs> = PrismaPromise<
    Array<
      PickArray<JobCandidateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof JobCandidateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], JobCandidateGroupByOutputType[P]>
            : GetScalarType<T[P], JobCandidateGroupByOutputType[P]>
        }
      >
    >


  export type JobCandidateSelect = {
    job_candidate_id?: boolean
    job_id?: boolean
    job?: boolean | JobArgs
    customer_id?: boolean
    customer?: boolean | CustomerArgs
    candidate_status?: boolean
    created_at?: boolean
    updated_at?: boolean
    created_by?: boolean
    updated_by?: boolean
  }


  export type JobCandidateInclude = {
    job?: boolean | JobArgs
    customer?: boolean | CustomerArgs
  } 

  export type JobCandidateGetPayload<S extends boolean | null | undefined | JobCandidateArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? JobCandidate :
    S extends undefined ? never :
    S extends { include: any } & (JobCandidateArgs | JobCandidateFindManyArgs)
    ? JobCandidate  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'job' ? JobGetPayload<S['include'][P]> :
        P extends 'customer' ? CustomerGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (JobCandidateArgs | JobCandidateFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'job' ? JobGetPayload<S['select'][P]> :
        P extends 'customer' ? CustomerGetPayload<S['select'][P]> :  P extends keyof JobCandidate ? JobCandidate[P] : never
  } 
      : JobCandidate


  type JobCandidateCountArgs = Merge<
    Omit<JobCandidateFindManyArgs, 'select' | 'include'> & {
      select?: JobCandidateCountAggregateInputType | true
    }
  >

  export interface JobCandidateDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one JobCandidate that matches the filter.
     * @param {JobCandidateFindUniqueArgs} args - Arguments to find a JobCandidate
     * @example
     * // Get one JobCandidate
     * const jobCandidate = await prisma.jobCandidate.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends JobCandidateFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, JobCandidateFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'JobCandidate'> extends True ? Prisma__JobCandidateClient<JobCandidateGetPayload<T>> : Prisma__JobCandidateClient<JobCandidateGetPayload<T> | null, null>

    /**
     * Find one JobCandidate that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {JobCandidateFindUniqueOrThrowArgs} args - Arguments to find a JobCandidate
     * @example
     * // Get one JobCandidate
     * const jobCandidate = await prisma.jobCandidate.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends JobCandidateFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, JobCandidateFindUniqueOrThrowArgs>
    ): Prisma__JobCandidateClient<JobCandidateGetPayload<T>>

    /**
     * Find the first JobCandidate that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobCandidateFindFirstArgs} args - Arguments to find a JobCandidate
     * @example
     * // Get one JobCandidate
     * const jobCandidate = await prisma.jobCandidate.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends JobCandidateFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, JobCandidateFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'JobCandidate'> extends True ? Prisma__JobCandidateClient<JobCandidateGetPayload<T>> : Prisma__JobCandidateClient<JobCandidateGetPayload<T> | null, null>

    /**
     * Find the first JobCandidate that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobCandidateFindFirstOrThrowArgs} args - Arguments to find a JobCandidate
     * @example
     * // Get one JobCandidate
     * const jobCandidate = await prisma.jobCandidate.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends JobCandidateFindFirstOrThrowArgs>(
      args?: SelectSubset<T, JobCandidateFindFirstOrThrowArgs>
    ): Prisma__JobCandidateClient<JobCandidateGetPayload<T>>

    /**
     * Find zero or more JobCandidates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobCandidateFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all JobCandidates
     * const jobCandidates = await prisma.jobCandidate.findMany()
     * 
     * // Get first 10 JobCandidates
     * const jobCandidates = await prisma.jobCandidate.findMany({ take: 10 })
     * 
     * // Only select the `job_candidate_id`
     * const jobCandidateWithJob_candidate_idOnly = await prisma.jobCandidate.findMany({ select: { job_candidate_id: true } })
     * 
    **/
    findMany<T extends JobCandidateFindManyArgs>(
      args?: SelectSubset<T, JobCandidateFindManyArgs>
    ): PrismaPromise<Array<JobCandidateGetPayload<T>>>

    /**
     * Create a JobCandidate.
     * @param {JobCandidateCreateArgs} args - Arguments to create a JobCandidate.
     * @example
     * // Create one JobCandidate
     * const JobCandidate = await prisma.jobCandidate.create({
     *   data: {
     *     // ... data to create a JobCandidate
     *   }
     * })
     * 
    **/
    create<T extends JobCandidateCreateArgs>(
      args: SelectSubset<T, JobCandidateCreateArgs>
    ): Prisma__JobCandidateClient<JobCandidateGetPayload<T>>

    /**
     * Create many JobCandidates.
     *     @param {JobCandidateCreateManyArgs} args - Arguments to create many JobCandidates.
     *     @example
     *     // Create many JobCandidates
     *     const jobCandidate = await prisma.jobCandidate.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends JobCandidateCreateManyArgs>(
      args?: SelectSubset<T, JobCandidateCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a JobCandidate.
     * @param {JobCandidateDeleteArgs} args - Arguments to delete one JobCandidate.
     * @example
     * // Delete one JobCandidate
     * const JobCandidate = await prisma.jobCandidate.delete({
     *   where: {
     *     // ... filter to delete one JobCandidate
     *   }
     * })
     * 
    **/
    delete<T extends JobCandidateDeleteArgs>(
      args: SelectSubset<T, JobCandidateDeleteArgs>
    ): Prisma__JobCandidateClient<JobCandidateGetPayload<T>>

    /**
     * Update one JobCandidate.
     * @param {JobCandidateUpdateArgs} args - Arguments to update one JobCandidate.
     * @example
     * // Update one JobCandidate
     * const jobCandidate = await prisma.jobCandidate.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends JobCandidateUpdateArgs>(
      args: SelectSubset<T, JobCandidateUpdateArgs>
    ): Prisma__JobCandidateClient<JobCandidateGetPayload<T>>

    /**
     * Delete zero or more JobCandidates.
     * @param {JobCandidateDeleteManyArgs} args - Arguments to filter JobCandidates to delete.
     * @example
     * // Delete a few JobCandidates
     * const { count } = await prisma.jobCandidate.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends JobCandidateDeleteManyArgs>(
      args?: SelectSubset<T, JobCandidateDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more JobCandidates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobCandidateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many JobCandidates
     * const jobCandidate = await prisma.jobCandidate.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends JobCandidateUpdateManyArgs>(
      args: SelectSubset<T, JobCandidateUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one JobCandidate.
     * @param {JobCandidateUpsertArgs} args - Arguments to update or create a JobCandidate.
     * @example
     * // Update or create a JobCandidate
     * const jobCandidate = await prisma.jobCandidate.upsert({
     *   create: {
     *     // ... data to create a JobCandidate
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the JobCandidate we want to update
     *   }
     * })
    **/
    upsert<T extends JobCandidateUpsertArgs>(
      args: SelectSubset<T, JobCandidateUpsertArgs>
    ): Prisma__JobCandidateClient<JobCandidateGetPayload<T>>

    /**
     * Count the number of JobCandidates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobCandidateCountArgs} args - Arguments to filter JobCandidates to count.
     * @example
     * // Count the number of JobCandidates
     * const count = await prisma.jobCandidate.count({
     *   where: {
     *     // ... the filter for the JobCandidates we want to count
     *   }
     * })
    **/
    count<T extends JobCandidateCountArgs>(
      args?: Subset<T, JobCandidateCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], JobCandidateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a JobCandidate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobCandidateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends JobCandidateAggregateArgs>(args: Subset<T, JobCandidateAggregateArgs>): PrismaPromise<GetJobCandidateAggregateType<T>>

    /**
     * Group by JobCandidate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobCandidateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends JobCandidateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: JobCandidateGroupByArgs['orderBy'] }
        : { orderBy?: JobCandidateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, JobCandidateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetJobCandidateGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for JobCandidate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__JobCandidateClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    job<T extends JobArgs= {}>(args?: Subset<T, JobArgs>): Prisma__JobClient<JobGetPayload<T> | Null>;

    customer<T extends CustomerArgs= {}>(args?: Subset<T, CustomerArgs>): Prisma__CustomerClient<CustomerGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * JobCandidate base type for findUnique actions
   */
  export type JobCandidateFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the JobCandidate
     * 
    **/
    select?: JobCandidateSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: JobCandidateInclude | null
    /**
     * Filter, which JobCandidate to fetch.
     * 
    **/
    where: JobCandidateWhereUniqueInput
  }

  /**
   * JobCandidate: findUnique
   */
  export interface JobCandidateFindUniqueArgs extends JobCandidateFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * JobCandidate findUniqueOrThrow
   */
  export type JobCandidateFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the JobCandidate
     * 
    **/
    select?: JobCandidateSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: JobCandidateInclude | null
    /**
     * Filter, which JobCandidate to fetch.
     * 
    **/
    where: JobCandidateWhereUniqueInput
  }


  /**
   * JobCandidate base type for findFirst actions
   */
  export type JobCandidateFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the JobCandidate
     * 
    **/
    select?: JobCandidateSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: JobCandidateInclude | null
    /**
     * Filter, which JobCandidate to fetch.
     * 
    **/
    where?: JobCandidateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobCandidates to fetch.
     * 
    **/
    orderBy?: Enumerable<JobCandidateOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JobCandidates.
     * 
    **/
    cursor?: JobCandidateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JobCandidates from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobCandidates.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JobCandidates.
     * 
    **/
    distinct?: Enumerable<JobCandidateScalarFieldEnum>
  }

  /**
   * JobCandidate: findFirst
   */
  export interface JobCandidateFindFirstArgs extends JobCandidateFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * JobCandidate findFirstOrThrow
   */
  export type JobCandidateFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the JobCandidate
     * 
    **/
    select?: JobCandidateSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: JobCandidateInclude | null
    /**
     * Filter, which JobCandidate to fetch.
     * 
    **/
    where?: JobCandidateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobCandidates to fetch.
     * 
    **/
    orderBy?: Enumerable<JobCandidateOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JobCandidates.
     * 
    **/
    cursor?: JobCandidateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JobCandidates from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobCandidates.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JobCandidates.
     * 
    **/
    distinct?: Enumerable<JobCandidateScalarFieldEnum>
  }


  /**
   * JobCandidate findMany
   */
  export type JobCandidateFindManyArgs = {
    /**
     * Select specific fields to fetch from the JobCandidate
     * 
    **/
    select?: JobCandidateSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: JobCandidateInclude | null
    /**
     * Filter, which JobCandidates to fetch.
     * 
    **/
    where?: JobCandidateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobCandidates to fetch.
     * 
    **/
    orderBy?: Enumerable<JobCandidateOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing JobCandidates.
     * 
    **/
    cursor?: JobCandidateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JobCandidates from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobCandidates.
     * 
    **/
    skip?: number
    distinct?: Enumerable<JobCandidateScalarFieldEnum>
  }


  /**
   * JobCandidate create
   */
  export type JobCandidateCreateArgs = {
    /**
     * Select specific fields to fetch from the JobCandidate
     * 
    **/
    select?: JobCandidateSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: JobCandidateInclude | null
    /**
     * The data needed to create a JobCandidate.
     * 
    **/
    data: XOR<JobCandidateCreateInput, JobCandidateUncheckedCreateInput>
  }


  /**
   * JobCandidate createMany
   */
  export type JobCandidateCreateManyArgs = {
    /**
     * The data used to create many JobCandidates.
     * 
    **/
    data: Enumerable<JobCandidateCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * JobCandidate update
   */
  export type JobCandidateUpdateArgs = {
    /**
     * Select specific fields to fetch from the JobCandidate
     * 
    **/
    select?: JobCandidateSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: JobCandidateInclude | null
    /**
     * The data needed to update a JobCandidate.
     * 
    **/
    data: XOR<JobCandidateUpdateInput, JobCandidateUncheckedUpdateInput>
    /**
     * Choose, which JobCandidate to update.
     * 
    **/
    where: JobCandidateWhereUniqueInput
  }


  /**
   * JobCandidate updateMany
   */
  export type JobCandidateUpdateManyArgs = {
    /**
     * The data used to update JobCandidates.
     * 
    **/
    data: XOR<JobCandidateUpdateManyMutationInput, JobCandidateUncheckedUpdateManyInput>
    /**
     * Filter which JobCandidates to update
     * 
    **/
    where?: JobCandidateWhereInput
  }


  /**
   * JobCandidate upsert
   */
  export type JobCandidateUpsertArgs = {
    /**
     * Select specific fields to fetch from the JobCandidate
     * 
    **/
    select?: JobCandidateSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: JobCandidateInclude | null
    /**
     * The filter to search for the JobCandidate to update in case it exists.
     * 
    **/
    where: JobCandidateWhereUniqueInput
    /**
     * In case the JobCandidate found by the `where` argument doesn't exist, create a new JobCandidate with this data.
     * 
    **/
    create: XOR<JobCandidateCreateInput, JobCandidateUncheckedCreateInput>
    /**
     * In case the JobCandidate was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<JobCandidateUpdateInput, JobCandidateUncheckedUpdateInput>
  }


  /**
   * JobCandidate delete
   */
  export type JobCandidateDeleteArgs = {
    /**
     * Select specific fields to fetch from the JobCandidate
     * 
    **/
    select?: JobCandidateSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: JobCandidateInclude | null
    /**
     * Filter which JobCandidate to delete.
     * 
    **/
    where: JobCandidateWhereUniqueInput
  }


  /**
   * JobCandidate deleteMany
   */
  export type JobCandidateDeleteManyArgs = {
    /**
     * Filter which JobCandidates to delete
     * 
    **/
    where?: JobCandidateWhereInput
  }


  /**
   * JobCandidate without action
   */
  export type JobCandidateArgs = {
    /**
     * Select specific fields to fetch from the JobCandidate
     * 
    **/
    select?: JobCandidateSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: JobCandidateInclude | null
  }



  /**
   * Model JobRequirement
   */


  export type AggregateJobRequirement = {
    _count: JobRequirementCountAggregateOutputType | null
    _avg: JobRequirementAvgAggregateOutputType | null
    _sum: JobRequirementSumAggregateOutputType | null
    _min: JobRequirementMinAggregateOutputType | null
    _max: JobRequirementMaxAggregateOutputType | null
  }

  export type JobRequirementAvgAggregateOutputType = {
    require_id: number | null
  }

  export type JobRequirementSumAggregateOutputType = {
    require_id: number | null
  }

  export type JobRequirementMinAggregateOutputType = {
    job_require_id: string | null
    job_id: string | null
    require_id: number | null
    created_at: Date | null
    updated_at: Date | null
    created_by: string | null
    updated_by: string | null
  }

  export type JobRequirementMaxAggregateOutputType = {
    job_require_id: string | null
    job_id: string | null
    require_id: number | null
    created_at: Date | null
    updated_at: Date | null
    created_by: string | null
    updated_by: string | null
  }

  export type JobRequirementCountAggregateOutputType = {
    job_require_id: number
    job_id: number
    require_id: number
    require_detial: number
    created_at: number
    updated_at: number
    created_by: number
    updated_by: number
    _all: number
  }


  export type JobRequirementAvgAggregateInputType = {
    require_id?: true
  }

  export type JobRequirementSumAggregateInputType = {
    require_id?: true
  }

  export type JobRequirementMinAggregateInputType = {
    job_require_id?: true
    job_id?: true
    require_id?: true
    created_at?: true
    updated_at?: true
    created_by?: true
    updated_by?: true
  }

  export type JobRequirementMaxAggregateInputType = {
    job_require_id?: true
    job_id?: true
    require_id?: true
    created_at?: true
    updated_at?: true
    created_by?: true
    updated_by?: true
  }

  export type JobRequirementCountAggregateInputType = {
    job_require_id?: true
    job_id?: true
    require_id?: true
    require_detial?: true
    created_at?: true
    updated_at?: true
    created_by?: true
    updated_by?: true
    _all?: true
  }

  export type JobRequirementAggregateArgs = {
    /**
     * Filter which JobRequirement to aggregate.
     * 
    **/
    where?: JobRequirementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobRequirements to fetch.
     * 
    **/
    orderBy?: Enumerable<JobRequirementOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: JobRequirementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JobRequirements from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobRequirements.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned JobRequirements
    **/
    _count?: true | JobRequirementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: JobRequirementAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: JobRequirementSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: JobRequirementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: JobRequirementMaxAggregateInputType
  }

  export type GetJobRequirementAggregateType<T extends JobRequirementAggregateArgs> = {
        [P in keyof T & keyof AggregateJobRequirement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateJobRequirement[P]>
      : GetScalarType<T[P], AggregateJobRequirement[P]>
  }




  export type JobRequirementGroupByArgs = {
    where?: JobRequirementWhereInput
    orderBy?: Enumerable<JobRequirementOrderByWithAggregationInput>
    by: Array<JobRequirementScalarFieldEnum>
    having?: JobRequirementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: JobRequirementCountAggregateInputType | true
    _avg?: JobRequirementAvgAggregateInputType
    _sum?: JobRequirementSumAggregateInputType
    _min?: JobRequirementMinAggregateInputType
    _max?: JobRequirementMaxAggregateInputType
  }


  export type JobRequirementGroupByOutputType = {
    job_require_id: string
    job_id: string
    require_id: number
    require_detial: JsonValue | null
    created_at: Date
    updated_at: Date
    created_by: string | null
    updated_by: string | null
    _count: JobRequirementCountAggregateOutputType | null
    _avg: JobRequirementAvgAggregateOutputType | null
    _sum: JobRequirementSumAggregateOutputType | null
    _min: JobRequirementMinAggregateOutputType | null
    _max: JobRequirementMaxAggregateOutputType | null
  }

  type GetJobRequirementGroupByPayload<T extends JobRequirementGroupByArgs> = PrismaPromise<
    Array<
      PickArray<JobRequirementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof JobRequirementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], JobRequirementGroupByOutputType[P]>
            : GetScalarType<T[P], JobRequirementGroupByOutputType[P]>
        }
      >
    >


  export type JobRequirementSelect = {
    job_require_id?: boolean
    job_id?: boolean
    jobs?: boolean | JobArgs
    require_id?: boolean
    require_detial?: boolean
    created_at?: boolean
    updated_at?: boolean
    created_by?: boolean
    updated_by?: boolean
  }


  export type JobRequirementInclude = {
    jobs?: boolean | JobArgs
  } 

  export type JobRequirementGetPayload<S extends boolean | null | undefined | JobRequirementArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? JobRequirement :
    S extends undefined ? never :
    S extends { include: any } & (JobRequirementArgs | JobRequirementFindManyArgs)
    ? JobRequirement  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'jobs' ? JobGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (JobRequirementArgs | JobRequirementFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'jobs' ? JobGetPayload<S['select'][P]> :  P extends keyof JobRequirement ? JobRequirement[P] : never
  } 
      : JobRequirement


  type JobRequirementCountArgs = Merge<
    Omit<JobRequirementFindManyArgs, 'select' | 'include'> & {
      select?: JobRequirementCountAggregateInputType | true
    }
  >

  export interface JobRequirementDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one JobRequirement that matches the filter.
     * @param {JobRequirementFindUniqueArgs} args - Arguments to find a JobRequirement
     * @example
     * // Get one JobRequirement
     * const jobRequirement = await prisma.jobRequirement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends JobRequirementFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, JobRequirementFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'JobRequirement'> extends True ? Prisma__JobRequirementClient<JobRequirementGetPayload<T>> : Prisma__JobRequirementClient<JobRequirementGetPayload<T> | null, null>

    /**
     * Find one JobRequirement that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {JobRequirementFindUniqueOrThrowArgs} args - Arguments to find a JobRequirement
     * @example
     * // Get one JobRequirement
     * const jobRequirement = await prisma.jobRequirement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends JobRequirementFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, JobRequirementFindUniqueOrThrowArgs>
    ): Prisma__JobRequirementClient<JobRequirementGetPayload<T>>

    /**
     * Find the first JobRequirement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobRequirementFindFirstArgs} args - Arguments to find a JobRequirement
     * @example
     * // Get one JobRequirement
     * const jobRequirement = await prisma.jobRequirement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends JobRequirementFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, JobRequirementFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'JobRequirement'> extends True ? Prisma__JobRequirementClient<JobRequirementGetPayload<T>> : Prisma__JobRequirementClient<JobRequirementGetPayload<T> | null, null>

    /**
     * Find the first JobRequirement that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobRequirementFindFirstOrThrowArgs} args - Arguments to find a JobRequirement
     * @example
     * // Get one JobRequirement
     * const jobRequirement = await prisma.jobRequirement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends JobRequirementFindFirstOrThrowArgs>(
      args?: SelectSubset<T, JobRequirementFindFirstOrThrowArgs>
    ): Prisma__JobRequirementClient<JobRequirementGetPayload<T>>

    /**
     * Find zero or more JobRequirements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobRequirementFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all JobRequirements
     * const jobRequirements = await prisma.jobRequirement.findMany()
     * 
     * // Get first 10 JobRequirements
     * const jobRequirements = await prisma.jobRequirement.findMany({ take: 10 })
     * 
     * // Only select the `job_require_id`
     * const jobRequirementWithJob_require_idOnly = await prisma.jobRequirement.findMany({ select: { job_require_id: true } })
     * 
    **/
    findMany<T extends JobRequirementFindManyArgs>(
      args?: SelectSubset<T, JobRequirementFindManyArgs>
    ): PrismaPromise<Array<JobRequirementGetPayload<T>>>

    /**
     * Create a JobRequirement.
     * @param {JobRequirementCreateArgs} args - Arguments to create a JobRequirement.
     * @example
     * // Create one JobRequirement
     * const JobRequirement = await prisma.jobRequirement.create({
     *   data: {
     *     // ... data to create a JobRequirement
     *   }
     * })
     * 
    **/
    create<T extends JobRequirementCreateArgs>(
      args: SelectSubset<T, JobRequirementCreateArgs>
    ): Prisma__JobRequirementClient<JobRequirementGetPayload<T>>

    /**
     * Create many JobRequirements.
     *     @param {JobRequirementCreateManyArgs} args - Arguments to create many JobRequirements.
     *     @example
     *     // Create many JobRequirements
     *     const jobRequirement = await prisma.jobRequirement.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends JobRequirementCreateManyArgs>(
      args?: SelectSubset<T, JobRequirementCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a JobRequirement.
     * @param {JobRequirementDeleteArgs} args - Arguments to delete one JobRequirement.
     * @example
     * // Delete one JobRequirement
     * const JobRequirement = await prisma.jobRequirement.delete({
     *   where: {
     *     // ... filter to delete one JobRequirement
     *   }
     * })
     * 
    **/
    delete<T extends JobRequirementDeleteArgs>(
      args: SelectSubset<T, JobRequirementDeleteArgs>
    ): Prisma__JobRequirementClient<JobRequirementGetPayload<T>>

    /**
     * Update one JobRequirement.
     * @param {JobRequirementUpdateArgs} args - Arguments to update one JobRequirement.
     * @example
     * // Update one JobRequirement
     * const jobRequirement = await prisma.jobRequirement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends JobRequirementUpdateArgs>(
      args: SelectSubset<T, JobRequirementUpdateArgs>
    ): Prisma__JobRequirementClient<JobRequirementGetPayload<T>>

    /**
     * Delete zero or more JobRequirements.
     * @param {JobRequirementDeleteManyArgs} args - Arguments to filter JobRequirements to delete.
     * @example
     * // Delete a few JobRequirements
     * const { count } = await prisma.jobRequirement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends JobRequirementDeleteManyArgs>(
      args?: SelectSubset<T, JobRequirementDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more JobRequirements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobRequirementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many JobRequirements
     * const jobRequirement = await prisma.jobRequirement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends JobRequirementUpdateManyArgs>(
      args: SelectSubset<T, JobRequirementUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one JobRequirement.
     * @param {JobRequirementUpsertArgs} args - Arguments to update or create a JobRequirement.
     * @example
     * // Update or create a JobRequirement
     * const jobRequirement = await prisma.jobRequirement.upsert({
     *   create: {
     *     // ... data to create a JobRequirement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the JobRequirement we want to update
     *   }
     * })
    **/
    upsert<T extends JobRequirementUpsertArgs>(
      args: SelectSubset<T, JobRequirementUpsertArgs>
    ): Prisma__JobRequirementClient<JobRequirementGetPayload<T>>

    /**
     * Count the number of JobRequirements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobRequirementCountArgs} args - Arguments to filter JobRequirements to count.
     * @example
     * // Count the number of JobRequirements
     * const count = await prisma.jobRequirement.count({
     *   where: {
     *     // ... the filter for the JobRequirements we want to count
     *   }
     * })
    **/
    count<T extends JobRequirementCountArgs>(
      args?: Subset<T, JobRequirementCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], JobRequirementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a JobRequirement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobRequirementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends JobRequirementAggregateArgs>(args: Subset<T, JobRequirementAggregateArgs>): PrismaPromise<GetJobRequirementAggregateType<T>>

    /**
     * Group by JobRequirement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobRequirementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends JobRequirementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: JobRequirementGroupByArgs['orderBy'] }
        : { orderBy?: JobRequirementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, JobRequirementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetJobRequirementGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for JobRequirement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__JobRequirementClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    jobs<T extends JobArgs= {}>(args?: Subset<T, JobArgs>): Prisma__JobClient<JobGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * JobRequirement base type for findUnique actions
   */
  export type JobRequirementFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the JobRequirement
     * 
    **/
    select?: JobRequirementSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: JobRequirementInclude | null
    /**
     * Filter, which JobRequirement to fetch.
     * 
    **/
    where: JobRequirementWhereUniqueInput
  }

  /**
   * JobRequirement: findUnique
   */
  export interface JobRequirementFindUniqueArgs extends JobRequirementFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * JobRequirement findUniqueOrThrow
   */
  export type JobRequirementFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the JobRequirement
     * 
    **/
    select?: JobRequirementSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: JobRequirementInclude | null
    /**
     * Filter, which JobRequirement to fetch.
     * 
    **/
    where: JobRequirementWhereUniqueInput
  }


  /**
   * JobRequirement base type for findFirst actions
   */
  export type JobRequirementFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the JobRequirement
     * 
    **/
    select?: JobRequirementSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: JobRequirementInclude | null
    /**
     * Filter, which JobRequirement to fetch.
     * 
    **/
    where?: JobRequirementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobRequirements to fetch.
     * 
    **/
    orderBy?: Enumerable<JobRequirementOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JobRequirements.
     * 
    **/
    cursor?: JobRequirementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JobRequirements from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobRequirements.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JobRequirements.
     * 
    **/
    distinct?: Enumerable<JobRequirementScalarFieldEnum>
  }

  /**
   * JobRequirement: findFirst
   */
  export interface JobRequirementFindFirstArgs extends JobRequirementFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * JobRequirement findFirstOrThrow
   */
  export type JobRequirementFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the JobRequirement
     * 
    **/
    select?: JobRequirementSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: JobRequirementInclude | null
    /**
     * Filter, which JobRequirement to fetch.
     * 
    **/
    where?: JobRequirementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobRequirements to fetch.
     * 
    **/
    orderBy?: Enumerable<JobRequirementOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JobRequirements.
     * 
    **/
    cursor?: JobRequirementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JobRequirements from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobRequirements.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JobRequirements.
     * 
    **/
    distinct?: Enumerable<JobRequirementScalarFieldEnum>
  }


  /**
   * JobRequirement findMany
   */
  export type JobRequirementFindManyArgs = {
    /**
     * Select specific fields to fetch from the JobRequirement
     * 
    **/
    select?: JobRequirementSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: JobRequirementInclude | null
    /**
     * Filter, which JobRequirements to fetch.
     * 
    **/
    where?: JobRequirementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobRequirements to fetch.
     * 
    **/
    orderBy?: Enumerable<JobRequirementOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing JobRequirements.
     * 
    **/
    cursor?: JobRequirementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JobRequirements from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobRequirements.
     * 
    **/
    skip?: number
    distinct?: Enumerable<JobRequirementScalarFieldEnum>
  }


  /**
   * JobRequirement create
   */
  export type JobRequirementCreateArgs = {
    /**
     * Select specific fields to fetch from the JobRequirement
     * 
    **/
    select?: JobRequirementSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: JobRequirementInclude | null
    /**
     * The data needed to create a JobRequirement.
     * 
    **/
    data: XOR<JobRequirementCreateInput, JobRequirementUncheckedCreateInput>
  }


  /**
   * JobRequirement createMany
   */
  export type JobRequirementCreateManyArgs = {
    /**
     * The data used to create many JobRequirements.
     * 
    **/
    data: Enumerable<JobRequirementCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * JobRequirement update
   */
  export type JobRequirementUpdateArgs = {
    /**
     * Select specific fields to fetch from the JobRequirement
     * 
    **/
    select?: JobRequirementSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: JobRequirementInclude | null
    /**
     * The data needed to update a JobRequirement.
     * 
    **/
    data: XOR<JobRequirementUpdateInput, JobRequirementUncheckedUpdateInput>
    /**
     * Choose, which JobRequirement to update.
     * 
    **/
    where: JobRequirementWhereUniqueInput
  }


  /**
   * JobRequirement updateMany
   */
  export type JobRequirementUpdateManyArgs = {
    /**
     * The data used to update JobRequirements.
     * 
    **/
    data: XOR<JobRequirementUpdateManyMutationInput, JobRequirementUncheckedUpdateManyInput>
    /**
     * Filter which JobRequirements to update
     * 
    **/
    where?: JobRequirementWhereInput
  }


  /**
   * JobRequirement upsert
   */
  export type JobRequirementUpsertArgs = {
    /**
     * Select specific fields to fetch from the JobRequirement
     * 
    **/
    select?: JobRequirementSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: JobRequirementInclude | null
    /**
     * The filter to search for the JobRequirement to update in case it exists.
     * 
    **/
    where: JobRequirementWhereUniqueInput
    /**
     * In case the JobRequirement found by the `where` argument doesn't exist, create a new JobRequirement with this data.
     * 
    **/
    create: XOR<JobRequirementCreateInput, JobRequirementUncheckedCreateInput>
    /**
     * In case the JobRequirement was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<JobRequirementUpdateInput, JobRequirementUncheckedUpdateInput>
  }


  /**
   * JobRequirement delete
   */
  export type JobRequirementDeleteArgs = {
    /**
     * Select specific fields to fetch from the JobRequirement
     * 
    **/
    select?: JobRequirementSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: JobRequirementInclude | null
    /**
     * Filter which JobRequirement to delete.
     * 
    **/
    where: JobRequirementWhereUniqueInput
  }


  /**
   * JobRequirement deleteMany
   */
  export type JobRequirementDeleteManyArgs = {
    /**
     * Filter which JobRequirements to delete
     * 
    **/
    where?: JobRequirementWhereInput
  }


  /**
   * JobRequirement without action
   */
  export type JobRequirementArgs = {
    /**
     * Select specific fields to fetch from the JobRequirement
     * 
    **/
    select?: JobRequirementSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: JobRequirementInclude | null
  }



  /**
   * Model SystemLangauge
   */


  export type AggregateSystemLangauge = {
    _count: SystemLangaugeCountAggregateOutputType | null
    _avg: SystemLangaugeAvgAggregateOutputType | null
    _sum: SystemLangaugeSumAggregateOutputType | null
    _min: SystemLangaugeMinAggregateOutputType | null
    _max: SystemLangaugeMaxAggregateOutputType | null
  }

  export type SystemLangaugeAvgAggregateOutputType = {
    language_id: number | null
  }

  export type SystemLangaugeSumAggregateOutputType = {
    language_id: number | null
  }

  export type SystemLangaugeMinAggregateOutputType = {
    language_id: number | null
    language_code: string | null
    is_default: boolean | null
  }

  export type SystemLangaugeMaxAggregateOutputType = {
    language_id: number | null
    language_code: string | null
    is_default: boolean | null
  }

  export type SystemLangaugeCountAggregateOutputType = {
    language_id: number
    language_code: number
    is_default: number
    _all: number
  }


  export type SystemLangaugeAvgAggregateInputType = {
    language_id?: true
  }

  export type SystemLangaugeSumAggregateInputType = {
    language_id?: true
  }

  export type SystemLangaugeMinAggregateInputType = {
    language_id?: true
    language_code?: true
    is_default?: true
  }

  export type SystemLangaugeMaxAggregateInputType = {
    language_id?: true
    language_code?: true
    is_default?: true
  }

  export type SystemLangaugeCountAggregateInputType = {
    language_id?: true
    language_code?: true
    is_default?: true
    _all?: true
  }

  export type SystemLangaugeAggregateArgs = {
    /**
     * Filter which SystemLangauge to aggregate.
     * 
    **/
    where?: SystemLangaugeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemLangauges to fetch.
     * 
    **/
    orderBy?: Enumerable<SystemLangaugeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: SystemLangaugeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemLangauges from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemLangauges.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SystemLangauges
    **/
    _count?: true | SystemLangaugeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SystemLangaugeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SystemLangaugeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SystemLangaugeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SystemLangaugeMaxAggregateInputType
  }

  export type GetSystemLangaugeAggregateType<T extends SystemLangaugeAggregateArgs> = {
        [P in keyof T & keyof AggregateSystemLangauge]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSystemLangauge[P]>
      : GetScalarType<T[P], AggregateSystemLangauge[P]>
  }




  export type SystemLangaugeGroupByArgs = {
    where?: SystemLangaugeWhereInput
    orderBy?: Enumerable<SystemLangaugeOrderByWithAggregationInput>
    by: Array<SystemLangaugeScalarFieldEnum>
    having?: SystemLangaugeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SystemLangaugeCountAggregateInputType | true
    _avg?: SystemLangaugeAvgAggregateInputType
    _sum?: SystemLangaugeSumAggregateInputType
    _min?: SystemLangaugeMinAggregateInputType
    _max?: SystemLangaugeMaxAggregateInputType
  }


  export type SystemLangaugeGroupByOutputType = {
    language_id: number
    language_code: string
    is_default: boolean
    _count: SystemLangaugeCountAggregateOutputType | null
    _avg: SystemLangaugeAvgAggregateOutputType | null
    _sum: SystemLangaugeSumAggregateOutputType | null
    _min: SystemLangaugeMinAggregateOutputType | null
    _max: SystemLangaugeMaxAggregateOutputType | null
  }

  type GetSystemLangaugeGroupByPayload<T extends SystemLangaugeGroupByArgs> = PrismaPromise<
    Array<
      PickArray<SystemLangaugeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SystemLangaugeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SystemLangaugeGroupByOutputType[P]>
            : GetScalarType<T[P], SystemLangaugeGroupByOutputType[P]>
        }
      >
    >


  export type SystemLangaugeSelect = {
    language_id?: boolean
    language_code?: boolean
    is_default?: boolean
  }


  export type SystemLangaugeGetPayload<S extends boolean | null | undefined | SystemLangaugeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? SystemLangauge :
    S extends undefined ? never :
    S extends { include: any } & (SystemLangaugeArgs | SystemLangaugeFindManyArgs)
    ? SystemLangauge 
    : S extends { select: any } & (SystemLangaugeArgs | SystemLangaugeFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof SystemLangauge ? SystemLangauge[P] : never
  } 
      : SystemLangauge


  type SystemLangaugeCountArgs = Merge<
    Omit<SystemLangaugeFindManyArgs, 'select' | 'include'> & {
      select?: SystemLangaugeCountAggregateInputType | true
    }
  >

  export interface SystemLangaugeDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one SystemLangauge that matches the filter.
     * @param {SystemLangaugeFindUniqueArgs} args - Arguments to find a SystemLangauge
     * @example
     * // Get one SystemLangauge
     * const systemLangauge = await prisma.systemLangauge.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SystemLangaugeFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, SystemLangaugeFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'SystemLangauge'> extends True ? Prisma__SystemLangaugeClient<SystemLangaugeGetPayload<T>> : Prisma__SystemLangaugeClient<SystemLangaugeGetPayload<T> | null, null>

    /**
     * Find one SystemLangauge that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {SystemLangaugeFindUniqueOrThrowArgs} args - Arguments to find a SystemLangauge
     * @example
     * // Get one SystemLangauge
     * const systemLangauge = await prisma.systemLangauge.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends SystemLangaugeFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, SystemLangaugeFindUniqueOrThrowArgs>
    ): Prisma__SystemLangaugeClient<SystemLangaugeGetPayload<T>>

    /**
     * Find the first SystemLangauge that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemLangaugeFindFirstArgs} args - Arguments to find a SystemLangauge
     * @example
     * // Get one SystemLangauge
     * const systemLangauge = await prisma.systemLangauge.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SystemLangaugeFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, SystemLangaugeFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'SystemLangauge'> extends True ? Prisma__SystemLangaugeClient<SystemLangaugeGetPayload<T>> : Prisma__SystemLangaugeClient<SystemLangaugeGetPayload<T> | null, null>

    /**
     * Find the first SystemLangauge that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemLangaugeFindFirstOrThrowArgs} args - Arguments to find a SystemLangauge
     * @example
     * // Get one SystemLangauge
     * const systemLangauge = await prisma.systemLangauge.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends SystemLangaugeFindFirstOrThrowArgs>(
      args?: SelectSubset<T, SystemLangaugeFindFirstOrThrowArgs>
    ): Prisma__SystemLangaugeClient<SystemLangaugeGetPayload<T>>

    /**
     * Find zero or more SystemLangauges that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemLangaugeFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SystemLangauges
     * const systemLangauges = await prisma.systemLangauge.findMany()
     * 
     * // Get first 10 SystemLangauges
     * const systemLangauges = await prisma.systemLangauge.findMany({ take: 10 })
     * 
     * // Only select the `language_id`
     * const systemLangaugeWithLanguage_idOnly = await prisma.systemLangauge.findMany({ select: { language_id: true } })
     * 
    **/
    findMany<T extends SystemLangaugeFindManyArgs>(
      args?: SelectSubset<T, SystemLangaugeFindManyArgs>
    ): PrismaPromise<Array<SystemLangaugeGetPayload<T>>>

    /**
     * Create a SystemLangauge.
     * @param {SystemLangaugeCreateArgs} args - Arguments to create a SystemLangauge.
     * @example
     * // Create one SystemLangauge
     * const SystemLangauge = await prisma.systemLangauge.create({
     *   data: {
     *     // ... data to create a SystemLangauge
     *   }
     * })
     * 
    **/
    create<T extends SystemLangaugeCreateArgs>(
      args: SelectSubset<T, SystemLangaugeCreateArgs>
    ): Prisma__SystemLangaugeClient<SystemLangaugeGetPayload<T>>

    /**
     * Create many SystemLangauges.
     *     @param {SystemLangaugeCreateManyArgs} args - Arguments to create many SystemLangauges.
     *     @example
     *     // Create many SystemLangauges
     *     const systemLangauge = await prisma.systemLangauge.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SystemLangaugeCreateManyArgs>(
      args?: SelectSubset<T, SystemLangaugeCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a SystemLangauge.
     * @param {SystemLangaugeDeleteArgs} args - Arguments to delete one SystemLangauge.
     * @example
     * // Delete one SystemLangauge
     * const SystemLangauge = await prisma.systemLangauge.delete({
     *   where: {
     *     // ... filter to delete one SystemLangauge
     *   }
     * })
     * 
    **/
    delete<T extends SystemLangaugeDeleteArgs>(
      args: SelectSubset<T, SystemLangaugeDeleteArgs>
    ): Prisma__SystemLangaugeClient<SystemLangaugeGetPayload<T>>

    /**
     * Update one SystemLangauge.
     * @param {SystemLangaugeUpdateArgs} args - Arguments to update one SystemLangauge.
     * @example
     * // Update one SystemLangauge
     * const systemLangauge = await prisma.systemLangauge.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SystemLangaugeUpdateArgs>(
      args: SelectSubset<T, SystemLangaugeUpdateArgs>
    ): Prisma__SystemLangaugeClient<SystemLangaugeGetPayload<T>>

    /**
     * Delete zero or more SystemLangauges.
     * @param {SystemLangaugeDeleteManyArgs} args - Arguments to filter SystemLangauges to delete.
     * @example
     * // Delete a few SystemLangauges
     * const { count } = await prisma.systemLangauge.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SystemLangaugeDeleteManyArgs>(
      args?: SelectSubset<T, SystemLangaugeDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more SystemLangauges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemLangaugeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SystemLangauges
     * const systemLangauge = await prisma.systemLangauge.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SystemLangaugeUpdateManyArgs>(
      args: SelectSubset<T, SystemLangaugeUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one SystemLangauge.
     * @param {SystemLangaugeUpsertArgs} args - Arguments to update or create a SystemLangauge.
     * @example
     * // Update or create a SystemLangauge
     * const systemLangauge = await prisma.systemLangauge.upsert({
     *   create: {
     *     // ... data to create a SystemLangauge
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SystemLangauge we want to update
     *   }
     * })
    **/
    upsert<T extends SystemLangaugeUpsertArgs>(
      args: SelectSubset<T, SystemLangaugeUpsertArgs>
    ): Prisma__SystemLangaugeClient<SystemLangaugeGetPayload<T>>

    /**
     * Count the number of SystemLangauges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemLangaugeCountArgs} args - Arguments to filter SystemLangauges to count.
     * @example
     * // Count the number of SystemLangauges
     * const count = await prisma.systemLangauge.count({
     *   where: {
     *     // ... the filter for the SystemLangauges we want to count
     *   }
     * })
    **/
    count<T extends SystemLangaugeCountArgs>(
      args?: Subset<T, SystemLangaugeCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SystemLangaugeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SystemLangauge.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemLangaugeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SystemLangaugeAggregateArgs>(args: Subset<T, SystemLangaugeAggregateArgs>): PrismaPromise<GetSystemLangaugeAggregateType<T>>

    /**
     * Group by SystemLangauge.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemLangaugeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SystemLangaugeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SystemLangaugeGroupByArgs['orderBy'] }
        : { orderBy?: SystemLangaugeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SystemLangaugeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSystemLangaugeGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for SystemLangauge.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__SystemLangaugeClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * SystemLangauge base type for findUnique actions
   */
  export type SystemLangaugeFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the SystemLangauge
     * 
    **/
    select?: SystemLangaugeSelect | null
    /**
     * Filter, which SystemLangauge to fetch.
     * 
    **/
    where: SystemLangaugeWhereUniqueInput
  }

  /**
   * SystemLangauge: findUnique
   */
  export interface SystemLangaugeFindUniqueArgs extends SystemLangaugeFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * SystemLangauge findUniqueOrThrow
   */
  export type SystemLangaugeFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the SystemLangauge
     * 
    **/
    select?: SystemLangaugeSelect | null
    /**
     * Filter, which SystemLangauge to fetch.
     * 
    **/
    where: SystemLangaugeWhereUniqueInput
  }


  /**
   * SystemLangauge base type for findFirst actions
   */
  export type SystemLangaugeFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the SystemLangauge
     * 
    **/
    select?: SystemLangaugeSelect | null
    /**
     * Filter, which SystemLangauge to fetch.
     * 
    **/
    where?: SystemLangaugeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemLangauges to fetch.
     * 
    **/
    orderBy?: Enumerable<SystemLangaugeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SystemLangauges.
     * 
    **/
    cursor?: SystemLangaugeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemLangauges from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemLangauges.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SystemLangauges.
     * 
    **/
    distinct?: Enumerable<SystemLangaugeScalarFieldEnum>
  }

  /**
   * SystemLangauge: findFirst
   */
  export interface SystemLangaugeFindFirstArgs extends SystemLangaugeFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * SystemLangauge findFirstOrThrow
   */
  export type SystemLangaugeFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the SystemLangauge
     * 
    **/
    select?: SystemLangaugeSelect | null
    /**
     * Filter, which SystemLangauge to fetch.
     * 
    **/
    where?: SystemLangaugeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemLangauges to fetch.
     * 
    **/
    orderBy?: Enumerable<SystemLangaugeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SystemLangauges.
     * 
    **/
    cursor?: SystemLangaugeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemLangauges from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemLangauges.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SystemLangauges.
     * 
    **/
    distinct?: Enumerable<SystemLangaugeScalarFieldEnum>
  }


  /**
   * SystemLangauge findMany
   */
  export type SystemLangaugeFindManyArgs = {
    /**
     * Select specific fields to fetch from the SystemLangauge
     * 
    **/
    select?: SystemLangaugeSelect | null
    /**
     * Filter, which SystemLangauges to fetch.
     * 
    **/
    where?: SystemLangaugeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemLangauges to fetch.
     * 
    **/
    orderBy?: Enumerable<SystemLangaugeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SystemLangauges.
     * 
    **/
    cursor?: SystemLangaugeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemLangauges from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemLangauges.
     * 
    **/
    skip?: number
    distinct?: Enumerable<SystemLangaugeScalarFieldEnum>
  }


  /**
   * SystemLangauge create
   */
  export type SystemLangaugeCreateArgs = {
    /**
     * Select specific fields to fetch from the SystemLangauge
     * 
    **/
    select?: SystemLangaugeSelect | null
    /**
     * The data needed to create a SystemLangauge.
     * 
    **/
    data: XOR<SystemLangaugeCreateInput, SystemLangaugeUncheckedCreateInput>
  }


  /**
   * SystemLangauge createMany
   */
  export type SystemLangaugeCreateManyArgs = {
    /**
     * The data used to create many SystemLangauges.
     * 
    **/
    data: Enumerable<SystemLangaugeCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * SystemLangauge update
   */
  export type SystemLangaugeUpdateArgs = {
    /**
     * Select specific fields to fetch from the SystemLangauge
     * 
    **/
    select?: SystemLangaugeSelect | null
    /**
     * The data needed to update a SystemLangauge.
     * 
    **/
    data: XOR<SystemLangaugeUpdateInput, SystemLangaugeUncheckedUpdateInput>
    /**
     * Choose, which SystemLangauge to update.
     * 
    **/
    where: SystemLangaugeWhereUniqueInput
  }


  /**
   * SystemLangauge updateMany
   */
  export type SystemLangaugeUpdateManyArgs = {
    /**
     * The data used to update SystemLangauges.
     * 
    **/
    data: XOR<SystemLangaugeUpdateManyMutationInput, SystemLangaugeUncheckedUpdateManyInput>
    /**
     * Filter which SystemLangauges to update
     * 
    **/
    where?: SystemLangaugeWhereInput
  }


  /**
   * SystemLangauge upsert
   */
  export type SystemLangaugeUpsertArgs = {
    /**
     * Select specific fields to fetch from the SystemLangauge
     * 
    **/
    select?: SystemLangaugeSelect | null
    /**
     * The filter to search for the SystemLangauge to update in case it exists.
     * 
    **/
    where: SystemLangaugeWhereUniqueInput
    /**
     * In case the SystemLangauge found by the `where` argument doesn't exist, create a new SystemLangauge with this data.
     * 
    **/
    create: XOR<SystemLangaugeCreateInput, SystemLangaugeUncheckedCreateInput>
    /**
     * In case the SystemLangauge was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<SystemLangaugeUpdateInput, SystemLangaugeUncheckedUpdateInput>
  }


  /**
   * SystemLangauge delete
   */
  export type SystemLangaugeDeleteArgs = {
    /**
     * Select specific fields to fetch from the SystemLangauge
     * 
    **/
    select?: SystemLangaugeSelect | null
    /**
     * Filter which SystemLangauge to delete.
     * 
    **/
    where: SystemLangaugeWhereUniqueInput
  }


  /**
   * SystemLangauge deleteMany
   */
  export type SystemLangaugeDeleteManyArgs = {
    /**
     * Filter which SystemLangauges to delete
     * 
    **/
    where?: SystemLangaugeWhereInput
  }


  /**
   * SystemLangauge without action
   */
  export type SystemLangaugeArgs = {
    /**
     * Select specific fields to fetch from the SystemLangauge
     * 
    **/
    select?: SystemLangaugeSelect | null
  }



  /**
   * Model Logger
   */


  export type AggregateLogger = {
    _count: LoggerCountAggregateOutputType | null
    _min: LoggerMinAggregateOutputType | null
    _max: LoggerMaxAggregateOutputType | null
  }

  export type LoggerMinAggregateOutputType = {
    log_id: string | null
    action_user: UserAction | null
    user_id: string | null
    created_at: Date | null
    updated_at: Date | null
    created_by: string | null
    updated_by: string | null
  }

  export type LoggerMaxAggregateOutputType = {
    log_id: string | null
    action_user: UserAction | null
    user_id: string | null
    created_at: Date | null
    updated_at: Date | null
    created_by: string | null
    updated_by: string | null
  }

  export type LoggerCountAggregateOutputType = {
    log_id: number
    action_user: number
    user_id: number
    new_value: number
    old_value: number
    created_at: number
    updated_at: number
    created_by: number
    updated_by: number
    _all: number
  }


  export type LoggerMinAggregateInputType = {
    log_id?: true
    action_user?: true
    user_id?: true
    created_at?: true
    updated_at?: true
    created_by?: true
    updated_by?: true
  }

  export type LoggerMaxAggregateInputType = {
    log_id?: true
    action_user?: true
    user_id?: true
    created_at?: true
    updated_at?: true
    created_by?: true
    updated_by?: true
  }

  export type LoggerCountAggregateInputType = {
    log_id?: true
    action_user?: true
    user_id?: true
    new_value?: true
    old_value?: true
    created_at?: true
    updated_at?: true
    created_by?: true
    updated_by?: true
    _all?: true
  }

  export type LoggerAggregateArgs = {
    /**
     * Filter which Logger to aggregate.
     * 
    **/
    where?: LoggerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Loggers to fetch.
     * 
    **/
    orderBy?: Enumerable<LoggerOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: LoggerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Loggers from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Loggers.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Loggers
    **/
    _count?: true | LoggerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LoggerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LoggerMaxAggregateInputType
  }

  export type GetLoggerAggregateType<T extends LoggerAggregateArgs> = {
        [P in keyof T & keyof AggregateLogger]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLogger[P]>
      : GetScalarType<T[P], AggregateLogger[P]>
  }




  export type LoggerGroupByArgs = {
    where?: LoggerWhereInput
    orderBy?: Enumerable<LoggerOrderByWithAggregationInput>
    by: Array<LoggerScalarFieldEnum>
    having?: LoggerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LoggerCountAggregateInputType | true
    _min?: LoggerMinAggregateInputType
    _max?: LoggerMaxAggregateInputType
  }


  export type LoggerGroupByOutputType = {
    log_id: string
    action_user: UserAction
    user_id: string | null
    new_value: JsonValue | null
    old_value: JsonValue | null
    created_at: Date
    updated_at: Date
    created_by: string | null
    updated_by: string | null
    _count: LoggerCountAggregateOutputType | null
    _min: LoggerMinAggregateOutputType | null
    _max: LoggerMaxAggregateOutputType | null
  }

  type GetLoggerGroupByPayload<T extends LoggerGroupByArgs> = PrismaPromise<
    Array<
      PickArray<LoggerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LoggerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LoggerGroupByOutputType[P]>
            : GetScalarType<T[P], LoggerGroupByOutputType[P]>
        }
      >
    >


  export type LoggerSelect = {
    log_id?: boolean
    action_user?: boolean
    user_id?: boolean
    User?: boolean | UserArgs
    new_value?: boolean
    old_value?: boolean
    created_at?: boolean
    updated_at?: boolean
    created_by?: boolean
    updated_by?: boolean
  }


  export type LoggerInclude = {
    User?: boolean | UserArgs
  } 

  export type LoggerGetPayload<S extends boolean | null | undefined | LoggerArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Logger :
    S extends undefined ? never :
    S extends { include: any } & (LoggerArgs | LoggerFindManyArgs)
    ? Logger  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'User' ? UserGetPayload<S['include'][P]> | null :  never
  } 
    : S extends { select: any } & (LoggerArgs | LoggerFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'User' ? UserGetPayload<S['select'][P]> | null :  P extends keyof Logger ? Logger[P] : never
  } 
      : Logger


  type LoggerCountArgs = Merge<
    Omit<LoggerFindManyArgs, 'select' | 'include'> & {
      select?: LoggerCountAggregateInputType | true
    }
  >

  export interface LoggerDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Logger that matches the filter.
     * @param {LoggerFindUniqueArgs} args - Arguments to find a Logger
     * @example
     * // Get one Logger
     * const logger = await prisma.logger.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends LoggerFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, LoggerFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Logger'> extends True ? Prisma__LoggerClient<LoggerGetPayload<T>> : Prisma__LoggerClient<LoggerGetPayload<T> | null, null>

    /**
     * Find one Logger that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {LoggerFindUniqueOrThrowArgs} args - Arguments to find a Logger
     * @example
     * // Get one Logger
     * const logger = await prisma.logger.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends LoggerFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, LoggerFindUniqueOrThrowArgs>
    ): Prisma__LoggerClient<LoggerGetPayload<T>>

    /**
     * Find the first Logger that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoggerFindFirstArgs} args - Arguments to find a Logger
     * @example
     * // Get one Logger
     * const logger = await prisma.logger.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends LoggerFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, LoggerFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Logger'> extends True ? Prisma__LoggerClient<LoggerGetPayload<T>> : Prisma__LoggerClient<LoggerGetPayload<T> | null, null>

    /**
     * Find the first Logger that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoggerFindFirstOrThrowArgs} args - Arguments to find a Logger
     * @example
     * // Get one Logger
     * const logger = await prisma.logger.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends LoggerFindFirstOrThrowArgs>(
      args?: SelectSubset<T, LoggerFindFirstOrThrowArgs>
    ): Prisma__LoggerClient<LoggerGetPayload<T>>

    /**
     * Find zero or more Loggers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoggerFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Loggers
     * const loggers = await prisma.logger.findMany()
     * 
     * // Get first 10 Loggers
     * const loggers = await prisma.logger.findMany({ take: 10 })
     * 
     * // Only select the `log_id`
     * const loggerWithLog_idOnly = await prisma.logger.findMany({ select: { log_id: true } })
     * 
    **/
    findMany<T extends LoggerFindManyArgs>(
      args?: SelectSubset<T, LoggerFindManyArgs>
    ): PrismaPromise<Array<LoggerGetPayload<T>>>

    /**
     * Create a Logger.
     * @param {LoggerCreateArgs} args - Arguments to create a Logger.
     * @example
     * // Create one Logger
     * const Logger = await prisma.logger.create({
     *   data: {
     *     // ... data to create a Logger
     *   }
     * })
     * 
    **/
    create<T extends LoggerCreateArgs>(
      args: SelectSubset<T, LoggerCreateArgs>
    ): Prisma__LoggerClient<LoggerGetPayload<T>>

    /**
     * Create many Loggers.
     *     @param {LoggerCreateManyArgs} args - Arguments to create many Loggers.
     *     @example
     *     // Create many Loggers
     *     const logger = await prisma.logger.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends LoggerCreateManyArgs>(
      args?: SelectSubset<T, LoggerCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Logger.
     * @param {LoggerDeleteArgs} args - Arguments to delete one Logger.
     * @example
     * // Delete one Logger
     * const Logger = await prisma.logger.delete({
     *   where: {
     *     // ... filter to delete one Logger
     *   }
     * })
     * 
    **/
    delete<T extends LoggerDeleteArgs>(
      args: SelectSubset<T, LoggerDeleteArgs>
    ): Prisma__LoggerClient<LoggerGetPayload<T>>

    /**
     * Update one Logger.
     * @param {LoggerUpdateArgs} args - Arguments to update one Logger.
     * @example
     * // Update one Logger
     * const logger = await prisma.logger.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends LoggerUpdateArgs>(
      args: SelectSubset<T, LoggerUpdateArgs>
    ): Prisma__LoggerClient<LoggerGetPayload<T>>

    /**
     * Delete zero or more Loggers.
     * @param {LoggerDeleteManyArgs} args - Arguments to filter Loggers to delete.
     * @example
     * // Delete a few Loggers
     * const { count } = await prisma.logger.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends LoggerDeleteManyArgs>(
      args?: SelectSubset<T, LoggerDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Loggers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoggerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Loggers
     * const logger = await prisma.logger.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends LoggerUpdateManyArgs>(
      args: SelectSubset<T, LoggerUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Logger.
     * @param {LoggerUpsertArgs} args - Arguments to update or create a Logger.
     * @example
     * // Update or create a Logger
     * const logger = await prisma.logger.upsert({
     *   create: {
     *     // ... data to create a Logger
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Logger we want to update
     *   }
     * })
    **/
    upsert<T extends LoggerUpsertArgs>(
      args: SelectSubset<T, LoggerUpsertArgs>
    ): Prisma__LoggerClient<LoggerGetPayload<T>>

    /**
     * Count the number of Loggers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoggerCountArgs} args - Arguments to filter Loggers to count.
     * @example
     * // Count the number of Loggers
     * const count = await prisma.logger.count({
     *   where: {
     *     // ... the filter for the Loggers we want to count
     *   }
     * })
    **/
    count<T extends LoggerCountArgs>(
      args?: Subset<T, LoggerCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LoggerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Logger.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoggerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LoggerAggregateArgs>(args: Subset<T, LoggerAggregateArgs>): PrismaPromise<GetLoggerAggregateType<T>>

    /**
     * Group by Logger.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoggerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LoggerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LoggerGroupByArgs['orderBy'] }
        : { orderBy?: LoggerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LoggerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLoggerGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Logger.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__LoggerClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    User<T extends UserArgs= {}>(args?: Subset<T, UserArgs>): Prisma__UserClient<UserGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Logger base type for findUnique actions
   */
  export type LoggerFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Logger
     * 
    **/
    select?: LoggerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: LoggerInclude | null
    /**
     * Filter, which Logger to fetch.
     * 
    **/
    where: LoggerWhereUniqueInput
  }

  /**
   * Logger: findUnique
   */
  export interface LoggerFindUniqueArgs extends LoggerFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Logger findUniqueOrThrow
   */
  export type LoggerFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Logger
     * 
    **/
    select?: LoggerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: LoggerInclude | null
    /**
     * Filter, which Logger to fetch.
     * 
    **/
    where: LoggerWhereUniqueInput
  }


  /**
   * Logger base type for findFirst actions
   */
  export type LoggerFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Logger
     * 
    **/
    select?: LoggerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: LoggerInclude | null
    /**
     * Filter, which Logger to fetch.
     * 
    **/
    where?: LoggerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Loggers to fetch.
     * 
    **/
    orderBy?: Enumerable<LoggerOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Loggers.
     * 
    **/
    cursor?: LoggerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Loggers from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Loggers.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Loggers.
     * 
    **/
    distinct?: Enumerable<LoggerScalarFieldEnum>
  }

  /**
   * Logger: findFirst
   */
  export interface LoggerFindFirstArgs extends LoggerFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Logger findFirstOrThrow
   */
  export type LoggerFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Logger
     * 
    **/
    select?: LoggerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: LoggerInclude | null
    /**
     * Filter, which Logger to fetch.
     * 
    **/
    where?: LoggerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Loggers to fetch.
     * 
    **/
    orderBy?: Enumerable<LoggerOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Loggers.
     * 
    **/
    cursor?: LoggerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Loggers from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Loggers.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Loggers.
     * 
    **/
    distinct?: Enumerable<LoggerScalarFieldEnum>
  }


  /**
   * Logger findMany
   */
  export type LoggerFindManyArgs = {
    /**
     * Select specific fields to fetch from the Logger
     * 
    **/
    select?: LoggerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: LoggerInclude | null
    /**
     * Filter, which Loggers to fetch.
     * 
    **/
    where?: LoggerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Loggers to fetch.
     * 
    **/
    orderBy?: Enumerable<LoggerOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Loggers.
     * 
    **/
    cursor?: LoggerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Loggers from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Loggers.
     * 
    **/
    skip?: number
    distinct?: Enumerable<LoggerScalarFieldEnum>
  }


  /**
   * Logger create
   */
  export type LoggerCreateArgs = {
    /**
     * Select specific fields to fetch from the Logger
     * 
    **/
    select?: LoggerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: LoggerInclude | null
    /**
     * The data needed to create a Logger.
     * 
    **/
    data: XOR<LoggerCreateInput, LoggerUncheckedCreateInput>
  }


  /**
   * Logger createMany
   */
  export type LoggerCreateManyArgs = {
    /**
     * The data used to create many Loggers.
     * 
    **/
    data: Enumerable<LoggerCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Logger update
   */
  export type LoggerUpdateArgs = {
    /**
     * Select specific fields to fetch from the Logger
     * 
    **/
    select?: LoggerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: LoggerInclude | null
    /**
     * The data needed to update a Logger.
     * 
    **/
    data: XOR<LoggerUpdateInput, LoggerUncheckedUpdateInput>
    /**
     * Choose, which Logger to update.
     * 
    **/
    where: LoggerWhereUniqueInput
  }


  /**
   * Logger updateMany
   */
  export type LoggerUpdateManyArgs = {
    /**
     * The data used to update Loggers.
     * 
    **/
    data: XOR<LoggerUpdateManyMutationInput, LoggerUncheckedUpdateManyInput>
    /**
     * Filter which Loggers to update
     * 
    **/
    where?: LoggerWhereInput
  }


  /**
   * Logger upsert
   */
  export type LoggerUpsertArgs = {
    /**
     * Select specific fields to fetch from the Logger
     * 
    **/
    select?: LoggerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: LoggerInclude | null
    /**
     * The filter to search for the Logger to update in case it exists.
     * 
    **/
    where: LoggerWhereUniqueInput
    /**
     * In case the Logger found by the `where` argument doesn't exist, create a new Logger with this data.
     * 
    **/
    create: XOR<LoggerCreateInput, LoggerUncheckedCreateInput>
    /**
     * In case the Logger was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<LoggerUpdateInput, LoggerUncheckedUpdateInput>
  }


  /**
   * Logger delete
   */
  export type LoggerDeleteArgs = {
    /**
     * Select specific fields to fetch from the Logger
     * 
    **/
    select?: LoggerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: LoggerInclude | null
    /**
     * Filter which Logger to delete.
     * 
    **/
    where: LoggerWhereUniqueInput
  }


  /**
   * Logger deleteMany
   */
  export type LoggerDeleteManyArgs = {
    /**
     * Filter which Loggers to delete
     * 
    **/
    where?: LoggerWhereInput
  }


  /**
   * Logger without action
   */
  export type LoggerArgs = {
    /**
     * Select specific fields to fetch from the Logger
     * 
    **/
    select?: LoggerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: LoggerInclude | null
  }



  /**
   * Model News
   */


  export type AggregateNews = {
    _count: NewsCountAggregateOutputType | null
    _avg: NewsAvgAggregateOutputType | null
    _sum: NewsSumAggregateOutputType | null
    _min: NewsMinAggregateOutputType | null
    _max: NewsMaxAggregateOutputType | null
  }

  export type NewsAvgAggregateOutputType = {
    page_id: number | null
  }

  export type NewsSumAggregateOutputType = {
    page_id: number | null
  }

  export type NewsMinAggregateOutputType = {
    news_id: string | null
    page_id: number | null
    title: string | null
    brief: string | null
    image_id: string | null
    content: string | null
    is_top: boolean | null
    is_publish: boolean | null
    created_at: Date | null
    updated_at: Date | null
    created_by: string | null
    update_by: string | null
  }

  export type NewsMaxAggregateOutputType = {
    news_id: string | null
    page_id: number | null
    title: string | null
    brief: string | null
    image_id: string | null
    content: string | null
    is_top: boolean | null
    is_publish: boolean | null
    created_at: Date | null
    updated_at: Date | null
    created_by: string | null
    update_by: string | null
  }

  export type NewsCountAggregateOutputType = {
    news_id: number
    page_id: number
    title: number
    brief: number
    image_id: number
    content: number
    is_top: number
    is_publish: number
    created_at: number
    updated_at: number
    created_by: number
    update_by: number
    _all: number
  }


  export type NewsAvgAggregateInputType = {
    page_id?: true
  }

  export type NewsSumAggregateInputType = {
    page_id?: true
  }

  export type NewsMinAggregateInputType = {
    news_id?: true
    page_id?: true
    title?: true
    brief?: true
    image_id?: true
    content?: true
    is_top?: true
    is_publish?: true
    created_at?: true
    updated_at?: true
    created_by?: true
    update_by?: true
  }

  export type NewsMaxAggregateInputType = {
    news_id?: true
    page_id?: true
    title?: true
    brief?: true
    image_id?: true
    content?: true
    is_top?: true
    is_publish?: true
    created_at?: true
    updated_at?: true
    created_by?: true
    update_by?: true
  }

  export type NewsCountAggregateInputType = {
    news_id?: true
    page_id?: true
    title?: true
    brief?: true
    image_id?: true
    content?: true
    is_top?: true
    is_publish?: true
    created_at?: true
    updated_at?: true
    created_by?: true
    update_by?: true
    _all?: true
  }

  export type NewsAggregateArgs = {
    /**
     * Filter which News to aggregate.
     * 
    **/
    where?: NewsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of News to fetch.
     * 
    **/
    orderBy?: Enumerable<NewsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: NewsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` News from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` News.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned News
    **/
    _count?: true | NewsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NewsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NewsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NewsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NewsMaxAggregateInputType
  }

  export type GetNewsAggregateType<T extends NewsAggregateArgs> = {
        [P in keyof T & keyof AggregateNews]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNews[P]>
      : GetScalarType<T[P], AggregateNews[P]>
  }




  export type NewsGroupByArgs = {
    where?: NewsWhereInput
    orderBy?: Enumerable<NewsOrderByWithAggregationInput>
    by: Array<NewsScalarFieldEnum>
    having?: NewsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NewsCountAggregateInputType | true
    _avg?: NewsAvgAggregateInputType
    _sum?: NewsSumAggregateInputType
    _min?: NewsMinAggregateInputType
    _max?: NewsMaxAggregateInputType
  }


  export type NewsGroupByOutputType = {
    news_id: string
    page_id: number
    title: string
    brief: string
    image_id: string
    content: string
    is_top: boolean
    is_publish: boolean
    created_at: Date
    updated_at: Date
    created_by: string
    update_by: string
    _count: NewsCountAggregateOutputType | null
    _avg: NewsAvgAggregateOutputType | null
    _sum: NewsSumAggregateOutputType | null
    _min: NewsMinAggregateOutputType | null
    _max: NewsMaxAggregateOutputType | null
  }

  type GetNewsGroupByPayload<T extends NewsGroupByArgs> = PrismaPromise<
    Array<
      PickArray<NewsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NewsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NewsGroupByOutputType[P]>
            : GetScalarType<T[P], NewsGroupByOutputType[P]>
        }
      >
    >


  export type NewsSelect = {
    news_id?: boolean
    page_id?: boolean
    pages?: boolean | PagesArgs
    title?: boolean
    brief?: boolean
    image_id?: boolean
    content?: boolean
    is_top?: boolean
    is_publish?: boolean
    created_at?: boolean
    updated_at?: boolean
    created_by?: boolean
    update_by?: boolean
  }


  export type NewsInclude = {
    pages?: boolean | PagesArgs
  } 

  export type NewsGetPayload<S extends boolean | null | undefined | NewsArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? News :
    S extends undefined ? never :
    S extends { include: any } & (NewsArgs | NewsFindManyArgs)
    ? News  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'pages' ? PagesGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (NewsArgs | NewsFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'pages' ? PagesGetPayload<S['select'][P]> :  P extends keyof News ? News[P] : never
  } 
      : News


  type NewsCountArgs = Merge<
    Omit<NewsFindManyArgs, 'select' | 'include'> & {
      select?: NewsCountAggregateInputType | true
    }
  >

  export interface NewsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one News that matches the filter.
     * @param {NewsFindUniqueArgs} args - Arguments to find a News
     * @example
     * // Get one News
     * const news = await prisma.news.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends NewsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, NewsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'News'> extends True ? Prisma__NewsClient<NewsGetPayload<T>> : Prisma__NewsClient<NewsGetPayload<T> | null, null>

    /**
     * Find one News that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {NewsFindUniqueOrThrowArgs} args - Arguments to find a News
     * @example
     * // Get one News
     * const news = await prisma.news.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends NewsFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, NewsFindUniqueOrThrowArgs>
    ): Prisma__NewsClient<NewsGetPayload<T>>

    /**
     * Find the first News that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsFindFirstArgs} args - Arguments to find a News
     * @example
     * // Get one News
     * const news = await prisma.news.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends NewsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, NewsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'News'> extends True ? Prisma__NewsClient<NewsGetPayload<T>> : Prisma__NewsClient<NewsGetPayload<T> | null, null>

    /**
     * Find the first News that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsFindFirstOrThrowArgs} args - Arguments to find a News
     * @example
     * // Get one News
     * const news = await prisma.news.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends NewsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, NewsFindFirstOrThrowArgs>
    ): Prisma__NewsClient<NewsGetPayload<T>>

    /**
     * Find zero or more News that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all News
     * const news = await prisma.news.findMany()
     * 
     * // Get first 10 News
     * const news = await prisma.news.findMany({ take: 10 })
     * 
     * // Only select the `news_id`
     * const newsWithNews_idOnly = await prisma.news.findMany({ select: { news_id: true } })
     * 
    **/
    findMany<T extends NewsFindManyArgs>(
      args?: SelectSubset<T, NewsFindManyArgs>
    ): PrismaPromise<Array<NewsGetPayload<T>>>

    /**
     * Create a News.
     * @param {NewsCreateArgs} args - Arguments to create a News.
     * @example
     * // Create one News
     * const News = await prisma.news.create({
     *   data: {
     *     // ... data to create a News
     *   }
     * })
     * 
    **/
    create<T extends NewsCreateArgs>(
      args: SelectSubset<T, NewsCreateArgs>
    ): Prisma__NewsClient<NewsGetPayload<T>>

    /**
     * Create many News.
     *     @param {NewsCreateManyArgs} args - Arguments to create many News.
     *     @example
     *     // Create many News
     *     const news = await prisma.news.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends NewsCreateManyArgs>(
      args?: SelectSubset<T, NewsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a News.
     * @param {NewsDeleteArgs} args - Arguments to delete one News.
     * @example
     * // Delete one News
     * const News = await prisma.news.delete({
     *   where: {
     *     // ... filter to delete one News
     *   }
     * })
     * 
    **/
    delete<T extends NewsDeleteArgs>(
      args: SelectSubset<T, NewsDeleteArgs>
    ): Prisma__NewsClient<NewsGetPayload<T>>

    /**
     * Update one News.
     * @param {NewsUpdateArgs} args - Arguments to update one News.
     * @example
     * // Update one News
     * const news = await prisma.news.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends NewsUpdateArgs>(
      args: SelectSubset<T, NewsUpdateArgs>
    ): Prisma__NewsClient<NewsGetPayload<T>>

    /**
     * Delete zero or more News.
     * @param {NewsDeleteManyArgs} args - Arguments to filter News to delete.
     * @example
     * // Delete a few News
     * const { count } = await prisma.news.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends NewsDeleteManyArgs>(
      args?: SelectSubset<T, NewsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more News.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many News
     * const news = await prisma.news.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends NewsUpdateManyArgs>(
      args: SelectSubset<T, NewsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one News.
     * @param {NewsUpsertArgs} args - Arguments to update or create a News.
     * @example
     * // Update or create a News
     * const news = await prisma.news.upsert({
     *   create: {
     *     // ... data to create a News
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the News we want to update
     *   }
     * })
    **/
    upsert<T extends NewsUpsertArgs>(
      args: SelectSubset<T, NewsUpsertArgs>
    ): Prisma__NewsClient<NewsGetPayload<T>>

    /**
     * Count the number of News.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsCountArgs} args - Arguments to filter News to count.
     * @example
     * // Count the number of News
     * const count = await prisma.news.count({
     *   where: {
     *     // ... the filter for the News we want to count
     *   }
     * })
    **/
    count<T extends NewsCountArgs>(
      args?: Subset<T, NewsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NewsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a News.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NewsAggregateArgs>(args: Subset<T, NewsAggregateArgs>): PrismaPromise<GetNewsAggregateType<T>>

    /**
     * Group by News.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NewsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NewsGroupByArgs['orderBy'] }
        : { orderBy?: NewsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NewsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNewsGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for News.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__NewsClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    pages<T extends PagesArgs= {}>(args?: Subset<T, PagesArgs>): Prisma__PagesClient<PagesGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * News base type for findUnique actions
   */
  export type NewsFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the News
     * 
    **/
    select?: NewsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: NewsInclude | null
    /**
     * Filter, which News to fetch.
     * 
    **/
    where: NewsWhereUniqueInput
  }

  /**
   * News: findUnique
   */
  export interface NewsFindUniqueArgs extends NewsFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * News findUniqueOrThrow
   */
  export type NewsFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the News
     * 
    **/
    select?: NewsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: NewsInclude | null
    /**
     * Filter, which News to fetch.
     * 
    **/
    where: NewsWhereUniqueInput
  }


  /**
   * News base type for findFirst actions
   */
  export type NewsFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the News
     * 
    **/
    select?: NewsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: NewsInclude | null
    /**
     * Filter, which News to fetch.
     * 
    **/
    where?: NewsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of News to fetch.
     * 
    **/
    orderBy?: Enumerable<NewsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for News.
     * 
    **/
    cursor?: NewsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` News from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` News.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of News.
     * 
    **/
    distinct?: Enumerable<NewsScalarFieldEnum>
  }

  /**
   * News: findFirst
   */
  export interface NewsFindFirstArgs extends NewsFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * News findFirstOrThrow
   */
  export type NewsFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the News
     * 
    **/
    select?: NewsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: NewsInclude | null
    /**
     * Filter, which News to fetch.
     * 
    **/
    where?: NewsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of News to fetch.
     * 
    **/
    orderBy?: Enumerable<NewsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for News.
     * 
    **/
    cursor?: NewsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` News from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` News.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of News.
     * 
    **/
    distinct?: Enumerable<NewsScalarFieldEnum>
  }


  /**
   * News findMany
   */
  export type NewsFindManyArgs = {
    /**
     * Select specific fields to fetch from the News
     * 
    **/
    select?: NewsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: NewsInclude | null
    /**
     * Filter, which News to fetch.
     * 
    **/
    where?: NewsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of News to fetch.
     * 
    **/
    orderBy?: Enumerable<NewsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing News.
     * 
    **/
    cursor?: NewsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` News from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` News.
     * 
    **/
    skip?: number
    distinct?: Enumerable<NewsScalarFieldEnum>
  }


  /**
   * News create
   */
  export type NewsCreateArgs = {
    /**
     * Select specific fields to fetch from the News
     * 
    **/
    select?: NewsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: NewsInclude | null
    /**
     * The data needed to create a News.
     * 
    **/
    data: XOR<NewsCreateInput, NewsUncheckedCreateInput>
  }


  /**
   * News createMany
   */
  export type NewsCreateManyArgs = {
    /**
     * The data used to create many News.
     * 
    **/
    data: Enumerable<NewsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * News update
   */
  export type NewsUpdateArgs = {
    /**
     * Select specific fields to fetch from the News
     * 
    **/
    select?: NewsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: NewsInclude | null
    /**
     * The data needed to update a News.
     * 
    **/
    data: XOR<NewsUpdateInput, NewsUncheckedUpdateInput>
    /**
     * Choose, which News to update.
     * 
    **/
    where: NewsWhereUniqueInput
  }


  /**
   * News updateMany
   */
  export type NewsUpdateManyArgs = {
    /**
     * The data used to update News.
     * 
    **/
    data: XOR<NewsUpdateManyMutationInput, NewsUncheckedUpdateManyInput>
    /**
     * Filter which News to update
     * 
    **/
    where?: NewsWhereInput
  }


  /**
   * News upsert
   */
  export type NewsUpsertArgs = {
    /**
     * Select specific fields to fetch from the News
     * 
    **/
    select?: NewsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: NewsInclude | null
    /**
     * The filter to search for the News to update in case it exists.
     * 
    **/
    where: NewsWhereUniqueInput
    /**
     * In case the News found by the `where` argument doesn't exist, create a new News with this data.
     * 
    **/
    create: XOR<NewsCreateInput, NewsUncheckedCreateInput>
    /**
     * In case the News was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<NewsUpdateInput, NewsUncheckedUpdateInput>
  }


  /**
   * News delete
   */
  export type NewsDeleteArgs = {
    /**
     * Select specific fields to fetch from the News
     * 
    **/
    select?: NewsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: NewsInclude | null
    /**
     * Filter which News to delete.
     * 
    **/
    where: NewsWhereUniqueInput
  }


  /**
   * News deleteMany
   */
  export type NewsDeleteManyArgs = {
    /**
     * Filter which News to delete
     * 
    **/
    where?: NewsWhereInput
  }


  /**
   * News without action
   */
  export type NewsArgs = {
    /**
     * Select specific fields to fetch from the News
     * 
    **/
    select?: NewsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: NewsInclude | null
  }



  /**
   * Model Notification
   */


  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationMinAggregateOutputType = {
    notifiation_id: string | null
    user_id: string | null
    link: string | null
    message: string | null
    is_new: boolean | null
    is_badge: boolean | null
    created_at: Date | null
    created_by: string | null
  }

  export type NotificationMaxAggregateOutputType = {
    notifiation_id: string | null
    user_id: string | null
    link: string | null
    message: string | null
    is_new: boolean | null
    is_badge: boolean | null
    created_at: Date | null
    created_by: string | null
  }

  export type NotificationCountAggregateOutputType = {
    notifiation_id: number
    user_id: number
    link: number
    message: number
    is_new: number
    is_badge: number
    created_at: number
    created_by: number
    _all: number
  }


  export type NotificationMinAggregateInputType = {
    notifiation_id?: true
    user_id?: true
    link?: true
    message?: true
    is_new?: true
    is_badge?: true
    created_at?: true
    created_by?: true
  }

  export type NotificationMaxAggregateInputType = {
    notifiation_id?: true
    user_id?: true
    link?: true
    message?: true
    is_new?: true
    is_badge?: true
    created_at?: true
    created_by?: true
  }

  export type NotificationCountAggregateInputType = {
    notifiation_id?: true
    user_id?: true
    link?: true
    message?: true
    is_new?: true
    is_badge?: true
    created_at?: true
    created_by?: true
    _all?: true
  }

  export type NotificationAggregateArgs = {
    /**
     * Filter which Notification to aggregate.
     * 
    **/
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     * 
    **/
    orderBy?: Enumerable<NotificationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type NotificationGroupByArgs = {
    where?: NotificationWhereInput
    orderBy?: Enumerable<NotificationOrderByWithAggregationInput>
    by: Array<NotificationScalarFieldEnum>
    having?: NotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }


  export type NotificationGroupByOutputType = {
    notifiation_id: string
    user_id: string
    link: string
    message: string
    is_new: boolean
    is_badge: boolean
    created_at: Date
    created_by: string
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = PrismaPromise<
    Array<
      PickArray<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSelect = {
    notifiation_id?: boolean
    user_id?: boolean
    User?: boolean | UserArgs
    link?: boolean
    message?: boolean
    is_new?: boolean
    is_badge?: boolean
    created_at?: boolean
    created_by?: boolean
  }


  export type NotificationInclude = {
    User?: boolean | UserArgs
  } 

  export type NotificationGetPayload<S extends boolean | null | undefined | NotificationArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Notification :
    S extends undefined ? never :
    S extends { include: any } & (NotificationArgs | NotificationFindManyArgs)
    ? Notification  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'User' ? UserGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (NotificationArgs | NotificationFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'User' ? UserGetPayload<S['select'][P]> :  P extends keyof Notification ? Notification[P] : never
  } 
      : Notification


  type NotificationCountArgs = Merge<
    Omit<NotificationFindManyArgs, 'select' | 'include'> & {
      select?: NotificationCountAggregateInputType | true
    }
  >

  export interface NotificationDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends NotificationFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, NotificationFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Notification'> extends True ? Prisma__NotificationClient<NotificationGetPayload<T>> : Prisma__NotificationClient<NotificationGetPayload<T> | null, null>

    /**
     * Find one Notification that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, NotificationFindUniqueOrThrowArgs>
    ): Prisma__NotificationClient<NotificationGetPayload<T>>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends NotificationFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, NotificationFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Notification'> extends True ? Prisma__NotificationClient<NotificationGetPayload<T>> : Prisma__NotificationClient<NotificationGetPayload<T> | null, null>

    /**
     * Find the first Notification that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs>(
      args?: SelectSubset<T, NotificationFindFirstOrThrowArgs>
    ): Prisma__NotificationClient<NotificationGetPayload<T>>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `notifiation_id`
     * const notificationWithNotifiation_idOnly = await prisma.notification.findMany({ select: { notifiation_id: true } })
     * 
    **/
    findMany<T extends NotificationFindManyArgs>(
      args?: SelectSubset<T, NotificationFindManyArgs>
    ): PrismaPromise<Array<NotificationGetPayload<T>>>

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
    **/
    create<T extends NotificationCreateArgs>(
      args: SelectSubset<T, NotificationCreateArgs>
    ): Prisma__NotificationClient<NotificationGetPayload<T>>

    /**
     * Create many Notifications.
     *     @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     *     @example
     *     // Create many Notifications
     *     const notification = await prisma.notification.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends NotificationCreateManyArgs>(
      args?: SelectSubset<T, NotificationCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
    **/
    delete<T extends NotificationDeleteArgs>(
      args: SelectSubset<T, NotificationDeleteArgs>
    ): Prisma__NotificationClient<NotificationGetPayload<T>>

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends NotificationUpdateArgs>(
      args: SelectSubset<T, NotificationUpdateArgs>
    ): Prisma__NotificationClient<NotificationGetPayload<T>>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends NotificationDeleteManyArgs>(
      args?: SelectSubset<T, NotificationDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends NotificationUpdateManyArgs>(
      args: SelectSubset<T, NotificationUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
    **/
    upsert<T extends NotificationUpsertArgs>(
      args: SelectSubset<T, NotificationUpsertArgs>
    ): Prisma__NotificationClient<NotificationGetPayload<T>>

    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__NotificationClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    User<T extends UserArgs= {}>(args?: Subset<T, UserArgs>): Prisma__UserClient<UserGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Notification base type for findUnique actions
   */
  export type NotificationFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Notification
     * 
    **/
    select?: NotificationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: NotificationInclude | null
    /**
     * Filter, which Notification to fetch.
     * 
    **/
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification: findUnique
   */
  export interface NotificationFindUniqueArgs extends NotificationFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Notification findUniqueOrThrow
   */
  export type NotificationFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Notification
     * 
    **/
    select?: NotificationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: NotificationInclude | null
    /**
     * Filter, which Notification to fetch.
     * 
    **/
    where: NotificationWhereUniqueInput
  }


  /**
   * Notification base type for findFirst actions
   */
  export type NotificationFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Notification
     * 
    **/
    select?: NotificationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: NotificationInclude | null
    /**
     * Filter, which Notification to fetch.
     * 
    **/
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     * 
    **/
    orderBy?: Enumerable<NotificationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     * 
    **/
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     * 
    **/
    distinct?: Enumerable<NotificationScalarFieldEnum>
  }

  /**
   * Notification: findFirst
   */
  export interface NotificationFindFirstArgs extends NotificationFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Notification findFirstOrThrow
   */
  export type NotificationFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Notification
     * 
    **/
    select?: NotificationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: NotificationInclude | null
    /**
     * Filter, which Notification to fetch.
     * 
    **/
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     * 
    **/
    orderBy?: Enumerable<NotificationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     * 
    **/
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     * 
    **/
    distinct?: Enumerable<NotificationScalarFieldEnum>
  }


  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs = {
    /**
     * Select specific fields to fetch from the Notification
     * 
    **/
    select?: NotificationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: NotificationInclude | null
    /**
     * Filter, which Notifications to fetch.
     * 
    **/
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     * 
    **/
    orderBy?: Enumerable<NotificationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     * 
    **/
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     * 
    **/
    skip?: number
    distinct?: Enumerable<NotificationScalarFieldEnum>
  }


  /**
   * Notification create
   */
  export type NotificationCreateArgs = {
    /**
     * Select specific fields to fetch from the Notification
     * 
    **/
    select?: NotificationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: NotificationInclude | null
    /**
     * The data needed to create a Notification.
     * 
    **/
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
  }


  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs = {
    /**
     * The data used to create many Notifications.
     * 
    **/
    data: Enumerable<NotificationCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Notification update
   */
  export type NotificationUpdateArgs = {
    /**
     * Select specific fields to fetch from the Notification
     * 
    **/
    select?: NotificationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: NotificationInclude | null
    /**
     * The data needed to update a Notification.
     * 
    **/
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
    /**
     * Choose, which Notification to update.
     * 
    **/
    where: NotificationWhereUniqueInput
  }


  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs = {
    /**
     * The data used to update Notifications.
     * 
    **/
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     * 
    **/
    where?: NotificationWhereInput
  }


  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs = {
    /**
     * Select specific fields to fetch from the Notification
     * 
    **/
    select?: NotificationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: NotificationInclude | null
    /**
     * The filter to search for the Notification to update in case it exists.
     * 
    **/
    where: NotificationWhereUniqueInput
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     * 
    **/
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
  }


  /**
   * Notification delete
   */
  export type NotificationDeleteArgs = {
    /**
     * Select specific fields to fetch from the Notification
     * 
    **/
    select?: NotificationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: NotificationInclude | null
    /**
     * Filter which Notification to delete.
     * 
    **/
    where: NotificationWhereUniqueInput
  }


  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs = {
    /**
     * Filter which Notifications to delete
     * 
    **/
    where?: NotificationWhereInput
  }


  /**
   * Notification without action
   */
  export type NotificationArgs = {
    /**
     * Select specific fields to fetch from the Notification
     * 
    **/
    select?: NotificationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: NotificationInclude | null
  }



  /**
   * Model Pages
   */


  export type AggregatePages = {
    _count: PagesCountAggregateOutputType | null
    _avg: PagesAvgAggregateOutputType | null
    _sum: PagesSumAggregateOutputType | null
    _min: PagesMinAggregateOutputType | null
    _max: PagesMaxAggregateOutputType | null
  }

  export type PagesAvgAggregateOutputType = {
    page_id: number | null
    page_type: number | null
  }

  export type PagesSumAggregateOutputType = {
    page_id: number | null
    page_type: number | null
  }

  export type PagesMinAggregateOutputType = {
    page_id: number | null
    page_name: string | null
    page_type: number | null
    created_at: Date | null
    created_by: string | null
  }

  export type PagesMaxAggregateOutputType = {
    page_id: number | null
    page_name: string | null
    page_type: number | null
    created_at: Date | null
    created_by: string | null
  }

  export type PagesCountAggregateOutputType = {
    page_id: number
    page_name: number
    page_type: number
    created_at: number
    created_by: number
    _all: number
  }


  export type PagesAvgAggregateInputType = {
    page_id?: true
    page_type?: true
  }

  export type PagesSumAggregateInputType = {
    page_id?: true
    page_type?: true
  }

  export type PagesMinAggregateInputType = {
    page_id?: true
    page_name?: true
    page_type?: true
    created_at?: true
    created_by?: true
  }

  export type PagesMaxAggregateInputType = {
    page_id?: true
    page_name?: true
    page_type?: true
    created_at?: true
    created_by?: true
  }

  export type PagesCountAggregateInputType = {
    page_id?: true
    page_name?: true
    page_type?: true
    created_at?: true
    created_by?: true
    _all?: true
  }

  export type PagesAggregateArgs = {
    /**
     * Filter which Pages to aggregate.
     * 
    **/
    where?: PagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pages to fetch.
     * 
    **/
    orderBy?: Enumerable<PagesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: PagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pages from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pages.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Pages
    **/
    _count?: true | PagesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PagesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PagesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PagesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PagesMaxAggregateInputType
  }

  export type GetPagesAggregateType<T extends PagesAggregateArgs> = {
        [P in keyof T & keyof AggregatePages]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePages[P]>
      : GetScalarType<T[P], AggregatePages[P]>
  }




  export type PagesGroupByArgs = {
    where?: PagesWhereInput
    orderBy?: Enumerable<PagesOrderByWithAggregationInput>
    by: Array<PagesScalarFieldEnum>
    having?: PagesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PagesCountAggregateInputType | true
    _avg?: PagesAvgAggregateInputType
    _sum?: PagesSumAggregateInputType
    _min?: PagesMinAggregateInputType
    _max?: PagesMaxAggregateInputType
  }


  export type PagesGroupByOutputType = {
    page_id: number
    page_name: string
    page_type: number
    created_at: Date
    created_by: string
    _count: PagesCountAggregateOutputType | null
    _avg: PagesAvgAggregateOutputType | null
    _sum: PagesSumAggregateOutputType | null
    _min: PagesMinAggregateOutputType | null
    _max: PagesMaxAggregateOutputType | null
  }

  type GetPagesGroupByPayload<T extends PagesGroupByArgs> = PrismaPromise<
    Array<
      PickArray<PagesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PagesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PagesGroupByOutputType[P]>
            : GetScalarType<T[P], PagesGroupByOutputType[P]>
        }
      >
    >


  export type PagesSelect = {
    page_id?: boolean
    page_name?: boolean
    page_type?: boolean
    created_at?: boolean
    created_by?: boolean
    news?: boolean | NewsFindManyArgs
    _count?: boolean | PagesCountOutputTypeArgs
  }


  export type PagesInclude = {
    news?: boolean | NewsFindManyArgs
    _count?: boolean | PagesCountOutputTypeArgs
  } 

  export type PagesGetPayload<S extends boolean | null | undefined | PagesArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Pages :
    S extends undefined ? never :
    S extends { include: any } & (PagesArgs | PagesFindManyArgs)
    ? Pages  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'news' ? Array < NewsGetPayload<S['include'][P]>>  :
        P extends '_count' ? PagesCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (PagesArgs | PagesFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'news' ? Array < NewsGetPayload<S['select'][P]>>  :
        P extends '_count' ? PagesCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Pages ? Pages[P] : never
  } 
      : Pages


  type PagesCountArgs = Merge<
    Omit<PagesFindManyArgs, 'select' | 'include'> & {
      select?: PagesCountAggregateInputType | true
    }
  >

  export interface PagesDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Pages that matches the filter.
     * @param {PagesFindUniqueArgs} args - Arguments to find a Pages
     * @example
     * // Get one Pages
     * const pages = await prisma.pages.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PagesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, PagesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Pages'> extends True ? Prisma__PagesClient<PagesGetPayload<T>> : Prisma__PagesClient<PagesGetPayload<T> | null, null>

    /**
     * Find one Pages that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {PagesFindUniqueOrThrowArgs} args - Arguments to find a Pages
     * @example
     * // Get one Pages
     * const pages = await prisma.pages.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends PagesFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, PagesFindUniqueOrThrowArgs>
    ): Prisma__PagesClient<PagesGetPayload<T>>

    /**
     * Find the first Pages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PagesFindFirstArgs} args - Arguments to find a Pages
     * @example
     * // Get one Pages
     * const pages = await prisma.pages.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PagesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, PagesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Pages'> extends True ? Prisma__PagesClient<PagesGetPayload<T>> : Prisma__PagesClient<PagesGetPayload<T> | null, null>

    /**
     * Find the first Pages that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PagesFindFirstOrThrowArgs} args - Arguments to find a Pages
     * @example
     * // Get one Pages
     * const pages = await prisma.pages.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends PagesFindFirstOrThrowArgs>(
      args?: SelectSubset<T, PagesFindFirstOrThrowArgs>
    ): Prisma__PagesClient<PagesGetPayload<T>>

    /**
     * Find zero or more Pages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PagesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Pages
     * const pages = await prisma.pages.findMany()
     * 
     * // Get first 10 Pages
     * const pages = await prisma.pages.findMany({ take: 10 })
     * 
     * // Only select the `page_id`
     * const pagesWithPage_idOnly = await prisma.pages.findMany({ select: { page_id: true } })
     * 
    **/
    findMany<T extends PagesFindManyArgs>(
      args?: SelectSubset<T, PagesFindManyArgs>
    ): PrismaPromise<Array<PagesGetPayload<T>>>

    /**
     * Create a Pages.
     * @param {PagesCreateArgs} args - Arguments to create a Pages.
     * @example
     * // Create one Pages
     * const Pages = await prisma.pages.create({
     *   data: {
     *     // ... data to create a Pages
     *   }
     * })
     * 
    **/
    create<T extends PagesCreateArgs>(
      args: SelectSubset<T, PagesCreateArgs>
    ): Prisma__PagesClient<PagesGetPayload<T>>

    /**
     * Create many Pages.
     *     @param {PagesCreateManyArgs} args - Arguments to create many Pages.
     *     @example
     *     // Create many Pages
     *     const pages = await prisma.pages.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PagesCreateManyArgs>(
      args?: SelectSubset<T, PagesCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Pages.
     * @param {PagesDeleteArgs} args - Arguments to delete one Pages.
     * @example
     * // Delete one Pages
     * const Pages = await prisma.pages.delete({
     *   where: {
     *     // ... filter to delete one Pages
     *   }
     * })
     * 
    **/
    delete<T extends PagesDeleteArgs>(
      args: SelectSubset<T, PagesDeleteArgs>
    ): Prisma__PagesClient<PagesGetPayload<T>>

    /**
     * Update one Pages.
     * @param {PagesUpdateArgs} args - Arguments to update one Pages.
     * @example
     * // Update one Pages
     * const pages = await prisma.pages.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PagesUpdateArgs>(
      args: SelectSubset<T, PagesUpdateArgs>
    ): Prisma__PagesClient<PagesGetPayload<T>>

    /**
     * Delete zero or more Pages.
     * @param {PagesDeleteManyArgs} args - Arguments to filter Pages to delete.
     * @example
     * // Delete a few Pages
     * const { count } = await prisma.pages.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PagesDeleteManyArgs>(
      args?: SelectSubset<T, PagesDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PagesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Pages
     * const pages = await prisma.pages.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PagesUpdateManyArgs>(
      args: SelectSubset<T, PagesUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Pages.
     * @param {PagesUpsertArgs} args - Arguments to update or create a Pages.
     * @example
     * // Update or create a Pages
     * const pages = await prisma.pages.upsert({
     *   create: {
     *     // ... data to create a Pages
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Pages we want to update
     *   }
     * })
    **/
    upsert<T extends PagesUpsertArgs>(
      args: SelectSubset<T, PagesUpsertArgs>
    ): Prisma__PagesClient<PagesGetPayload<T>>

    /**
     * Count the number of Pages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PagesCountArgs} args - Arguments to filter Pages to count.
     * @example
     * // Count the number of Pages
     * const count = await prisma.pages.count({
     *   where: {
     *     // ... the filter for the Pages we want to count
     *   }
     * })
    **/
    count<T extends PagesCountArgs>(
      args?: Subset<T, PagesCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PagesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Pages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PagesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PagesAggregateArgs>(args: Subset<T, PagesAggregateArgs>): PrismaPromise<GetPagesAggregateType<T>>

    /**
     * Group by Pages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PagesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PagesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PagesGroupByArgs['orderBy'] }
        : { orderBy?: PagesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PagesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPagesGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Pages.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__PagesClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    news<T extends NewsFindManyArgs= {}>(args?: Subset<T, NewsFindManyArgs>): PrismaPromise<Array<NewsGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Pages base type for findUnique actions
   */
  export type PagesFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Pages
     * 
    **/
    select?: PagesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PagesInclude | null
    /**
     * Filter, which Pages to fetch.
     * 
    **/
    where: PagesWhereUniqueInput
  }

  /**
   * Pages: findUnique
   */
  export interface PagesFindUniqueArgs extends PagesFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Pages findUniqueOrThrow
   */
  export type PagesFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Pages
     * 
    **/
    select?: PagesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PagesInclude | null
    /**
     * Filter, which Pages to fetch.
     * 
    **/
    where: PagesWhereUniqueInput
  }


  /**
   * Pages base type for findFirst actions
   */
  export type PagesFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Pages
     * 
    **/
    select?: PagesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PagesInclude | null
    /**
     * Filter, which Pages to fetch.
     * 
    **/
    where?: PagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pages to fetch.
     * 
    **/
    orderBy?: Enumerable<PagesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Pages.
     * 
    **/
    cursor?: PagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pages from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pages.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Pages.
     * 
    **/
    distinct?: Enumerable<PagesScalarFieldEnum>
  }

  /**
   * Pages: findFirst
   */
  export interface PagesFindFirstArgs extends PagesFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Pages findFirstOrThrow
   */
  export type PagesFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Pages
     * 
    **/
    select?: PagesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PagesInclude | null
    /**
     * Filter, which Pages to fetch.
     * 
    **/
    where?: PagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pages to fetch.
     * 
    **/
    orderBy?: Enumerable<PagesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Pages.
     * 
    **/
    cursor?: PagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pages from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pages.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Pages.
     * 
    **/
    distinct?: Enumerable<PagesScalarFieldEnum>
  }


  /**
   * Pages findMany
   */
  export type PagesFindManyArgs = {
    /**
     * Select specific fields to fetch from the Pages
     * 
    **/
    select?: PagesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PagesInclude | null
    /**
     * Filter, which Pages to fetch.
     * 
    **/
    where?: PagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pages to fetch.
     * 
    **/
    orderBy?: Enumerable<PagesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Pages.
     * 
    **/
    cursor?: PagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pages from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pages.
     * 
    **/
    skip?: number
    distinct?: Enumerable<PagesScalarFieldEnum>
  }


  /**
   * Pages create
   */
  export type PagesCreateArgs = {
    /**
     * Select specific fields to fetch from the Pages
     * 
    **/
    select?: PagesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PagesInclude | null
    /**
     * The data needed to create a Pages.
     * 
    **/
    data: XOR<PagesCreateInput, PagesUncheckedCreateInput>
  }


  /**
   * Pages createMany
   */
  export type PagesCreateManyArgs = {
    /**
     * The data used to create many Pages.
     * 
    **/
    data: Enumerable<PagesCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Pages update
   */
  export type PagesUpdateArgs = {
    /**
     * Select specific fields to fetch from the Pages
     * 
    **/
    select?: PagesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PagesInclude | null
    /**
     * The data needed to update a Pages.
     * 
    **/
    data: XOR<PagesUpdateInput, PagesUncheckedUpdateInput>
    /**
     * Choose, which Pages to update.
     * 
    **/
    where: PagesWhereUniqueInput
  }


  /**
   * Pages updateMany
   */
  export type PagesUpdateManyArgs = {
    /**
     * The data used to update Pages.
     * 
    **/
    data: XOR<PagesUpdateManyMutationInput, PagesUncheckedUpdateManyInput>
    /**
     * Filter which Pages to update
     * 
    **/
    where?: PagesWhereInput
  }


  /**
   * Pages upsert
   */
  export type PagesUpsertArgs = {
    /**
     * Select specific fields to fetch from the Pages
     * 
    **/
    select?: PagesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PagesInclude | null
    /**
     * The filter to search for the Pages to update in case it exists.
     * 
    **/
    where: PagesWhereUniqueInput
    /**
     * In case the Pages found by the `where` argument doesn't exist, create a new Pages with this data.
     * 
    **/
    create: XOR<PagesCreateInput, PagesUncheckedCreateInput>
    /**
     * In case the Pages was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<PagesUpdateInput, PagesUncheckedUpdateInput>
  }


  /**
   * Pages delete
   */
  export type PagesDeleteArgs = {
    /**
     * Select specific fields to fetch from the Pages
     * 
    **/
    select?: PagesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PagesInclude | null
    /**
     * Filter which Pages to delete.
     * 
    **/
    where: PagesWhereUniqueInput
  }


  /**
   * Pages deleteMany
   */
  export type PagesDeleteManyArgs = {
    /**
     * Filter which Pages to delete
     * 
    **/
    where?: PagesWhereInput
  }


  /**
   * Pages without action
   */
  export type PagesArgs = {
    /**
     * Select specific fields to fetch from the Pages
     * 
    **/
    select?: PagesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PagesInclude | null
  }



  /**
   * Model ReferenceList
   */


  export type AggregateReferenceList = {
    _count: ReferenceListCountAggregateOutputType | null
    _avg: ReferenceListAvgAggregateOutputType | null
    _sum: ReferenceListSumAggregateOutputType | null
    _min: ReferenceListMinAggregateOutputType | null
    _max: ReferenceListMaxAggregateOutputType | null
  }

  export type ReferenceListAvgAggregateOutputType = {
    list_id: number | null
  }

  export type ReferenceListSumAggregateOutputType = {
    list_id: number | null
  }

  export type ReferenceListMinAggregateOutputType = {
    list_id: number | null
    list_name: string | null
    created_at: Date | null
  }

  export type ReferenceListMaxAggregateOutputType = {
    list_id: number | null
    list_name: string | null
    created_at: Date | null
  }

  export type ReferenceListCountAggregateOutputType = {
    list_id: number
    list_name: number
    created_at: number
    _all: number
  }


  export type ReferenceListAvgAggregateInputType = {
    list_id?: true
  }

  export type ReferenceListSumAggregateInputType = {
    list_id?: true
  }

  export type ReferenceListMinAggregateInputType = {
    list_id?: true
    list_name?: true
    created_at?: true
  }

  export type ReferenceListMaxAggregateInputType = {
    list_id?: true
    list_name?: true
    created_at?: true
  }

  export type ReferenceListCountAggregateInputType = {
    list_id?: true
    list_name?: true
    created_at?: true
    _all?: true
  }

  export type ReferenceListAggregateArgs = {
    /**
     * Filter which ReferenceList to aggregate.
     * 
    **/
    where?: ReferenceListWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReferenceLists to fetch.
     * 
    **/
    orderBy?: Enumerable<ReferenceListOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: ReferenceListWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReferenceLists from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReferenceLists.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ReferenceLists
    **/
    _count?: true | ReferenceListCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReferenceListAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReferenceListSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReferenceListMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReferenceListMaxAggregateInputType
  }

  export type GetReferenceListAggregateType<T extends ReferenceListAggregateArgs> = {
        [P in keyof T & keyof AggregateReferenceList]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReferenceList[P]>
      : GetScalarType<T[P], AggregateReferenceList[P]>
  }




  export type ReferenceListGroupByArgs = {
    where?: ReferenceListWhereInput
    orderBy?: Enumerable<ReferenceListOrderByWithAggregationInput>
    by: Array<ReferenceListScalarFieldEnum>
    having?: ReferenceListScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReferenceListCountAggregateInputType | true
    _avg?: ReferenceListAvgAggregateInputType
    _sum?: ReferenceListSumAggregateInputType
    _min?: ReferenceListMinAggregateInputType
    _max?: ReferenceListMaxAggregateInputType
  }


  export type ReferenceListGroupByOutputType = {
    list_id: number
    list_name: string
    created_at: Date
    _count: ReferenceListCountAggregateOutputType | null
    _avg: ReferenceListAvgAggregateOutputType | null
    _sum: ReferenceListSumAggregateOutputType | null
    _min: ReferenceListMinAggregateOutputType | null
    _max: ReferenceListMaxAggregateOutputType | null
  }

  type GetReferenceListGroupByPayload<T extends ReferenceListGroupByArgs> = PrismaPromise<
    Array<
      PickArray<ReferenceListGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReferenceListGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReferenceListGroupByOutputType[P]>
            : GetScalarType<T[P], ReferenceListGroupByOutputType[P]>
        }
      >
    >


  export type ReferenceListSelect = {
    list_id?: boolean
    list_name?: boolean
    created_at?: boolean
    listitems?: boolean | ReferenceListItemsFindManyArgs
    JobReferenceList?: boolean | JobReferenceListFindManyArgs
    _count?: boolean | ReferenceListCountOutputTypeArgs
  }


  export type ReferenceListInclude = {
    listitems?: boolean | ReferenceListItemsFindManyArgs
    JobReferenceList?: boolean | JobReferenceListFindManyArgs
    _count?: boolean | ReferenceListCountOutputTypeArgs
  } 

  export type ReferenceListGetPayload<S extends boolean | null | undefined | ReferenceListArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? ReferenceList :
    S extends undefined ? never :
    S extends { include: any } & (ReferenceListArgs | ReferenceListFindManyArgs)
    ? ReferenceList  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'listitems' ? Array < ReferenceListItemsGetPayload<S['include'][P]>>  :
        P extends 'JobReferenceList' ? Array < JobReferenceListGetPayload<S['include'][P]>>  :
        P extends '_count' ? ReferenceListCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (ReferenceListArgs | ReferenceListFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'listitems' ? Array < ReferenceListItemsGetPayload<S['select'][P]>>  :
        P extends 'JobReferenceList' ? Array < JobReferenceListGetPayload<S['select'][P]>>  :
        P extends '_count' ? ReferenceListCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof ReferenceList ? ReferenceList[P] : never
  } 
      : ReferenceList


  type ReferenceListCountArgs = Merge<
    Omit<ReferenceListFindManyArgs, 'select' | 'include'> & {
      select?: ReferenceListCountAggregateInputType | true
    }
  >

  export interface ReferenceListDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one ReferenceList that matches the filter.
     * @param {ReferenceListFindUniqueArgs} args - Arguments to find a ReferenceList
     * @example
     * // Get one ReferenceList
     * const referenceList = await prisma.referenceList.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ReferenceListFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ReferenceListFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ReferenceList'> extends True ? Prisma__ReferenceListClient<ReferenceListGetPayload<T>> : Prisma__ReferenceListClient<ReferenceListGetPayload<T> | null, null>

    /**
     * Find one ReferenceList that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ReferenceListFindUniqueOrThrowArgs} args - Arguments to find a ReferenceList
     * @example
     * // Get one ReferenceList
     * const referenceList = await prisma.referenceList.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ReferenceListFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, ReferenceListFindUniqueOrThrowArgs>
    ): Prisma__ReferenceListClient<ReferenceListGetPayload<T>>

    /**
     * Find the first ReferenceList that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferenceListFindFirstArgs} args - Arguments to find a ReferenceList
     * @example
     * // Get one ReferenceList
     * const referenceList = await prisma.referenceList.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ReferenceListFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ReferenceListFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ReferenceList'> extends True ? Prisma__ReferenceListClient<ReferenceListGetPayload<T>> : Prisma__ReferenceListClient<ReferenceListGetPayload<T> | null, null>

    /**
     * Find the first ReferenceList that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferenceListFindFirstOrThrowArgs} args - Arguments to find a ReferenceList
     * @example
     * // Get one ReferenceList
     * const referenceList = await prisma.referenceList.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ReferenceListFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ReferenceListFindFirstOrThrowArgs>
    ): Prisma__ReferenceListClient<ReferenceListGetPayload<T>>

    /**
     * Find zero or more ReferenceLists that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferenceListFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ReferenceLists
     * const referenceLists = await prisma.referenceList.findMany()
     * 
     * // Get first 10 ReferenceLists
     * const referenceLists = await prisma.referenceList.findMany({ take: 10 })
     * 
     * // Only select the `list_id`
     * const referenceListWithList_idOnly = await prisma.referenceList.findMany({ select: { list_id: true } })
     * 
    **/
    findMany<T extends ReferenceListFindManyArgs>(
      args?: SelectSubset<T, ReferenceListFindManyArgs>
    ): PrismaPromise<Array<ReferenceListGetPayload<T>>>

    /**
     * Create a ReferenceList.
     * @param {ReferenceListCreateArgs} args - Arguments to create a ReferenceList.
     * @example
     * // Create one ReferenceList
     * const ReferenceList = await prisma.referenceList.create({
     *   data: {
     *     // ... data to create a ReferenceList
     *   }
     * })
     * 
    **/
    create<T extends ReferenceListCreateArgs>(
      args: SelectSubset<T, ReferenceListCreateArgs>
    ): Prisma__ReferenceListClient<ReferenceListGetPayload<T>>

    /**
     * Create many ReferenceLists.
     *     @param {ReferenceListCreateManyArgs} args - Arguments to create many ReferenceLists.
     *     @example
     *     // Create many ReferenceLists
     *     const referenceList = await prisma.referenceList.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ReferenceListCreateManyArgs>(
      args?: SelectSubset<T, ReferenceListCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a ReferenceList.
     * @param {ReferenceListDeleteArgs} args - Arguments to delete one ReferenceList.
     * @example
     * // Delete one ReferenceList
     * const ReferenceList = await prisma.referenceList.delete({
     *   where: {
     *     // ... filter to delete one ReferenceList
     *   }
     * })
     * 
    **/
    delete<T extends ReferenceListDeleteArgs>(
      args: SelectSubset<T, ReferenceListDeleteArgs>
    ): Prisma__ReferenceListClient<ReferenceListGetPayload<T>>

    /**
     * Update one ReferenceList.
     * @param {ReferenceListUpdateArgs} args - Arguments to update one ReferenceList.
     * @example
     * // Update one ReferenceList
     * const referenceList = await prisma.referenceList.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ReferenceListUpdateArgs>(
      args: SelectSubset<T, ReferenceListUpdateArgs>
    ): Prisma__ReferenceListClient<ReferenceListGetPayload<T>>

    /**
     * Delete zero or more ReferenceLists.
     * @param {ReferenceListDeleteManyArgs} args - Arguments to filter ReferenceLists to delete.
     * @example
     * // Delete a few ReferenceLists
     * const { count } = await prisma.referenceList.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ReferenceListDeleteManyArgs>(
      args?: SelectSubset<T, ReferenceListDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more ReferenceLists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferenceListUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ReferenceLists
     * const referenceList = await prisma.referenceList.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ReferenceListUpdateManyArgs>(
      args: SelectSubset<T, ReferenceListUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one ReferenceList.
     * @param {ReferenceListUpsertArgs} args - Arguments to update or create a ReferenceList.
     * @example
     * // Update or create a ReferenceList
     * const referenceList = await prisma.referenceList.upsert({
     *   create: {
     *     // ... data to create a ReferenceList
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ReferenceList we want to update
     *   }
     * })
    **/
    upsert<T extends ReferenceListUpsertArgs>(
      args: SelectSubset<T, ReferenceListUpsertArgs>
    ): Prisma__ReferenceListClient<ReferenceListGetPayload<T>>

    /**
     * Count the number of ReferenceLists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferenceListCountArgs} args - Arguments to filter ReferenceLists to count.
     * @example
     * // Count the number of ReferenceLists
     * const count = await prisma.referenceList.count({
     *   where: {
     *     // ... the filter for the ReferenceLists we want to count
     *   }
     * })
    **/
    count<T extends ReferenceListCountArgs>(
      args?: Subset<T, ReferenceListCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReferenceListCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ReferenceList.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferenceListAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReferenceListAggregateArgs>(args: Subset<T, ReferenceListAggregateArgs>): PrismaPromise<GetReferenceListAggregateType<T>>

    /**
     * Group by ReferenceList.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferenceListGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReferenceListGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReferenceListGroupByArgs['orderBy'] }
        : { orderBy?: ReferenceListGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReferenceListGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReferenceListGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for ReferenceList.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ReferenceListClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    listitems<T extends ReferenceListItemsFindManyArgs= {}>(args?: Subset<T, ReferenceListItemsFindManyArgs>): PrismaPromise<Array<ReferenceListItemsGetPayload<T>>| Null>;

    JobReferenceList<T extends JobReferenceListFindManyArgs= {}>(args?: Subset<T, JobReferenceListFindManyArgs>): PrismaPromise<Array<JobReferenceListGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * ReferenceList base type for findUnique actions
   */
  export type ReferenceListFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the ReferenceList
     * 
    **/
    select?: ReferenceListSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ReferenceListInclude | null
    /**
     * Filter, which ReferenceList to fetch.
     * 
    **/
    where: ReferenceListWhereUniqueInput
  }

  /**
   * ReferenceList: findUnique
   */
  export interface ReferenceListFindUniqueArgs extends ReferenceListFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ReferenceList findUniqueOrThrow
   */
  export type ReferenceListFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the ReferenceList
     * 
    **/
    select?: ReferenceListSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ReferenceListInclude | null
    /**
     * Filter, which ReferenceList to fetch.
     * 
    **/
    where: ReferenceListWhereUniqueInput
  }


  /**
   * ReferenceList base type for findFirst actions
   */
  export type ReferenceListFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the ReferenceList
     * 
    **/
    select?: ReferenceListSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ReferenceListInclude | null
    /**
     * Filter, which ReferenceList to fetch.
     * 
    **/
    where?: ReferenceListWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReferenceLists to fetch.
     * 
    **/
    orderBy?: Enumerable<ReferenceListOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReferenceLists.
     * 
    **/
    cursor?: ReferenceListWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReferenceLists from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReferenceLists.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReferenceLists.
     * 
    **/
    distinct?: Enumerable<ReferenceListScalarFieldEnum>
  }

  /**
   * ReferenceList: findFirst
   */
  export interface ReferenceListFindFirstArgs extends ReferenceListFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ReferenceList findFirstOrThrow
   */
  export type ReferenceListFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the ReferenceList
     * 
    **/
    select?: ReferenceListSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ReferenceListInclude | null
    /**
     * Filter, which ReferenceList to fetch.
     * 
    **/
    where?: ReferenceListWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReferenceLists to fetch.
     * 
    **/
    orderBy?: Enumerable<ReferenceListOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReferenceLists.
     * 
    **/
    cursor?: ReferenceListWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReferenceLists from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReferenceLists.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReferenceLists.
     * 
    **/
    distinct?: Enumerable<ReferenceListScalarFieldEnum>
  }


  /**
   * ReferenceList findMany
   */
  export type ReferenceListFindManyArgs = {
    /**
     * Select specific fields to fetch from the ReferenceList
     * 
    **/
    select?: ReferenceListSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ReferenceListInclude | null
    /**
     * Filter, which ReferenceLists to fetch.
     * 
    **/
    where?: ReferenceListWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReferenceLists to fetch.
     * 
    **/
    orderBy?: Enumerable<ReferenceListOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ReferenceLists.
     * 
    **/
    cursor?: ReferenceListWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReferenceLists from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReferenceLists.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ReferenceListScalarFieldEnum>
  }


  /**
   * ReferenceList create
   */
  export type ReferenceListCreateArgs = {
    /**
     * Select specific fields to fetch from the ReferenceList
     * 
    **/
    select?: ReferenceListSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ReferenceListInclude | null
    /**
     * The data needed to create a ReferenceList.
     * 
    **/
    data: XOR<ReferenceListCreateInput, ReferenceListUncheckedCreateInput>
  }


  /**
   * ReferenceList createMany
   */
  export type ReferenceListCreateManyArgs = {
    /**
     * The data used to create many ReferenceLists.
     * 
    **/
    data: Enumerable<ReferenceListCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * ReferenceList update
   */
  export type ReferenceListUpdateArgs = {
    /**
     * Select specific fields to fetch from the ReferenceList
     * 
    **/
    select?: ReferenceListSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ReferenceListInclude | null
    /**
     * The data needed to update a ReferenceList.
     * 
    **/
    data: XOR<ReferenceListUpdateInput, ReferenceListUncheckedUpdateInput>
    /**
     * Choose, which ReferenceList to update.
     * 
    **/
    where: ReferenceListWhereUniqueInput
  }


  /**
   * ReferenceList updateMany
   */
  export type ReferenceListUpdateManyArgs = {
    /**
     * The data used to update ReferenceLists.
     * 
    **/
    data: XOR<ReferenceListUpdateManyMutationInput, ReferenceListUncheckedUpdateManyInput>
    /**
     * Filter which ReferenceLists to update
     * 
    **/
    where?: ReferenceListWhereInput
  }


  /**
   * ReferenceList upsert
   */
  export type ReferenceListUpsertArgs = {
    /**
     * Select specific fields to fetch from the ReferenceList
     * 
    **/
    select?: ReferenceListSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ReferenceListInclude | null
    /**
     * The filter to search for the ReferenceList to update in case it exists.
     * 
    **/
    where: ReferenceListWhereUniqueInput
    /**
     * In case the ReferenceList found by the `where` argument doesn't exist, create a new ReferenceList with this data.
     * 
    **/
    create: XOR<ReferenceListCreateInput, ReferenceListUncheckedCreateInput>
    /**
     * In case the ReferenceList was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<ReferenceListUpdateInput, ReferenceListUncheckedUpdateInput>
  }


  /**
   * ReferenceList delete
   */
  export type ReferenceListDeleteArgs = {
    /**
     * Select specific fields to fetch from the ReferenceList
     * 
    **/
    select?: ReferenceListSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ReferenceListInclude | null
    /**
     * Filter which ReferenceList to delete.
     * 
    **/
    where: ReferenceListWhereUniqueInput
  }


  /**
   * ReferenceList deleteMany
   */
  export type ReferenceListDeleteManyArgs = {
    /**
     * Filter which ReferenceLists to delete
     * 
    **/
    where?: ReferenceListWhereInput
  }


  /**
   * ReferenceList without action
   */
  export type ReferenceListArgs = {
    /**
     * Select specific fields to fetch from the ReferenceList
     * 
    **/
    select?: ReferenceListSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ReferenceListInclude | null
  }



  /**
   * Model ReferenceListItems
   */


  export type AggregateReferenceListItems = {
    _count: ReferenceListItemsCountAggregateOutputType | null
    _avg: ReferenceListItemsAvgAggregateOutputType | null
    _sum: ReferenceListItemsSumAggregateOutputType | null
    _min: ReferenceListItemsMinAggregateOutputType | null
    _max: ReferenceListItemsMaxAggregateOutputType | null
  }

  export type ReferenceListItemsAvgAggregateOutputType = {
    listitem_id: number | null
    list_id: number | null
    dictionary_id: number | null
    parent_id: number | null
  }

  export type ReferenceListItemsSumAggregateOutputType = {
    listitem_id: number | null
    list_id: number | null
    dictionary_id: number | null
    parent_id: number | null
  }

  export type ReferenceListItemsMinAggregateOutputType = {
    listitem_id: number | null
    list_id: number | null
    dictionary_id: number | null
    code: string | null
    listitem_value: string | null
    parent_id: number | null
    value: string | null
    created_at: Date | null
    updated_at: Date | null
    dictionaryDictionaries_id: string | null
  }

  export type ReferenceListItemsMaxAggregateOutputType = {
    listitem_id: number | null
    list_id: number | null
    dictionary_id: number | null
    code: string | null
    listitem_value: string | null
    parent_id: number | null
    value: string | null
    created_at: Date | null
    updated_at: Date | null
    dictionaryDictionaries_id: string | null
  }

  export type ReferenceListItemsCountAggregateOutputType = {
    listitem_id: number
    list_id: number
    dictionary_id: number
    code: number
    listitem_value: number
    parent_id: number
    value: number
    created_at: number
    updated_at: number
    dictionaryDictionaries_id: number
    _all: number
  }


  export type ReferenceListItemsAvgAggregateInputType = {
    listitem_id?: true
    list_id?: true
    dictionary_id?: true
    parent_id?: true
  }

  export type ReferenceListItemsSumAggregateInputType = {
    listitem_id?: true
    list_id?: true
    dictionary_id?: true
    parent_id?: true
  }

  export type ReferenceListItemsMinAggregateInputType = {
    listitem_id?: true
    list_id?: true
    dictionary_id?: true
    code?: true
    listitem_value?: true
    parent_id?: true
    value?: true
    created_at?: true
    updated_at?: true
    dictionaryDictionaries_id?: true
  }

  export type ReferenceListItemsMaxAggregateInputType = {
    listitem_id?: true
    list_id?: true
    dictionary_id?: true
    code?: true
    listitem_value?: true
    parent_id?: true
    value?: true
    created_at?: true
    updated_at?: true
    dictionaryDictionaries_id?: true
  }

  export type ReferenceListItemsCountAggregateInputType = {
    listitem_id?: true
    list_id?: true
    dictionary_id?: true
    code?: true
    listitem_value?: true
    parent_id?: true
    value?: true
    created_at?: true
    updated_at?: true
    dictionaryDictionaries_id?: true
    _all?: true
  }

  export type ReferenceListItemsAggregateArgs = {
    /**
     * Filter which ReferenceListItems to aggregate.
     * 
    **/
    where?: ReferenceListItemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReferenceListItems to fetch.
     * 
    **/
    orderBy?: Enumerable<ReferenceListItemsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: ReferenceListItemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReferenceListItems from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReferenceListItems.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ReferenceListItems
    **/
    _count?: true | ReferenceListItemsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReferenceListItemsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReferenceListItemsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReferenceListItemsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReferenceListItemsMaxAggregateInputType
  }

  export type GetReferenceListItemsAggregateType<T extends ReferenceListItemsAggregateArgs> = {
        [P in keyof T & keyof AggregateReferenceListItems]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReferenceListItems[P]>
      : GetScalarType<T[P], AggregateReferenceListItems[P]>
  }




  export type ReferenceListItemsGroupByArgs = {
    where?: ReferenceListItemsWhereInput
    orderBy?: Enumerable<ReferenceListItemsOrderByWithAggregationInput>
    by: Array<ReferenceListItemsScalarFieldEnum>
    having?: ReferenceListItemsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReferenceListItemsCountAggregateInputType | true
    _avg?: ReferenceListItemsAvgAggregateInputType
    _sum?: ReferenceListItemsSumAggregateInputType
    _min?: ReferenceListItemsMinAggregateInputType
    _max?: ReferenceListItemsMaxAggregateInputType
  }


  export type ReferenceListItemsGroupByOutputType = {
    listitem_id: number
    list_id: number
    dictionary_id: number
    code: string | null
    listitem_value: string | null
    parent_id: number | null
    value: string | null
    created_at: Date
    updated_at: Date
    dictionaryDictionaries_id: string | null
    _count: ReferenceListItemsCountAggregateOutputType | null
    _avg: ReferenceListItemsAvgAggregateOutputType | null
    _sum: ReferenceListItemsSumAggregateOutputType | null
    _min: ReferenceListItemsMinAggregateOutputType | null
    _max: ReferenceListItemsMaxAggregateOutputType | null
  }

  type GetReferenceListItemsGroupByPayload<T extends ReferenceListItemsGroupByArgs> = PrismaPromise<
    Array<
      PickArray<ReferenceListItemsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReferenceListItemsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReferenceListItemsGroupByOutputType[P]>
            : GetScalarType<T[P], ReferenceListItemsGroupByOutputType[P]>
        }
      >
    >


  export type ReferenceListItemsSelect = {
    listitem_id?: boolean
    list_id?: boolean
    list?: boolean | ReferenceListArgs
    dictionary_id?: boolean
    code?: boolean
    listitem_value?: boolean
    parent_id?: boolean
    value?: boolean
    created_at?: boolean
    updated_at?: boolean
    customer_experiences?: boolean | CustomerExperienceFindManyArgs
    Dictionary?: boolean | DictionaryArgs
    dictionaryDictionaries_id?: boolean
    JobReferenceList?: boolean | JobReferenceListFindManyArgs
    _count?: boolean | ReferenceListItemsCountOutputTypeArgs
  }


  export type ReferenceListItemsInclude = {
    list?: boolean | ReferenceListArgs
    customer_experiences?: boolean | CustomerExperienceFindManyArgs
    Dictionary?: boolean | DictionaryArgs
    JobReferenceList?: boolean | JobReferenceListFindManyArgs
    _count?: boolean | ReferenceListItemsCountOutputTypeArgs
  } 

  export type ReferenceListItemsGetPayload<S extends boolean | null | undefined | ReferenceListItemsArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? ReferenceListItems :
    S extends undefined ? never :
    S extends { include: any } & (ReferenceListItemsArgs | ReferenceListItemsFindManyArgs)
    ? ReferenceListItems  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'list' ? ReferenceListGetPayload<S['include'][P]> :
        P extends 'customer_experiences' ? Array < CustomerExperienceGetPayload<S['include'][P]>>  :
        P extends 'Dictionary' ? DictionaryGetPayload<S['include'][P]> | null :
        P extends 'JobReferenceList' ? Array < JobReferenceListGetPayload<S['include'][P]>>  :
        P extends '_count' ? ReferenceListItemsCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (ReferenceListItemsArgs | ReferenceListItemsFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'list' ? ReferenceListGetPayload<S['select'][P]> :
        P extends 'customer_experiences' ? Array < CustomerExperienceGetPayload<S['select'][P]>>  :
        P extends 'Dictionary' ? DictionaryGetPayload<S['select'][P]> | null :
        P extends 'JobReferenceList' ? Array < JobReferenceListGetPayload<S['select'][P]>>  :
        P extends '_count' ? ReferenceListItemsCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof ReferenceListItems ? ReferenceListItems[P] : never
  } 
      : ReferenceListItems


  type ReferenceListItemsCountArgs = Merge<
    Omit<ReferenceListItemsFindManyArgs, 'select' | 'include'> & {
      select?: ReferenceListItemsCountAggregateInputType | true
    }
  >

  export interface ReferenceListItemsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one ReferenceListItems that matches the filter.
     * @param {ReferenceListItemsFindUniqueArgs} args - Arguments to find a ReferenceListItems
     * @example
     * // Get one ReferenceListItems
     * const referenceListItems = await prisma.referenceListItems.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ReferenceListItemsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ReferenceListItemsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ReferenceListItems'> extends True ? Prisma__ReferenceListItemsClient<ReferenceListItemsGetPayload<T>> : Prisma__ReferenceListItemsClient<ReferenceListItemsGetPayload<T> | null, null>

    /**
     * Find one ReferenceListItems that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ReferenceListItemsFindUniqueOrThrowArgs} args - Arguments to find a ReferenceListItems
     * @example
     * // Get one ReferenceListItems
     * const referenceListItems = await prisma.referenceListItems.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ReferenceListItemsFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, ReferenceListItemsFindUniqueOrThrowArgs>
    ): Prisma__ReferenceListItemsClient<ReferenceListItemsGetPayload<T>>

    /**
     * Find the first ReferenceListItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferenceListItemsFindFirstArgs} args - Arguments to find a ReferenceListItems
     * @example
     * // Get one ReferenceListItems
     * const referenceListItems = await prisma.referenceListItems.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ReferenceListItemsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ReferenceListItemsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ReferenceListItems'> extends True ? Prisma__ReferenceListItemsClient<ReferenceListItemsGetPayload<T>> : Prisma__ReferenceListItemsClient<ReferenceListItemsGetPayload<T> | null, null>

    /**
     * Find the first ReferenceListItems that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferenceListItemsFindFirstOrThrowArgs} args - Arguments to find a ReferenceListItems
     * @example
     * // Get one ReferenceListItems
     * const referenceListItems = await prisma.referenceListItems.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ReferenceListItemsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ReferenceListItemsFindFirstOrThrowArgs>
    ): Prisma__ReferenceListItemsClient<ReferenceListItemsGetPayload<T>>

    /**
     * Find zero or more ReferenceListItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferenceListItemsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ReferenceListItems
     * const referenceListItems = await prisma.referenceListItems.findMany()
     * 
     * // Get first 10 ReferenceListItems
     * const referenceListItems = await prisma.referenceListItems.findMany({ take: 10 })
     * 
     * // Only select the `listitem_id`
     * const referenceListItemsWithListitem_idOnly = await prisma.referenceListItems.findMany({ select: { listitem_id: true } })
     * 
    **/
    findMany<T extends ReferenceListItemsFindManyArgs>(
      args?: SelectSubset<T, ReferenceListItemsFindManyArgs>
    ): PrismaPromise<Array<ReferenceListItemsGetPayload<T>>>

    /**
     * Create a ReferenceListItems.
     * @param {ReferenceListItemsCreateArgs} args - Arguments to create a ReferenceListItems.
     * @example
     * // Create one ReferenceListItems
     * const ReferenceListItems = await prisma.referenceListItems.create({
     *   data: {
     *     // ... data to create a ReferenceListItems
     *   }
     * })
     * 
    **/
    create<T extends ReferenceListItemsCreateArgs>(
      args: SelectSubset<T, ReferenceListItemsCreateArgs>
    ): Prisma__ReferenceListItemsClient<ReferenceListItemsGetPayload<T>>

    /**
     * Create many ReferenceListItems.
     *     @param {ReferenceListItemsCreateManyArgs} args - Arguments to create many ReferenceListItems.
     *     @example
     *     // Create many ReferenceListItems
     *     const referenceListItems = await prisma.referenceListItems.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ReferenceListItemsCreateManyArgs>(
      args?: SelectSubset<T, ReferenceListItemsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a ReferenceListItems.
     * @param {ReferenceListItemsDeleteArgs} args - Arguments to delete one ReferenceListItems.
     * @example
     * // Delete one ReferenceListItems
     * const ReferenceListItems = await prisma.referenceListItems.delete({
     *   where: {
     *     // ... filter to delete one ReferenceListItems
     *   }
     * })
     * 
    **/
    delete<T extends ReferenceListItemsDeleteArgs>(
      args: SelectSubset<T, ReferenceListItemsDeleteArgs>
    ): Prisma__ReferenceListItemsClient<ReferenceListItemsGetPayload<T>>

    /**
     * Update one ReferenceListItems.
     * @param {ReferenceListItemsUpdateArgs} args - Arguments to update one ReferenceListItems.
     * @example
     * // Update one ReferenceListItems
     * const referenceListItems = await prisma.referenceListItems.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ReferenceListItemsUpdateArgs>(
      args: SelectSubset<T, ReferenceListItemsUpdateArgs>
    ): Prisma__ReferenceListItemsClient<ReferenceListItemsGetPayload<T>>

    /**
     * Delete zero or more ReferenceListItems.
     * @param {ReferenceListItemsDeleteManyArgs} args - Arguments to filter ReferenceListItems to delete.
     * @example
     * // Delete a few ReferenceListItems
     * const { count } = await prisma.referenceListItems.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ReferenceListItemsDeleteManyArgs>(
      args?: SelectSubset<T, ReferenceListItemsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more ReferenceListItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferenceListItemsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ReferenceListItems
     * const referenceListItems = await prisma.referenceListItems.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ReferenceListItemsUpdateManyArgs>(
      args: SelectSubset<T, ReferenceListItemsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one ReferenceListItems.
     * @param {ReferenceListItemsUpsertArgs} args - Arguments to update or create a ReferenceListItems.
     * @example
     * // Update or create a ReferenceListItems
     * const referenceListItems = await prisma.referenceListItems.upsert({
     *   create: {
     *     // ... data to create a ReferenceListItems
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ReferenceListItems we want to update
     *   }
     * })
    **/
    upsert<T extends ReferenceListItemsUpsertArgs>(
      args: SelectSubset<T, ReferenceListItemsUpsertArgs>
    ): Prisma__ReferenceListItemsClient<ReferenceListItemsGetPayload<T>>

    /**
     * Count the number of ReferenceListItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferenceListItemsCountArgs} args - Arguments to filter ReferenceListItems to count.
     * @example
     * // Count the number of ReferenceListItems
     * const count = await prisma.referenceListItems.count({
     *   where: {
     *     // ... the filter for the ReferenceListItems we want to count
     *   }
     * })
    **/
    count<T extends ReferenceListItemsCountArgs>(
      args?: Subset<T, ReferenceListItemsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReferenceListItemsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ReferenceListItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferenceListItemsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReferenceListItemsAggregateArgs>(args: Subset<T, ReferenceListItemsAggregateArgs>): PrismaPromise<GetReferenceListItemsAggregateType<T>>

    /**
     * Group by ReferenceListItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferenceListItemsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReferenceListItemsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReferenceListItemsGroupByArgs['orderBy'] }
        : { orderBy?: ReferenceListItemsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReferenceListItemsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReferenceListItemsGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for ReferenceListItems.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ReferenceListItemsClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    list<T extends ReferenceListArgs= {}>(args?: Subset<T, ReferenceListArgs>): Prisma__ReferenceListClient<ReferenceListGetPayload<T> | Null>;

    customer_experiences<T extends CustomerExperienceFindManyArgs= {}>(args?: Subset<T, CustomerExperienceFindManyArgs>): PrismaPromise<Array<CustomerExperienceGetPayload<T>>| Null>;

    Dictionary<T extends DictionaryArgs= {}>(args?: Subset<T, DictionaryArgs>): Prisma__DictionaryClient<DictionaryGetPayload<T> | Null>;

    JobReferenceList<T extends JobReferenceListFindManyArgs= {}>(args?: Subset<T, JobReferenceListFindManyArgs>): PrismaPromise<Array<JobReferenceListGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * ReferenceListItems base type for findUnique actions
   */
  export type ReferenceListItemsFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the ReferenceListItems
     * 
    **/
    select?: ReferenceListItemsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ReferenceListItemsInclude | null
    /**
     * Filter, which ReferenceListItems to fetch.
     * 
    **/
    where: ReferenceListItemsWhereUniqueInput
  }

  /**
   * ReferenceListItems: findUnique
   */
  export interface ReferenceListItemsFindUniqueArgs extends ReferenceListItemsFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ReferenceListItems findUniqueOrThrow
   */
  export type ReferenceListItemsFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the ReferenceListItems
     * 
    **/
    select?: ReferenceListItemsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ReferenceListItemsInclude | null
    /**
     * Filter, which ReferenceListItems to fetch.
     * 
    **/
    where: ReferenceListItemsWhereUniqueInput
  }


  /**
   * ReferenceListItems base type for findFirst actions
   */
  export type ReferenceListItemsFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the ReferenceListItems
     * 
    **/
    select?: ReferenceListItemsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ReferenceListItemsInclude | null
    /**
     * Filter, which ReferenceListItems to fetch.
     * 
    **/
    where?: ReferenceListItemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReferenceListItems to fetch.
     * 
    **/
    orderBy?: Enumerable<ReferenceListItemsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReferenceListItems.
     * 
    **/
    cursor?: ReferenceListItemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReferenceListItems from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReferenceListItems.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReferenceListItems.
     * 
    **/
    distinct?: Enumerable<ReferenceListItemsScalarFieldEnum>
  }

  /**
   * ReferenceListItems: findFirst
   */
  export interface ReferenceListItemsFindFirstArgs extends ReferenceListItemsFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ReferenceListItems findFirstOrThrow
   */
  export type ReferenceListItemsFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the ReferenceListItems
     * 
    **/
    select?: ReferenceListItemsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ReferenceListItemsInclude | null
    /**
     * Filter, which ReferenceListItems to fetch.
     * 
    **/
    where?: ReferenceListItemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReferenceListItems to fetch.
     * 
    **/
    orderBy?: Enumerable<ReferenceListItemsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReferenceListItems.
     * 
    **/
    cursor?: ReferenceListItemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReferenceListItems from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReferenceListItems.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReferenceListItems.
     * 
    **/
    distinct?: Enumerable<ReferenceListItemsScalarFieldEnum>
  }


  /**
   * ReferenceListItems findMany
   */
  export type ReferenceListItemsFindManyArgs = {
    /**
     * Select specific fields to fetch from the ReferenceListItems
     * 
    **/
    select?: ReferenceListItemsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ReferenceListItemsInclude | null
    /**
     * Filter, which ReferenceListItems to fetch.
     * 
    **/
    where?: ReferenceListItemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReferenceListItems to fetch.
     * 
    **/
    orderBy?: Enumerable<ReferenceListItemsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ReferenceListItems.
     * 
    **/
    cursor?: ReferenceListItemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReferenceListItems from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReferenceListItems.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ReferenceListItemsScalarFieldEnum>
  }


  /**
   * ReferenceListItems create
   */
  export type ReferenceListItemsCreateArgs = {
    /**
     * Select specific fields to fetch from the ReferenceListItems
     * 
    **/
    select?: ReferenceListItemsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ReferenceListItemsInclude | null
    /**
     * The data needed to create a ReferenceListItems.
     * 
    **/
    data: XOR<ReferenceListItemsCreateInput, ReferenceListItemsUncheckedCreateInput>
  }


  /**
   * ReferenceListItems createMany
   */
  export type ReferenceListItemsCreateManyArgs = {
    /**
     * The data used to create many ReferenceListItems.
     * 
    **/
    data: Enumerable<ReferenceListItemsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * ReferenceListItems update
   */
  export type ReferenceListItemsUpdateArgs = {
    /**
     * Select specific fields to fetch from the ReferenceListItems
     * 
    **/
    select?: ReferenceListItemsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ReferenceListItemsInclude | null
    /**
     * The data needed to update a ReferenceListItems.
     * 
    **/
    data: XOR<ReferenceListItemsUpdateInput, ReferenceListItemsUncheckedUpdateInput>
    /**
     * Choose, which ReferenceListItems to update.
     * 
    **/
    where: ReferenceListItemsWhereUniqueInput
  }


  /**
   * ReferenceListItems updateMany
   */
  export type ReferenceListItemsUpdateManyArgs = {
    /**
     * The data used to update ReferenceListItems.
     * 
    **/
    data: XOR<ReferenceListItemsUpdateManyMutationInput, ReferenceListItemsUncheckedUpdateManyInput>
    /**
     * Filter which ReferenceListItems to update
     * 
    **/
    where?: ReferenceListItemsWhereInput
  }


  /**
   * ReferenceListItems upsert
   */
  export type ReferenceListItemsUpsertArgs = {
    /**
     * Select specific fields to fetch from the ReferenceListItems
     * 
    **/
    select?: ReferenceListItemsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ReferenceListItemsInclude | null
    /**
     * The filter to search for the ReferenceListItems to update in case it exists.
     * 
    **/
    where: ReferenceListItemsWhereUniqueInput
    /**
     * In case the ReferenceListItems found by the `where` argument doesn't exist, create a new ReferenceListItems with this data.
     * 
    **/
    create: XOR<ReferenceListItemsCreateInput, ReferenceListItemsUncheckedCreateInput>
    /**
     * In case the ReferenceListItems was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<ReferenceListItemsUpdateInput, ReferenceListItemsUncheckedUpdateInput>
  }


  /**
   * ReferenceListItems delete
   */
  export type ReferenceListItemsDeleteArgs = {
    /**
     * Select specific fields to fetch from the ReferenceListItems
     * 
    **/
    select?: ReferenceListItemsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ReferenceListItemsInclude | null
    /**
     * Filter which ReferenceListItems to delete.
     * 
    **/
    where: ReferenceListItemsWhereUniqueInput
  }


  /**
   * ReferenceListItems deleteMany
   */
  export type ReferenceListItemsDeleteManyArgs = {
    /**
     * Filter which ReferenceListItems to delete
     * 
    **/
    where?: ReferenceListItemsWhereInput
  }


  /**
   * ReferenceListItems without action
   */
  export type ReferenceListItemsArgs = {
    /**
     * Select specific fields to fetch from the ReferenceListItems
     * 
    **/
    select?: ReferenceListItemsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ReferenceListItemsInclude | null
  }



  /**
   * Model ScoutFav
   */


  export type AggregateScoutFav = {
    _count: ScoutFavCountAggregateOutputType | null
    _avg: ScoutFavAvgAggregateOutputType | null
    _sum: ScoutFavSumAggregateOutputType | null
    _min: ScoutFavMinAggregateOutputType | null
    _max: ScoutFavMaxAggregateOutputType | null
  }

  export type ScoutFavAvgAggregateOutputType = {
    entity_id: number | null
    branch_id: number | null
  }

  export type ScoutFavSumAggregateOutputType = {
    entity_id: number | null
    branch_id: number | null
  }

  export type ScoutFavMinAggregateOutputType = {
    scout_id: string | null
    entity_id: number | null
    branch_id: number | null
    user_id: string | null
    job_id: string | null
    note: string | null
    created_at: Date | null
    created_by: string | null
  }

  export type ScoutFavMaxAggregateOutputType = {
    scout_id: string | null
    entity_id: number | null
    branch_id: number | null
    user_id: string | null
    job_id: string | null
    note: string | null
    created_at: Date | null
    created_by: string | null
  }

  export type ScoutFavCountAggregateOutputType = {
    scout_id: number
    entity_id: number
    branch_id: number
    user_id: number
    job_id: number
    note: number
    created_at: number
    created_by: number
    _all: number
  }


  export type ScoutFavAvgAggregateInputType = {
    entity_id?: true
    branch_id?: true
  }

  export type ScoutFavSumAggregateInputType = {
    entity_id?: true
    branch_id?: true
  }

  export type ScoutFavMinAggregateInputType = {
    scout_id?: true
    entity_id?: true
    branch_id?: true
    user_id?: true
    job_id?: true
    note?: true
    created_at?: true
    created_by?: true
  }

  export type ScoutFavMaxAggregateInputType = {
    scout_id?: true
    entity_id?: true
    branch_id?: true
    user_id?: true
    job_id?: true
    note?: true
    created_at?: true
    created_by?: true
  }

  export type ScoutFavCountAggregateInputType = {
    scout_id?: true
    entity_id?: true
    branch_id?: true
    user_id?: true
    job_id?: true
    note?: true
    created_at?: true
    created_by?: true
    _all?: true
  }

  export type ScoutFavAggregateArgs = {
    /**
     * Filter which ScoutFav to aggregate.
     * 
    **/
    where?: ScoutFavWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScoutFavs to fetch.
     * 
    **/
    orderBy?: Enumerable<ScoutFavOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: ScoutFavWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScoutFavs from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScoutFavs.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ScoutFavs
    **/
    _count?: true | ScoutFavCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ScoutFavAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ScoutFavSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ScoutFavMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ScoutFavMaxAggregateInputType
  }

  export type GetScoutFavAggregateType<T extends ScoutFavAggregateArgs> = {
        [P in keyof T & keyof AggregateScoutFav]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateScoutFav[P]>
      : GetScalarType<T[P], AggregateScoutFav[P]>
  }




  export type ScoutFavGroupByArgs = {
    where?: ScoutFavWhereInput
    orderBy?: Enumerable<ScoutFavOrderByWithAggregationInput>
    by: Array<ScoutFavScalarFieldEnum>
    having?: ScoutFavScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ScoutFavCountAggregateInputType | true
    _avg?: ScoutFavAvgAggregateInputType
    _sum?: ScoutFavSumAggregateInputType
    _min?: ScoutFavMinAggregateInputType
    _max?: ScoutFavMaxAggregateInputType
  }


  export type ScoutFavGroupByOutputType = {
    scout_id: string
    entity_id: number | null
    branch_id: number | null
    user_id: string
    job_id: string | null
    note: string
    created_at: Date
    created_by: string
    _count: ScoutFavCountAggregateOutputType | null
    _avg: ScoutFavAvgAggregateOutputType | null
    _sum: ScoutFavSumAggregateOutputType | null
    _min: ScoutFavMinAggregateOutputType | null
    _max: ScoutFavMaxAggregateOutputType | null
  }

  type GetScoutFavGroupByPayload<T extends ScoutFavGroupByArgs> = PrismaPromise<
    Array<
      PickArray<ScoutFavGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ScoutFavGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ScoutFavGroupByOutputType[P]>
            : GetScalarType<T[P], ScoutFavGroupByOutputType[P]>
        }
      >
    >


  export type ScoutFavSelect = {
    scout_id?: boolean
    entity_id?: boolean
    branch_id?: boolean
    user_id?: boolean
    user?: boolean | UserArgs
    job_id?: boolean
    note?: boolean
    created_at?: boolean
    created_by?: boolean
  }


  export type ScoutFavInclude = {
    user?: boolean | UserArgs
  } 

  export type ScoutFavGetPayload<S extends boolean | null | undefined | ScoutFavArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? ScoutFav :
    S extends undefined ? never :
    S extends { include: any } & (ScoutFavArgs | ScoutFavFindManyArgs)
    ? ScoutFav  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'user' ? UserGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (ScoutFavArgs | ScoutFavFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'user' ? UserGetPayload<S['select'][P]> :  P extends keyof ScoutFav ? ScoutFav[P] : never
  } 
      : ScoutFav


  type ScoutFavCountArgs = Merge<
    Omit<ScoutFavFindManyArgs, 'select' | 'include'> & {
      select?: ScoutFavCountAggregateInputType | true
    }
  >

  export interface ScoutFavDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one ScoutFav that matches the filter.
     * @param {ScoutFavFindUniqueArgs} args - Arguments to find a ScoutFav
     * @example
     * // Get one ScoutFav
     * const scoutFav = await prisma.scoutFav.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ScoutFavFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ScoutFavFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ScoutFav'> extends True ? Prisma__ScoutFavClient<ScoutFavGetPayload<T>> : Prisma__ScoutFavClient<ScoutFavGetPayload<T> | null, null>

    /**
     * Find one ScoutFav that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ScoutFavFindUniqueOrThrowArgs} args - Arguments to find a ScoutFav
     * @example
     * // Get one ScoutFav
     * const scoutFav = await prisma.scoutFav.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ScoutFavFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, ScoutFavFindUniqueOrThrowArgs>
    ): Prisma__ScoutFavClient<ScoutFavGetPayload<T>>

    /**
     * Find the first ScoutFav that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScoutFavFindFirstArgs} args - Arguments to find a ScoutFav
     * @example
     * // Get one ScoutFav
     * const scoutFav = await prisma.scoutFav.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ScoutFavFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ScoutFavFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ScoutFav'> extends True ? Prisma__ScoutFavClient<ScoutFavGetPayload<T>> : Prisma__ScoutFavClient<ScoutFavGetPayload<T> | null, null>

    /**
     * Find the first ScoutFav that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScoutFavFindFirstOrThrowArgs} args - Arguments to find a ScoutFav
     * @example
     * // Get one ScoutFav
     * const scoutFav = await prisma.scoutFav.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ScoutFavFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ScoutFavFindFirstOrThrowArgs>
    ): Prisma__ScoutFavClient<ScoutFavGetPayload<T>>

    /**
     * Find zero or more ScoutFavs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScoutFavFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ScoutFavs
     * const scoutFavs = await prisma.scoutFav.findMany()
     * 
     * // Get first 10 ScoutFavs
     * const scoutFavs = await prisma.scoutFav.findMany({ take: 10 })
     * 
     * // Only select the `scout_id`
     * const scoutFavWithScout_idOnly = await prisma.scoutFav.findMany({ select: { scout_id: true } })
     * 
    **/
    findMany<T extends ScoutFavFindManyArgs>(
      args?: SelectSubset<T, ScoutFavFindManyArgs>
    ): PrismaPromise<Array<ScoutFavGetPayload<T>>>

    /**
     * Create a ScoutFav.
     * @param {ScoutFavCreateArgs} args - Arguments to create a ScoutFav.
     * @example
     * // Create one ScoutFav
     * const ScoutFav = await prisma.scoutFav.create({
     *   data: {
     *     // ... data to create a ScoutFav
     *   }
     * })
     * 
    **/
    create<T extends ScoutFavCreateArgs>(
      args: SelectSubset<T, ScoutFavCreateArgs>
    ): Prisma__ScoutFavClient<ScoutFavGetPayload<T>>

    /**
     * Create many ScoutFavs.
     *     @param {ScoutFavCreateManyArgs} args - Arguments to create many ScoutFavs.
     *     @example
     *     // Create many ScoutFavs
     *     const scoutFav = await prisma.scoutFav.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ScoutFavCreateManyArgs>(
      args?: SelectSubset<T, ScoutFavCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a ScoutFav.
     * @param {ScoutFavDeleteArgs} args - Arguments to delete one ScoutFav.
     * @example
     * // Delete one ScoutFav
     * const ScoutFav = await prisma.scoutFav.delete({
     *   where: {
     *     // ... filter to delete one ScoutFav
     *   }
     * })
     * 
    **/
    delete<T extends ScoutFavDeleteArgs>(
      args: SelectSubset<T, ScoutFavDeleteArgs>
    ): Prisma__ScoutFavClient<ScoutFavGetPayload<T>>

    /**
     * Update one ScoutFav.
     * @param {ScoutFavUpdateArgs} args - Arguments to update one ScoutFav.
     * @example
     * // Update one ScoutFav
     * const scoutFav = await prisma.scoutFav.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ScoutFavUpdateArgs>(
      args: SelectSubset<T, ScoutFavUpdateArgs>
    ): Prisma__ScoutFavClient<ScoutFavGetPayload<T>>

    /**
     * Delete zero or more ScoutFavs.
     * @param {ScoutFavDeleteManyArgs} args - Arguments to filter ScoutFavs to delete.
     * @example
     * // Delete a few ScoutFavs
     * const { count } = await prisma.scoutFav.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ScoutFavDeleteManyArgs>(
      args?: SelectSubset<T, ScoutFavDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more ScoutFavs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScoutFavUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ScoutFavs
     * const scoutFav = await prisma.scoutFav.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ScoutFavUpdateManyArgs>(
      args: SelectSubset<T, ScoutFavUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one ScoutFav.
     * @param {ScoutFavUpsertArgs} args - Arguments to update or create a ScoutFav.
     * @example
     * // Update or create a ScoutFav
     * const scoutFav = await prisma.scoutFav.upsert({
     *   create: {
     *     // ... data to create a ScoutFav
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ScoutFav we want to update
     *   }
     * })
    **/
    upsert<T extends ScoutFavUpsertArgs>(
      args: SelectSubset<T, ScoutFavUpsertArgs>
    ): Prisma__ScoutFavClient<ScoutFavGetPayload<T>>

    /**
     * Count the number of ScoutFavs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScoutFavCountArgs} args - Arguments to filter ScoutFavs to count.
     * @example
     * // Count the number of ScoutFavs
     * const count = await prisma.scoutFav.count({
     *   where: {
     *     // ... the filter for the ScoutFavs we want to count
     *   }
     * })
    **/
    count<T extends ScoutFavCountArgs>(
      args?: Subset<T, ScoutFavCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ScoutFavCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ScoutFav.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScoutFavAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ScoutFavAggregateArgs>(args: Subset<T, ScoutFavAggregateArgs>): PrismaPromise<GetScoutFavAggregateType<T>>

    /**
     * Group by ScoutFav.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScoutFavGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ScoutFavGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ScoutFavGroupByArgs['orderBy'] }
        : { orderBy?: ScoutFavGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ScoutFavGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetScoutFavGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for ScoutFav.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ScoutFavClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    user<T extends UserArgs= {}>(args?: Subset<T, UserArgs>): Prisma__UserClient<UserGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * ScoutFav base type for findUnique actions
   */
  export type ScoutFavFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the ScoutFav
     * 
    **/
    select?: ScoutFavSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ScoutFavInclude | null
    /**
     * Filter, which ScoutFav to fetch.
     * 
    **/
    where: ScoutFavWhereUniqueInput
  }

  /**
   * ScoutFav: findUnique
   */
  export interface ScoutFavFindUniqueArgs extends ScoutFavFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ScoutFav findUniqueOrThrow
   */
  export type ScoutFavFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the ScoutFav
     * 
    **/
    select?: ScoutFavSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ScoutFavInclude | null
    /**
     * Filter, which ScoutFav to fetch.
     * 
    **/
    where: ScoutFavWhereUniqueInput
  }


  /**
   * ScoutFav base type for findFirst actions
   */
  export type ScoutFavFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the ScoutFav
     * 
    **/
    select?: ScoutFavSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ScoutFavInclude | null
    /**
     * Filter, which ScoutFav to fetch.
     * 
    **/
    where?: ScoutFavWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScoutFavs to fetch.
     * 
    **/
    orderBy?: Enumerable<ScoutFavOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ScoutFavs.
     * 
    **/
    cursor?: ScoutFavWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScoutFavs from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScoutFavs.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ScoutFavs.
     * 
    **/
    distinct?: Enumerable<ScoutFavScalarFieldEnum>
  }

  /**
   * ScoutFav: findFirst
   */
  export interface ScoutFavFindFirstArgs extends ScoutFavFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ScoutFav findFirstOrThrow
   */
  export type ScoutFavFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the ScoutFav
     * 
    **/
    select?: ScoutFavSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ScoutFavInclude | null
    /**
     * Filter, which ScoutFav to fetch.
     * 
    **/
    where?: ScoutFavWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScoutFavs to fetch.
     * 
    **/
    orderBy?: Enumerable<ScoutFavOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ScoutFavs.
     * 
    **/
    cursor?: ScoutFavWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScoutFavs from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScoutFavs.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ScoutFavs.
     * 
    **/
    distinct?: Enumerable<ScoutFavScalarFieldEnum>
  }


  /**
   * ScoutFav findMany
   */
  export type ScoutFavFindManyArgs = {
    /**
     * Select specific fields to fetch from the ScoutFav
     * 
    **/
    select?: ScoutFavSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ScoutFavInclude | null
    /**
     * Filter, which ScoutFavs to fetch.
     * 
    **/
    where?: ScoutFavWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScoutFavs to fetch.
     * 
    **/
    orderBy?: Enumerable<ScoutFavOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ScoutFavs.
     * 
    **/
    cursor?: ScoutFavWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScoutFavs from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScoutFavs.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ScoutFavScalarFieldEnum>
  }


  /**
   * ScoutFav create
   */
  export type ScoutFavCreateArgs = {
    /**
     * Select specific fields to fetch from the ScoutFav
     * 
    **/
    select?: ScoutFavSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ScoutFavInclude | null
    /**
     * The data needed to create a ScoutFav.
     * 
    **/
    data: XOR<ScoutFavCreateInput, ScoutFavUncheckedCreateInput>
  }


  /**
   * ScoutFav createMany
   */
  export type ScoutFavCreateManyArgs = {
    /**
     * The data used to create many ScoutFavs.
     * 
    **/
    data: Enumerable<ScoutFavCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * ScoutFav update
   */
  export type ScoutFavUpdateArgs = {
    /**
     * Select specific fields to fetch from the ScoutFav
     * 
    **/
    select?: ScoutFavSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ScoutFavInclude | null
    /**
     * The data needed to update a ScoutFav.
     * 
    **/
    data: XOR<ScoutFavUpdateInput, ScoutFavUncheckedUpdateInput>
    /**
     * Choose, which ScoutFav to update.
     * 
    **/
    where: ScoutFavWhereUniqueInput
  }


  /**
   * ScoutFav updateMany
   */
  export type ScoutFavUpdateManyArgs = {
    /**
     * The data used to update ScoutFavs.
     * 
    **/
    data: XOR<ScoutFavUpdateManyMutationInput, ScoutFavUncheckedUpdateManyInput>
    /**
     * Filter which ScoutFavs to update
     * 
    **/
    where?: ScoutFavWhereInput
  }


  /**
   * ScoutFav upsert
   */
  export type ScoutFavUpsertArgs = {
    /**
     * Select specific fields to fetch from the ScoutFav
     * 
    **/
    select?: ScoutFavSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ScoutFavInclude | null
    /**
     * The filter to search for the ScoutFav to update in case it exists.
     * 
    **/
    where: ScoutFavWhereUniqueInput
    /**
     * In case the ScoutFav found by the `where` argument doesn't exist, create a new ScoutFav with this data.
     * 
    **/
    create: XOR<ScoutFavCreateInput, ScoutFavUncheckedCreateInput>
    /**
     * In case the ScoutFav was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<ScoutFavUpdateInput, ScoutFavUncheckedUpdateInput>
  }


  /**
   * ScoutFav delete
   */
  export type ScoutFavDeleteArgs = {
    /**
     * Select specific fields to fetch from the ScoutFav
     * 
    **/
    select?: ScoutFavSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ScoutFavInclude | null
    /**
     * Filter which ScoutFav to delete.
     * 
    **/
    where: ScoutFavWhereUniqueInput
  }


  /**
   * ScoutFav deleteMany
   */
  export type ScoutFavDeleteManyArgs = {
    /**
     * Filter which ScoutFavs to delete
     * 
    **/
    where?: ScoutFavWhereInput
  }


  /**
   * ScoutFav without action
   */
  export type ScoutFavArgs = {
    /**
     * Select specific fields to fetch from the ScoutFav
     * 
    **/
    select?: ScoutFavSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ScoutFavInclude | null
  }



  /**
   * Model User
   */


  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    company_id: number | null
    attemptpass_count: number | null
  }

  export type UserSumAggregateOutputType = {
    company_id: number | null
    attemptpass_count: number | null
  }

  export type UserMinAggregateOutputType = {
    user_id: string | null
    email: string | null
    mobile: string | null
    name: string | null
    password_hash: string | null
    role: UserRole | null
    company_id: number | null
    customer_id: string | null
    attemptpass_count: number | null
    reset_code: string | null
    is_emailverified: boolean | null
    is_mobileverified: boolean | null
    user_status: UserStatus | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
  }

  export type UserMaxAggregateOutputType = {
    user_id: string | null
    email: string | null
    mobile: string | null
    name: string | null
    password_hash: string | null
    role: UserRole | null
    company_id: number | null
    customer_id: string | null
    attemptpass_count: number | null
    reset_code: string | null
    is_emailverified: boolean | null
    is_mobileverified: boolean | null
    user_status: UserStatus | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
  }

  export type UserCountAggregateOutputType = {
    user_id: number
    email: number
    mobile: number
    name: number
    password_hash: number
    role: number
    company_id: number
    customer_id: number
    attemptpass_count: number
    reset_code: number
    is_emailverified: number
    is_mobileverified: number
    user_status: number
    created_at: number
    updated_at: number
    deleted_at: number
    favs: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    company_id?: true
    attemptpass_count?: true
  }

  export type UserSumAggregateInputType = {
    company_id?: true
    attemptpass_count?: true
  }

  export type UserMinAggregateInputType = {
    user_id?: true
    email?: true
    mobile?: true
    name?: true
    password_hash?: true
    role?: true
    company_id?: true
    customer_id?: true
    attemptpass_count?: true
    reset_code?: true
    is_emailverified?: true
    is_mobileverified?: true
    user_status?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
  }

  export type UserMaxAggregateInputType = {
    user_id?: true
    email?: true
    mobile?: true
    name?: true
    password_hash?: true
    role?: true
    company_id?: true
    customer_id?: true
    attemptpass_count?: true
    reset_code?: true
    is_emailverified?: true
    is_mobileverified?: true
    user_status?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
  }

  export type UserCountAggregateInputType = {
    user_id?: true
    email?: true
    mobile?: true
    name?: true
    password_hash?: true
    role?: true
    company_id?: true
    customer_id?: true
    attemptpass_count?: true
    reset_code?: true
    is_emailverified?: true
    is_mobileverified?: true
    user_status?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
    favs?: true
    _all?: true
  }

  export type UserAggregateArgs = {
    /**
     * Filter which User to aggregate.
     * 
    **/
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     * 
    **/
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs = {
    where?: UserWhereInput
    orderBy?: Enumerable<UserOrderByWithAggregationInput>
    by: Array<UserScalarFieldEnum>
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }


  export type UserGroupByOutputType = {
    user_id: string
    email: string
    mobile: string | null
    name: string | null
    password_hash: string
    role: UserRole
    company_id: number
    customer_id: string | null
    attemptpass_count: number | null
    reset_code: string
    is_emailverified: boolean
    is_mobileverified: boolean
    user_status: UserStatus
    created_at: Date
    updated_at: Date
    deleted_at: Date | null
    favs: JsonValue
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = PrismaPromise<
    Array<
      PickArray<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect = {
    user_id?: boolean
    email?: boolean
    mobile?: boolean
    name?: boolean
    password_hash?: boolean
    role?: boolean
    company_id?: boolean
    customer_id?: boolean
    attemptpass_count?: boolean
    reset_code?: boolean
    is_emailverified?: boolean
    is_mobileverified?: boolean
    user_status?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
    favs?: boolean
    Customer?: boolean | CustomerArgs
    loggers?: boolean | LoggerFindManyArgs
    from_inquiries?: boolean | InquiryFindManyArgs
    assign_inquiries?: boolean | InquiryFindManyArgs
    notifications?: boolean | NotificationFindManyArgs
    ScoutFav?: boolean | ScoutFavFindManyArgs
    _count?: boolean | UserCountOutputTypeArgs
  }


  export type UserInclude = {
    Customer?: boolean | CustomerArgs
    loggers?: boolean | LoggerFindManyArgs
    from_inquiries?: boolean | InquiryFindManyArgs
    assign_inquiries?: boolean | InquiryFindManyArgs
    notifications?: boolean | NotificationFindManyArgs
    ScoutFav?: boolean | ScoutFavFindManyArgs
    _count?: boolean | UserCountOutputTypeArgs
  } 

  export type UserGetPayload<S extends boolean | null | undefined | UserArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? User :
    S extends undefined ? never :
    S extends { include: any } & (UserArgs | UserFindManyArgs)
    ? User  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'Customer' ? CustomerGetPayload<S['include'][P]> | null :
        P extends 'loggers' ? Array < LoggerGetPayload<S['include'][P]>>  :
        P extends 'from_inquiries' ? Array < InquiryGetPayload<S['include'][P]>>  :
        P extends 'assign_inquiries' ? Array < InquiryGetPayload<S['include'][P]>>  :
        P extends 'notifications' ? Array < NotificationGetPayload<S['include'][P]>>  :
        P extends 'ScoutFav' ? Array < ScoutFavGetPayload<S['include'][P]>>  :
        P extends '_count' ? UserCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (UserArgs | UserFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'Customer' ? CustomerGetPayload<S['select'][P]> | null :
        P extends 'loggers' ? Array < LoggerGetPayload<S['select'][P]>>  :
        P extends 'from_inquiries' ? Array < InquiryGetPayload<S['select'][P]>>  :
        P extends 'assign_inquiries' ? Array < InquiryGetPayload<S['select'][P]>>  :
        P extends 'notifications' ? Array < NotificationGetPayload<S['select'][P]>>  :
        P extends 'ScoutFav' ? Array < ScoutFavGetPayload<S['select'][P]>>  :
        P extends '_count' ? UserCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof User ? User[P] : never
  } 
      : User


  type UserCountArgs = Merge<
    Omit<UserFindManyArgs, 'select' | 'include'> & {
      select?: UserCountAggregateInputType | true
    }
  >

  export interface UserDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, UserFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'User'> extends True ? Prisma__UserClient<UserGetPayload<T>> : Prisma__UserClient<UserGetPayload<T> | null, null>

    /**
     * Find one User that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, UserFindUniqueOrThrowArgs>
    ): Prisma__UserClient<UserGetPayload<T>>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, UserFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'User'> extends True ? Prisma__UserClient<UserGetPayload<T>> : Prisma__UserClient<UserGetPayload<T> | null, null>

    /**
     * Find the first User that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(
      args?: SelectSubset<T, UserFindFirstOrThrowArgs>
    ): Prisma__UserClient<UserGetPayload<T>>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `user_id`
     * const userWithUser_idOnly = await prisma.user.findMany({ select: { user_id: true } })
     * 
    **/
    findMany<T extends UserFindManyArgs>(
      args?: SelectSubset<T, UserFindManyArgs>
    ): PrismaPromise<Array<UserGetPayload<T>>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
    **/
    create<T extends UserCreateArgs>(
      args: SelectSubset<T, UserCreateArgs>
    ): Prisma__UserClient<UserGetPayload<T>>

    /**
     * Create many Users.
     *     @param {UserCreateManyArgs} args - Arguments to create many Users.
     *     @example
     *     // Create many Users
     *     const user = await prisma.user.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserCreateManyArgs>(
      args?: SelectSubset<T, UserCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
    **/
    delete<T extends UserDeleteArgs>(
      args: SelectSubset<T, UserDeleteArgs>
    ): Prisma__UserClient<UserGetPayload<T>>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserUpdateArgs>(
      args: SelectSubset<T, UserUpdateArgs>
    ): Prisma__UserClient<UserGetPayload<T>>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserDeleteManyArgs>(
      args?: SelectSubset<T, UserDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserUpdateManyArgs>(
      args: SelectSubset<T, UserUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
    **/
    upsert<T extends UserUpsertArgs>(
      args: SelectSubset<T, UserUpsertArgs>
    ): Prisma__UserClient<UserGetPayload<T>>

    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__UserClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    Customer<T extends CustomerArgs= {}>(args?: Subset<T, CustomerArgs>): Prisma__CustomerClient<CustomerGetPayload<T> | Null>;

    loggers<T extends LoggerFindManyArgs= {}>(args?: Subset<T, LoggerFindManyArgs>): PrismaPromise<Array<LoggerGetPayload<T>>| Null>;

    from_inquiries<T extends InquiryFindManyArgs= {}>(args?: Subset<T, InquiryFindManyArgs>): PrismaPromise<Array<InquiryGetPayload<T>>| Null>;

    assign_inquiries<T extends InquiryFindManyArgs= {}>(args?: Subset<T, InquiryFindManyArgs>): PrismaPromise<Array<InquiryGetPayload<T>>| Null>;

    notifications<T extends NotificationFindManyArgs= {}>(args?: Subset<T, NotificationFindManyArgs>): PrismaPromise<Array<NotificationGetPayload<T>>| Null>;

    ScoutFav<T extends ScoutFavFindManyArgs= {}>(args?: Subset<T, ScoutFavFindManyArgs>): PrismaPromise<Array<ScoutFavGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * User base type for findUnique actions
   */
  export type UserFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * Filter, which User to fetch.
     * 
    **/
    where: UserWhereUniqueInput
  }

  /**
   * User: findUnique
   */
  export interface UserFindUniqueArgs extends UserFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * Filter, which User to fetch.
     * 
    **/
    where: UserWhereUniqueInput
  }


  /**
   * User base type for findFirst actions
   */
  export type UserFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * Filter, which User to fetch.
     * 
    **/
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     * 
    **/
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     * 
    **/
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     * 
    **/
    distinct?: Enumerable<UserScalarFieldEnum>
  }

  /**
   * User: findFirst
   */
  export interface UserFindFirstArgs extends UserFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * Filter, which User to fetch.
     * 
    **/
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     * 
    **/
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     * 
    **/
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     * 
    **/
    distinct?: Enumerable<UserScalarFieldEnum>
  }


  /**
   * User findMany
   */
  export type UserFindManyArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * Filter, which Users to fetch.
     * 
    **/
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     * 
    **/
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     * 
    **/
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     * 
    **/
    skip?: number
    distinct?: Enumerable<UserScalarFieldEnum>
  }


  /**
   * User create
   */
  export type UserCreateArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * The data needed to create a User.
     * 
    **/
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }


  /**
   * User createMany
   */
  export type UserCreateManyArgs = {
    /**
     * The data used to create many Users.
     * 
    **/
    data: Enumerable<UserCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * User update
   */
  export type UserUpdateArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * The data needed to update a User.
     * 
    **/
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     * 
    **/
    where: UserWhereUniqueInput
  }


  /**
   * User updateMany
   */
  export type UserUpdateManyArgs = {
    /**
     * The data used to update Users.
     * 
    **/
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     * 
    **/
    where?: UserWhereInput
  }


  /**
   * User upsert
   */
  export type UserUpsertArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * The filter to search for the User to update in case it exists.
     * 
    **/
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     * 
    **/
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }


  /**
   * User delete
   */
  export type UserDeleteArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * Filter which User to delete.
     * 
    **/
    where: UserWhereUniqueInput
  }


  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs = {
    /**
     * Filter which Users to delete
     * 
    **/
    where?: UserWhereInput
  }


  /**
   * User without action
   */
  export type UserArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
  }



  /**
   * Enums
   */

  // Based on
  // https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

  export const ActionRoleScalarFieldEnum: {
    action_role_id: 'action_role_id',
    controller_path: 'controller_path',
    action_user: 'action_user',
    role: 'role',
    is_can: 'is_can',
    is_company: 'is_company',
    parent_id: 'parent_id',
    created_at: 'created_at',
    updated_at: 'updated_at',
    created_by: 'created_by',
    updated_by: 'updated_by'
  };

  export type ActionRoleScalarFieldEnum = (typeof ActionRoleScalarFieldEnum)[keyof typeof ActionRoleScalarFieldEnum]


  export const CustomerDesiredScalarFieldEnum: {
    desired_id: 'desired_id',
    customer_id: 'customer_id',
    occupation: 'occupation',
    industry: 'industry',
    location: 'location',
    career_level: 'career_level',
    contract_type: 'contract_type',
    desired_company: 'desired_company',
    time_to: 'time_to',
    annual_income: 'annual_income',
    created_at: 'created_at',
    updated_at: 'updated_at',
    created_by: 'created_by',
    updated_by: 'updated_by'
  };

  export type CustomerDesiredScalarFieldEnum = (typeof CustomerDesiredScalarFieldEnum)[keyof typeof CustomerDesiredScalarFieldEnum]


  export const CustomerEducationScalarFieldEnum: {
    education_id: 'education_id',
    customer_id: 'customer_id',
    country: 'country',
    degree: 'degree',
    entrollment_date: 'entrollment_date',
    graduate_date: 'graduate_date',
    is_current: 'is_current',
    school_id: 'school_id',
    school: 'school',
    faculty: 'faculty',
    department: 'department',
    created_at: 'created_at',
    updated_at: 'updated_at',
    created_by: 'created_by',
    updated_by: 'updated_by'
  };

  export type CustomerEducationScalarFieldEnum = (typeof CustomerEducationScalarFieldEnum)[keyof typeof CustomerEducationScalarFieldEnum]


  export const CustomerExperienceScalarFieldEnum: {
    experience_id: 'experience_id',
    jobdetail_id: 'jobdetail_id',
    skill_id: 'skill_id',
    over_year: 'over_year',
    created_at: 'created_at',
    updated_at: 'updated_at',
    created_by: 'created_by',
    updated_by: 'updated_by'
  };

  export type CustomerExperienceScalarFieldEnum = (typeof CustomerExperienceScalarFieldEnum)[keyof typeof CustomerExperienceScalarFieldEnum]


  export const CustomerJobDetailScalarFieldEnum: {
    jobdetail_id: 'jobdetail_id',
    customer_id: 'customer_id',
    experienced_company: 'experienced_company',
    annual_income: 'annual_income',
    has_management_exp: 'has_management_exp',
    created_at: 'created_at',
    updated_at: 'updated_at',
    created_by: 'created_by',
    updated_by: 'updated_by'
  };

  export type CustomerJobDetailScalarFieldEnum = (typeof CustomerJobDetailScalarFieldEnum)[keyof typeof CustomerJobDetailScalarFieldEnum]


  export const CustomerLanguageScalarFieldEnum: {
    language_id: 'language_id',
    customer_id: 'customer_id',
    level: 'level',
    language: 'language',
    is_motherlanguage: 'is_motherlanguage',
    certificate: 'certificate',
    created_at: 'created_at',
    updated_at: 'updated_at',
    created_by: 'created_by',
    updated_b: 'updated_b'
  };

  export type CustomerLanguageScalarFieldEnum = (typeof CustomerLanguageScalarFieldEnum)[keyof typeof CustomerLanguageScalarFieldEnum]


  export const CustomerQualificationScalarFieldEnum: {
    qualification_id: 'qualification_id',
    customer_id: 'customer_id',
    qualification: 'qualification',
    created_at: 'created_at',
    updated_at: 'updated_at',
    created_by: 'created_by',
    updated_by: 'updated_by'
  };

  export type CustomerQualificationScalarFieldEnum = (typeof CustomerQualificationScalarFieldEnum)[keyof typeof CustomerQualificationScalarFieldEnum]


  export const CustomerScalarFieldEnum: {
    customer_id: 'customer_id',
    first_name: 'first_name',
    last_name: 'last_name',
    first_name_kana: 'first_name_kana',
    last_name_kana: 'last_name_kana',
    gender: 'gender',
    birth_date: 'birth_date',
    spouse: 'spouse',
    family_size: 'family_size',
    email: 'email',
    mobile: 'mobile',
    phone: 'phone',
    profile_image: 'profile_image',
    cv_file: 'cv_file',
    resume_file: 'resume_file',
    prefecture: 'prefecture',
    post_code: 'post_code',
    city: 'city',
    district: 'district',
    address: 'address',
    address1: 'address1',
    nearest_station: 'nearest_station',
    socials: 'socials',
    country: 'country',
    experienced_year: 'experienced_year',
    from_data: 'from_data',
    status_customer: 'status_customer',
    created_at: 'created_at',
    updated_at: 'updated_at',
    created_by: 'created_by',
    updated_by: 'updated_by'
  };

  export type CustomerScalarFieldEnum = (typeof CustomerScalarFieldEnum)[keyof typeof CustomerScalarFieldEnum]


  export const CustomerVisaScalarFieldEnum: {
    visa_id: 'visa_id',
    customer_id: 'customer_id',
    status_visa: 'status_visa',
    date_expire: 'date_expire',
    country_citizenship: 'country_citizenship',
    back_visafile: 'back_visafile',
    front_visafile: 'front_visafile',
    created_at: 'created_at',
    updated_at: 'updated_at',
    created_by: 'created_by',
    updated_by: 'updated_by'
  };

  export type CustomerVisaScalarFieldEnum = (typeof CustomerVisaScalarFieldEnum)[keyof typeof CustomerVisaScalarFieldEnum]


  export const CustomerWorkHistoryScalarFieldEnum: {
    workhistory_id: 'workhistory_id',
    customer_id: 'customer_id',
    company_id: 'company_id',
    company_info: 'company_info',
    occupation: 'occupation',
    industry: 'industry',
    position: 'position',
    enter_date: 'enter_date',
    leave_date: 'leave_date',
    working_month: 'working_month',
    is_current: 'is_current',
    duties: 'duties',
    created_at: 'created_at',
    updated_at: 'updated_at',
    created_by: 'created_by',
    updated_by: 'updated_by'
  };

  export type CustomerWorkHistoryScalarFieldEnum = (typeof CustomerWorkHistoryScalarFieldEnum)[keyof typeof CustomerWorkHistoryScalarFieldEnum]


  export const DictionaryScalarFieldEnum: {
    dictionaries_id: 'dictionaries_id',
    dictionary_id: 'dictionary_id',
    language_code: 'language_code',
    dic_value: 'dic_value',
    created_at: 'created_at'
  };

  export type DictionaryScalarFieldEnum = (typeof DictionaryScalarFieldEnum)[keyof typeof DictionaryScalarFieldEnum]


  export const EntityAccountInfoScalarFieldEnum: {
    entity_accountinfo_id: 'entity_accountinfo_id',
    entity_id: 'entity_id',
    bank_code: 'bank_code',
    branch_code: 'branch_code',
    account_id: 'account_id',
    is_default: 'is_default',
    created_at: 'created_at',
    updated_at: 'updated_at',
    updated_by: 'updated_by',
    created_by: 'created_by'
  };

  export type EntityAccountInfoScalarFieldEnum = (typeof EntityAccountInfoScalarFieldEnum)[keyof typeof EntityAccountInfoScalarFieldEnum]


  export const EntityBranchScalarFieldEnum: {
    branch_id: 'branch_id',
    branch_name: 'branch_name',
    kana: 'kana',
    is_jeadquarter: 'is_jeadquarter',
    image: 'image',
    prefecture: 'prefecture',
    post_code: 'post_code',
    city: 'city',
    district: 'district',
    address: 'address',
    address1: 'address1',
    nearest_station: 'nearest_station',
    socials: 'socials',
    gps: 'gps',
    contact_person: 'contact_person',
    contact_details: 'contact_details',
    created_at: 'created_at',
    updated_at: 'updated_at',
    created_by: 'created_by',
    updated_by: 'updated_by',
    entity_id: 'entity_id'
  };

  export type EntityBranchScalarFieldEnum = (typeof EntityBranchScalarFieldEnum)[keyof typeof EntityBranchScalarFieldEnum]


  export const EntityDetailScalarFieldEnum: {
    entity_detail_id: 'entity_detail_id',
    entity_id: 'entity_id',
    establishment: 'establishment',
    capital: 'capital',
    numberof_employees: 'numberof_employees',
    business_performance: 'business_performance',
    representative_telephone: 'representative_telephone',
    representative: 'representative',
    average_age: 'average_age',
    foreign_capitalratio: 'foreign_capitalratio',
    homepage: 'homepage',
    business_summary: 'business_summary',
    organizational_structure: 'organizational_structure',
    company_sales: 'company_sales',
    workplace_environment: 'workplace_environment',
    shareholder: 'shareholder',
    related_company: 'related_company',
    recruitment_personname: 'recruitment_personname',
    memo: 'memo',
    business_status: 'business_status',
    created_at: 'created_at',
    updated_at: 'updated_at',
    created_by: 'created_by',
    updated_by: 'updated_by'
  };

  export type EntityDetailScalarFieldEnum = (typeof EntityDetailScalarFieldEnum)[keyof typeof EntityDetailScalarFieldEnum]


  export const EntityScalarFieldEnum: {
    entity_id: 'entity_id',
    name: 'name',
    kana: 'kana',
    logo: 'logo',
    socials: 'socials',
    gps: 'gps',
    contact_person: 'contact_person',
    contact_details: 'contact_details',
    is_system: 'is_system',
    created_at: 'created_at',
    updated_at: 'updated_at',
    created_by: 'created_by',
    updated_by: 'updated_by'
  };

  export type EntityScalarFieldEnum = (typeof EntityScalarFieldEnum)[keyof typeof EntityScalarFieldEnum]


  export const FilesScalarFieldEnum: {
    file_id: 'file_id',
    file_name: 'file_name',
    target_id: 'target_id',
    file_path: 'file_path',
    file_type: 'file_type',
    fiel_source: 'fiel_source',
    created_at: 'created_at',
    created_by: 'created_by'
  };

  export type FilesScalarFieldEnum = (typeof FilesScalarFieldEnum)[keyof typeof FilesScalarFieldEnum]


  export const InquiryScalarFieldEnum: {
    inquire_id: 'inquire_id',
    parent_id: 'parent_id',
    fromuser_id: 'fromuser_id',
    entity_id: 'entity_id',
    assigned_user_id: 'assigned_user_id',
    subject: 'subject',
    body: 'body',
    inquiry_status: 'inquiry_status',
    is_read: 'is_read',
    is_answer: 'is_answer',
    created_at: 'created_at',
    updated_at: 'updated_at',
    created_by: 'created_by'
  };

  export type InquiryScalarFieldEnum = (typeof InquiryScalarFieldEnum)[keyof typeof InquiryScalarFieldEnum]


  export const JobCandidateScalarFieldEnum: {
    job_candidate_id: 'job_candidate_id',
    job_id: 'job_id',
    customer_id: 'customer_id',
    candidate_status: 'candidate_status',
    created_at: 'created_at',
    updated_at: 'updated_at',
    created_by: 'created_by',
    updated_by: 'updated_by'
  };

  export type JobCandidateScalarFieldEnum = (typeof JobCandidateScalarFieldEnum)[keyof typeof JobCandidateScalarFieldEnum]


  export const JobOtherLanguageScalarFieldEnum: {
    job_other_language_id: 'job_other_language_id',
    language_id: 'language_id',
    language_level: 'language_level',
    job_id: 'job_id'
  };

  export type JobOtherLanguageScalarFieldEnum = (typeof JobOtherLanguageScalarFieldEnum)[keyof typeof JobOtherLanguageScalarFieldEnum]


  export const JobReferenceListScalarFieldEnum: {
    job_reference_id: 'job_reference_id',
    job_id: 'job_id',
    reference_list_id: 'reference_list_id',
    reference_list_item_id: 'reference_list_item_id'
  };

  export type JobReferenceListScalarFieldEnum = (typeof JobReferenceListScalarFieldEnum)[keyof typeof JobReferenceListScalarFieldEnum]


  export const JobRequirementScalarFieldEnum: {
    job_require_id: 'job_require_id',
    job_id: 'job_id',
    require_id: 'require_id',
    require_detial: 'require_detial',
    created_at: 'created_at',
    updated_at: 'updated_at',
    created_by: 'created_by',
    updated_by: 'updated_by'
  };

  export type JobRequirementScalarFieldEnum = (typeof JobRequirementScalarFieldEnum)[keyof typeof JobRequirementScalarFieldEnum]


  export const JobScalarFieldEnum: {
    job_id: 'job_id',
    created_at: 'created_at',
    updated_at: 'updated_at',
    created_by: 'created_by',
    updated_by: 'updated_by',
    job_publish: 'job_publish',
    location_details: 'location_details',
    career_level: 'career_level',
    benefit_other: 'benefit_other',
    smoke: 'smoke',
    employment_status: 'employment_status',
    japanese_level: 'japanese_level',
    english_level: 'english_level',
    experienced_count: 'experienced_count',
    age_min: 'age_min',
    age_max: 'age_max',
    set_age_reason: 'set_age_reason',
    recruitment_type: 'recruitment_type',
    job_title: 'job_title',
    job_description: 'job_description',
    japanese_percentage: 'japanese_percentage',
    must_condition: 'must_condition',
    want_condition: 'want_condition',
    position_name: 'position_name',
    working_hour: 'working_hour',
    salary_type: 'salary_type',
    salary_min: 'salary_min',
    salary_max: 'salary_max',
    salary_detail: 'salary_detail',
    day_off: 'day_off',
    progress_detail: 'progress_detail',
    entity_branch_id: 'entity_branch_id',
    expire_date: 'expire_date'
  };

  export type JobScalarFieldEnum = (typeof JobScalarFieldEnum)[keyof typeof JobScalarFieldEnum]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const LoggerScalarFieldEnum: {
    log_id: 'log_id',
    action_user: 'action_user',
    user_id: 'user_id',
    new_value: 'new_value',
    old_value: 'old_value',
    created_at: 'created_at',
    updated_at: 'updated_at',
    created_by: 'created_by',
    updated_by: 'updated_by'
  };

  export type LoggerScalarFieldEnum = (typeof LoggerScalarFieldEnum)[keyof typeof LoggerScalarFieldEnum]


  export const NewsScalarFieldEnum: {
    news_id: 'news_id',
    page_id: 'page_id',
    title: 'title',
    brief: 'brief',
    image_id: 'image_id',
    content: 'content',
    is_top: 'is_top',
    is_publish: 'is_publish',
    created_at: 'created_at',
    updated_at: 'updated_at',
    created_by: 'created_by',
    update_by: 'update_by'
  };

  export type NewsScalarFieldEnum = (typeof NewsScalarFieldEnum)[keyof typeof NewsScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    notifiation_id: 'notifiation_id',
    user_id: 'user_id',
    link: 'link',
    message: 'message',
    is_new: 'is_new',
    is_badge: 'is_badge',
    created_at: 'created_at',
    created_by: 'created_by'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const PagesScalarFieldEnum: {
    page_id: 'page_id',
    page_name: 'page_name',
    page_type: 'page_type',
    created_at: 'created_at',
    created_by: 'created_by'
  };

  export type PagesScalarFieldEnum = (typeof PagesScalarFieldEnum)[keyof typeof PagesScalarFieldEnum]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const ReferenceListItemsScalarFieldEnum: {
    listitem_id: 'listitem_id',
    list_id: 'list_id',
    dictionary_id: 'dictionary_id',
    code: 'code',
    listitem_value: 'listitem_value',
    parent_id: 'parent_id',
    value: 'value',
    created_at: 'created_at',
    updated_at: 'updated_at',
    dictionaryDictionaries_id: 'dictionaryDictionaries_id'
  };

  export type ReferenceListItemsScalarFieldEnum = (typeof ReferenceListItemsScalarFieldEnum)[keyof typeof ReferenceListItemsScalarFieldEnum]


  export const ReferenceListScalarFieldEnum: {
    list_id: 'list_id',
    list_name: 'list_name',
    created_at: 'created_at'
  };

  export type ReferenceListScalarFieldEnum = (typeof ReferenceListScalarFieldEnum)[keyof typeof ReferenceListScalarFieldEnum]


  export const ScoutFavScalarFieldEnum: {
    scout_id: 'scout_id',
    entity_id: 'entity_id',
    branch_id: 'branch_id',
    user_id: 'user_id',
    job_id: 'job_id',
    note: 'note',
    created_at: 'created_at',
    created_by: 'created_by'
  };

  export type ScoutFavScalarFieldEnum = (typeof ScoutFavScalarFieldEnum)[keyof typeof ScoutFavScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const SystemLangaugeScalarFieldEnum: {
    language_id: 'language_id',
    language_code: 'language_code',
    is_default: 'is_default'
  };

  export type SystemLangaugeScalarFieldEnum = (typeof SystemLangaugeScalarFieldEnum)[keyof typeof SystemLangaugeScalarFieldEnum]


  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    user_id: 'user_id',
    email: 'email',
    mobile: 'mobile',
    name: 'name',
    password_hash: 'password_hash',
    role: 'role',
    company_id: 'company_id',
    customer_id: 'customer_id',
    attemptpass_count: 'attemptpass_count',
    reset_code: 'reset_code',
    is_emailverified: 'is_emailverified',
    is_mobileverified: 'is_mobileverified',
    user_status: 'user_status',
    created_at: 'created_at',
    updated_at: 'updated_at',
    deleted_at: 'deleted_at',
    favs: 'favs'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  /**
   * Deep Input Types
   */


  export type ActionRoleWhereInput = {
    AND?: Enumerable<ActionRoleWhereInput>
    OR?: Enumerable<ActionRoleWhereInput>
    NOT?: Enumerable<ActionRoleWhereInput>
    action_role_id?: StringFilter | string
    controller_path?: StringNullableFilter | string | null
    action_user?: EnumUserActionFilter | UserAction
    role?: EnumUserRoleFilter | UserRole
    is_can?: BoolFilter | boolean
    is_company?: BoolFilter | boolean
    parent_id?: StringNullableFilter | string | null
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    created_by?: StringNullableFilter | string | null
    updated_by?: StringNullableFilter | string | null
  }

  export type ActionRoleOrderByWithRelationInput = {
    action_role_id?: SortOrder
    controller_path?: SortOrder
    action_user?: SortOrder
    role?: SortOrder
    is_can?: SortOrder
    is_company?: SortOrder
    parent_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
  }

  export type ActionRoleWhereUniqueInput = {
    action_role_id?: string
  }

  export type ActionRoleOrderByWithAggregationInput = {
    action_role_id?: SortOrder
    controller_path?: SortOrder
    action_user?: SortOrder
    role?: SortOrder
    is_can?: SortOrder
    is_company?: SortOrder
    parent_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
    _count?: ActionRoleCountOrderByAggregateInput
    _max?: ActionRoleMaxOrderByAggregateInput
    _min?: ActionRoleMinOrderByAggregateInput
  }

  export type ActionRoleScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ActionRoleScalarWhereWithAggregatesInput>
    OR?: Enumerable<ActionRoleScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ActionRoleScalarWhereWithAggregatesInput>
    action_role_id?: StringWithAggregatesFilter | string
    controller_path?: StringNullableWithAggregatesFilter | string | null
    action_user?: EnumUserActionWithAggregatesFilter | UserAction
    role?: EnumUserRoleWithAggregatesFilter | UserRole
    is_can?: BoolWithAggregatesFilter | boolean
    is_company?: BoolWithAggregatesFilter | boolean
    parent_id?: StringNullableWithAggregatesFilter | string | null
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeWithAggregatesFilter | Date | string
    created_by?: StringNullableWithAggregatesFilter | string | null
    updated_by?: StringNullableWithAggregatesFilter | string | null
  }

  export type CustomerWhereInput = {
    AND?: Enumerable<CustomerWhereInput>
    OR?: Enumerable<CustomerWhereInput>
    NOT?: Enumerable<CustomerWhereInput>
    customer_id?: StringFilter | string
    first_name?: StringFilter | string
    last_name?: StringFilter | string
    first_name_kana?: StringFilter | string
    last_name_kana?: StringFilter | string
    gender?: EnumGenderNullableFilter | Gender | null
    birth_date?: DateTimeNullableFilter | Date | string | null
    spouse?: JsonNullableFilter
    family_size?: IntNullableFilter | number | null
    email?: StringNullableFilter | string | null
    mobile?: StringNullableFilter | string | null
    phone?: StringNullableFilter | string | null
    profile_image?: StringNullableFilter | string | null
    cv_file?: StringNullableFilter | string | null
    resume_file?: StringNullableFilter | string | null
    prefecture?: JsonNullableFilter
    post_code?: StringNullableFilter | string | null
    city?: StringNullableFilter | string | null
    district?: StringNullableFilter | string | null
    address?: StringNullableFilter | string | null
    address1?: StringNullableFilter | string | null
    nearest_station?: StringNullableFilter | string | null
    socials?: JsonNullableFilter
    country?: StringNullableFilter | string | null
    experienced_year?: IntNullableFilter | number | null
    from_data?: IntNullableFilter | number | null
    status_customer?: EnumCustomerStatusNullableFilter | CustomerStatus | null
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    created_by?: StringNullableFilter | string | null
    updated_by?: StringNullableFilter | string | null
    user?: XOR<UserRelationFilter, UserWhereInput> | null
    customer_visas?: CustomerVisaListRelationFilter
    customer_jobdetails?: CustomerJobDetailListRelationFilter
    customer_educations?: CustomerEducationListRelationFilter
    customer_languages?: CustomerLanguageListRelationFilter
    customer_qualifications?: CustomerQualificationListRelationFilter
    customer_workhistories?: CustomerWorkHistoryListRelationFilter
    job_candidates?: JobCandidateListRelationFilter
    customer_desired?: CustomerDesiredListRelationFilter
  }

  export type CustomerOrderByWithRelationInput = {
    customer_id?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    first_name_kana?: SortOrder
    last_name_kana?: SortOrder
    gender?: SortOrder
    birth_date?: SortOrder
    spouse?: SortOrder
    family_size?: SortOrder
    email?: SortOrder
    mobile?: SortOrder
    phone?: SortOrder
    profile_image?: SortOrder
    cv_file?: SortOrder
    resume_file?: SortOrder
    prefecture?: SortOrder
    post_code?: SortOrder
    city?: SortOrder
    district?: SortOrder
    address?: SortOrder
    address1?: SortOrder
    nearest_station?: SortOrder
    socials?: SortOrder
    country?: SortOrder
    experienced_year?: SortOrder
    from_data?: SortOrder
    status_customer?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
    user?: UserOrderByWithRelationInput
    customer_visas?: CustomerVisaOrderByRelationAggregateInput
    customer_jobdetails?: CustomerJobDetailOrderByRelationAggregateInput
    customer_educations?: CustomerEducationOrderByRelationAggregateInput
    customer_languages?: CustomerLanguageOrderByRelationAggregateInput
    customer_qualifications?: CustomerQualificationOrderByRelationAggregateInput
    customer_workhistories?: CustomerWorkHistoryOrderByRelationAggregateInput
    job_candidates?: JobCandidateOrderByRelationAggregateInput
    customer_desired?: CustomerDesiredOrderByRelationAggregateInput
  }

  export type CustomerWhereUniqueInput = {
    customer_id?: string
  }

  export type CustomerOrderByWithAggregationInput = {
    customer_id?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    first_name_kana?: SortOrder
    last_name_kana?: SortOrder
    gender?: SortOrder
    birth_date?: SortOrder
    spouse?: SortOrder
    family_size?: SortOrder
    email?: SortOrder
    mobile?: SortOrder
    phone?: SortOrder
    profile_image?: SortOrder
    cv_file?: SortOrder
    resume_file?: SortOrder
    prefecture?: SortOrder
    post_code?: SortOrder
    city?: SortOrder
    district?: SortOrder
    address?: SortOrder
    address1?: SortOrder
    nearest_station?: SortOrder
    socials?: SortOrder
    country?: SortOrder
    experienced_year?: SortOrder
    from_data?: SortOrder
    status_customer?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
    _count?: CustomerCountOrderByAggregateInput
    _avg?: CustomerAvgOrderByAggregateInput
    _max?: CustomerMaxOrderByAggregateInput
    _min?: CustomerMinOrderByAggregateInput
    _sum?: CustomerSumOrderByAggregateInput
  }

  export type CustomerScalarWhereWithAggregatesInput = {
    AND?: Enumerable<CustomerScalarWhereWithAggregatesInput>
    OR?: Enumerable<CustomerScalarWhereWithAggregatesInput>
    NOT?: Enumerable<CustomerScalarWhereWithAggregatesInput>
    customer_id?: StringWithAggregatesFilter | string
    first_name?: StringWithAggregatesFilter | string
    last_name?: StringWithAggregatesFilter | string
    first_name_kana?: StringWithAggregatesFilter | string
    last_name_kana?: StringWithAggregatesFilter | string
    gender?: EnumGenderNullableWithAggregatesFilter | Gender | null
    birth_date?: DateTimeNullableWithAggregatesFilter | Date | string | null
    spouse?: JsonNullableWithAggregatesFilter
    family_size?: IntNullableWithAggregatesFilter | number | null
    email?: StringNullableWithAggregatesFilter | string | null
    mobile?: StringNullableWithAggregatesFilter | string | null
    phone?: StringNullableWithAggregatesFilter | string | null
    profile_image?: StringNullableWithAggregatesFilter | string | null
    cv_file?: StringNullableWithAggregatesFilter | string | null
    resume_file?: StringNullableWithAggregatesFilter | string | null
    prefecture?: JsonNullableWithAggregatesFilter
    post_code?: StringNullableWithAggregatesFilter | string | null
    city?: StringNullableWithAggregatesFilter | string | null
    district?: StringNullableWithAggregatesFilter | string | null
    address?: StringNullableWithAggregatesFilter | string | null
    address1?: StringNullableWithAggregatesFilter | string | null
    nearest_station?: StringNullableWithAggregatesFilter | string | null
    socials?: JsonNullableWithAggregatesFilter
    country?: StringNullableWithAggregatesFilter | string | null
    experienced_year?: IntNullableWithAggregatesFilter | number | null
    from_data?: IntNullableWithAggregatesFilter | number | null
    status_customer?: EnumCustomerStatusNullableWithAggregatesFilter | CustomerStatus | null
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeWithAggregatesFilter | Date | string
    created_by?: StringNullableWithAggregatesFilter | string | null
    updated_by?: StringNullableWithAggregatesFilter | string | null
  }

  export type CustomerDesiredWhereInput = {
    AND?: Enumerable<CustomerDesiredWhereInput>
    OR?: Enumerable<CustomerDesiredWhereInput>
    NOT?: Enumerable<CustomerDesiredWhereInput>
    desired_id?: StringFilter | string
    customer?: XOR<CustomerRelationFilter, CustomerWhereInput> | null
    customer_id?: StringNullableFilter | string | null
    occupation?: JsonNullableListFilter
    industry?: JsonNullableListFilter
    location?: JsonNullableListFilter
    career_level?: JsonNullableListFilter
    contract_type?: JsonNullableListFilter
    desired_company?: JsonNullableListFilter
    time_to?: StringFilter | string
    annual_income?: IntFilter | number
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    created_by?: StringNullableFilter | string | null
    updated_by?: StringNullableFilter | string | null
  }

  export type CustomerDesiredOrderByWithRelationInput = {
    desired_id?: SortOrder
    customer?: CustomerOrderByWithRelationInput
    customer_id?: SortOrder
    occupation?: SortOrder
    industry?: SortOrder
    location?: SortOrder
    career_level?: SortOrder
    contract_type?: SortOrder
    desired_company?: SortOrder
    time_to?: SortOrder
    annual_income?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
  }

  export type CustomerDesiredWhereUniqueInput = {
    desired_id?: string
  }

  export type CustomerDesiredOrderByWithAggregationInput = {
    desired_id?: SortOrder
    customer_id?: SortOrder
    occupation?: SortOrder
    industry?: SortOrder
    location?: SortOrder
    career_level?: SortOrder
    contract_type?: SortOrder
    desired_company?: SortOrder
    time_to?: SortOrder
    annual_income?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
    _count?: CustomerDesiredCountOrderByAggregateInput
    _avg?: CustomerDesiredAvgOrderByAggregateInput
    _max?: CustomerDesiredMaxOrderByAggregateInput
    _min?: CustomerDesiredMinOrderByAggregateInput
    _sum?: CustomerDesiredSumOrderByAggregateInput
  }

  export type CustomerDesiredScalarWhereWithAggregatesInput = {
    AND?: Enumerable<CustomerDesiredScalarWhereWithAggregatesInput>
    OR?: Enumerable<CustomerDesiredScalarWhereWithAggregatesInput>
    NOT?: Enumerable<CustomerDesiredScalarWhereWithAggregatesInput>
    desired_id?: StringWithAggregatesFilter | string
    customer_id?: StringNullableWithAggregatesFilter | string | null
    occupation?: JsonNullableListFilter
    industry?: JsonNullableListFilter
    location?: JsonNullableListFilter
    career_level?: JsonNullableListFilter
    contract_type?: JsonNullableListFilter
    desired_company?: JsonNullableListFilter
    time_to?: StringWithAggregatesFilter | string
    annual_income?: IntWithAggregatesFilter | number
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeWithAggregatesFilter | Date | string
    created_by?: StringNullableWithAggregatesFilter | string | null
    updated_by?: StringNullableWithAggregatesFilter | string | null
  }

  export type CustomerEducationWhereInput = {
    AND?: Enumerable<CustomerEducationWhereInput>
    OR?: Enumerable<CustomerEducationWhereInput>
    NOT?: Enumerable<CustomerEducationWhereInput>
    education_id?: StringFilter | string
    customer?: XOR<CustomerRelationFilter, CustomerWhereInput> | null
    customer_id?: StringNullableFilter | string | null
    country?: StringNullableFilter | string | null
    degree?: JsonNullableFilter
    entrollment_date?: DateTimeNullableFilter | Date | string | null
    graduate_date?: DateTimeNullableFilter | Date | string | null
    is_current?: BoolNullableFilter | boolean | null
    school_id?: IntNullableFilter | number | null
    school?: JsonNullableFilter
    faculty?: StringNullableFilter | string | null
    department?: StringNullableFilter | string | null
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    created_by?: StringNullableFilter | string | null
    updated_by?: StringNullableFilter | string | null
  }

  export type CustomerEducationOrderByWithRelationInput = {
    education_id?: SortOrder
    customer?: CustomerOrderByWithRelationInput
    customer_id?: SortOrder
    country?: SortOrder
    degree?: SortOrder
    entrollment_date?: SortOrder
    graduate_date?: SortOrder
    is_current?: SortOrder
    school_id?: SortOrder
    school?: SortOrder
    faculty?: SortOrder
    department?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
  }

  export type CustomerEducationWhereUniqueInput = {
    education_id?: string
  }

  export type CustomerEducationOrderByWithAggregationInput = {
    education_id?: SortOrder
    customer_id?: SortOrder
    country?: SortOrder
    degree?: SortOrder
    entrollment_date?: SortOrder
    graduate_date?: SortOrder
    is_current?: SortOrder
    school_id?: SortOrder
    school?: SortOrder
    faculty?: SortOrder
    department?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
    _count?: CustomerEducationCountOrderByAggregateInput
    _avg?: CustomerEducationAvgOrderByAggregateInput
    _max?: CustomerEducationMaxOrderByAggregateInput
    _min?: CustomerEducationMinOrderByAggregateInput
    _sum?: CustomerEducationSumOrderByAggregateInput
  }

  export type CustomerEducationScalarWhereWithAggregatesInput = {
    AND?: Enumerable<CustomerEducationScalarWhereWithAggregatesInput>
    OR?: Enumerable<CustomerEducationScalarWhereWithAggregatesInput>
    NOT?: Enumerable<CustomerEducationScalarWhereWithAggregatesInput>
    education_id?: StringWithAggregatesFilter | string
    customer_id?: StringNullableWithAggregatesFilter | string | null
    country?: StringNullableWithAggregatesFilter | string | null
    degree?: JsonNullableWithAggregatesFilter
    entrollment_date?: DateTimeNullableWithAggregatesFilter | Date | string | null
    graduate_date?: DateTimeNullableWithAggregatesFilter | Date | string | null
    is_current?: BoolNullableWithAggregatesFilter | boolean | null
    school_id?: IntNullableWithAggregatesFilter | number | null
    school?: JsonNullableWithAggregatesFilter
    faculty?: StringNullableWithAggregatesFilter | string | null
    department?: StringNullableWithAggregatesFilter | string | null
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeWithAggregatesFilter | Date | string
    created_by?: StringNullableWithAggregatesFilter | string | null
    updated_by?: StringNullableWithAggregatesFilter | string | null
  }

  export type CustomerExperienceWhereInput = {
    AND?: Enumerable<CustomerExperienceWhereInput>
    OR?: Enumerable<CustomerExperienceWhereInput>
    NOT?: Enumerable<CustomerExperienceWhereInput>
    experience_id?: StringFilter | string
    jobdetail_id?: StringFilter | string
    jobdetails?: XOR<CustomerJobDetailRelationFilter, CustomerJobDetailWhereInput>
    skill_id?: IntFilter | number
    listitems?: XOR<ReferenceListItemsRelationFilter, ReferenceListItemsWhereInput>
    over_year?: IntNullableFilter | number | null
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeNullableFilter | Date | string | null
    created_by?: StringNullableFilter | string | null
    updated_by?: StringNullableFilter | string | null
  }

  export type CustomerExperienceOrderByWithRelationInput = {
    experience_id?: SortOrder
    jobdetail_id?: SortOrder
    jobdetails?: CustomerJobDetailOrderByWithRelationInput
    skill_id?: SortOrder
    listitems?: ReferenceListItemsOrderByWithRelationInput
    over_year?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
  }

  export type CustomerExperienceWhereUniqueInput = {
    experience_id?: string
  }

  export type CustomerExperienceOrderByWithAggregationInput = {
    experience_id?: SortOrder
    jobdetail_id?: SortOrder
    skill_id?: SortOrder
    over_year?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
    _count?: CustomerExperienceCountOrderByAggregateInput
    _avg?: CustomerExperienceAvgOrderByAggregateInput
    _max?: CustomerExperienceMaxOrderByAggregateInput
    _min?: CustomerExperienceMinOrderByAggregateInput
    _sum?: CustomerExperienceSumOrderByAggregateInput
  }

  export type CustomerExperienceScalarWhereWithAggregatesInput = {
    AND?: Enumerable<CustomerExperienceScalarWhereWithAggregatesInput>
    OR?: Enumerable<CustomerExperienceScalarWhereWithAggregatesInput>
    NOT?: Enumerable<CustomerExperienceScalarWhereWithAggregatesInput>
    experience_id?: StringWithAggregatesFilter | string
    jobdetail_id?: StringWithAggregatesFilter | string
    skill_id?: IntWithAggregatesFilter | number
    over_year?: IntNullableWithAggregatesFilter | number | null
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
    created_by?: StringNullableWithAggregatesFilter | string | null
    updated_by?: StringNullableWithAggregatesFilter | string | null
  }

  export type CustomerJobDetailWhereInput = {
    AND?: Enumerable<CustomerJobDetailWhereInput>
    OR?: Enumerable<CustomerJobDetailWhereInput>
    NOT?: Enumerable<CustomerJobDetailWhereInput>
    jobdetail_id?: StringFilter | string
    customer_id?: StringNullableFilter | string | null
    customer?: XOR<CustomerRelationFilter, CustomerWhereInput> | null
    customer_experiences?: CustomerExperienceListRelationFilter
    experienced_company?: IntFilter | number
    annual_income?: IntNullableFilter | number | null
    has_management_exp?: BoolFilter | boolean
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    created_by?: StringNullableFilter | string | null
    updated_by?: StringNullableFilter | string | null
  }

  export type CustomerJobDetailOrderByWithRelationInput = {
    jobdetail_id?: SortOrder
    customer_id?: SortOrder
    customer?: CustomerOrderByWithRelationInput
    customer_experiences?: CustomerExperienceOrderByRelationAggregateInput
    experienced_company?: SortOrder
    annual_income?: SortOrder
    has_management_exp?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
  }

  export type CustomerJobDetailWhereUniqueInput = {
    jobdetail_id?: string
  }

  export type CustomerJobDetailOrderByWithAggregationInput = {
    jobdetail_id?: SortOrder
    customer_id?: SortOrder
    experienced_company?: SortOrder
    annual_income?: SortOrder
    has_management_exp?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
    _count?: CustomerJobDetailCountOrderByAggregateInput
    _avg?: CustomerJobDetailAvgOrderByAggregateInput
    _max?: CustomerJobDetailMaxOrderByAggregateInput
    _min?: CustomerJobDetailMinOrderByAggregateInput
    _sum?: CustomerJobDetailSumOrderByAggregateInput
  }

  export type CustomerJobDetailScalarWhereWithAggregatesInput = {
    AND?: Enumerable<CustomerJobDetailScalarWhereWithAggregatesInput>
    OR?: Enumerable<CustomerJobDetailScalarWhereWithAggregatesInput>
    NOT?: Enumerable<CustomerJobDetailScalarWhereWithAggregatesInput>
    jobdetail_id?: StringWithAggregatesFilter | string
    customer_id?: StringNullableWithAggregatesFilter | string | null
    experienced_company?: IntWithAggregatesFilter | number
    annual_income?: IntNullableWithAggregatesFilter | number | null
    has_management_exp?: BoolWithAggregatesFilter | boolean
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeWithAggregatesFilter | Date | string
    created_by?: StringNullableWithAggregatesFilter | string | null
    updated_by?: StringNullableWithAggregatesFilter | string | null
  }

  export type CustomerLanguageWhereInput = {
    AND?: Enumerable<CustomerLanguageWhereInput>
    OR?: Enumerable<CustomerLanguageWhereInput>
    NOT?: Enumerable<CustomerLanguageWhereInput>
    language_id?: StringFilter | string
    customer_id?: StringFilter | string
    customer?: XOR<CustomerRelationFilter, CustomerWhereInput>
    level?: EnumLanguageLevelNullableFilter | LanguageLevel | null
    language?: IntNullableFilter | number | null
    is_motherlanguage?: BoolFilter | boolean
    certificate?: JsonNullableFilter
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeNullableFilter | Date | string | null
    created_by?: StringNullableFilter | string | null
    updated_b?: StringNullableFilter | string | null
  }

  export type CustomerLanguageOrderByWithRelationInput = {
    language_id?: SortOrder
    customer_id?: SortOrder
    customer?: CustomerOrderByWithRelationInput
    level?: SortOrder
    language?: SortOrder
    is_motherlanguage?: SortOrder
    certificate?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    created_by?: SortOrder
    updated_b?: SortOrder
  }

  export type CustomerLanguageWhereUniqueInput = {
    language_id?: string
  }

  export type CustomerLanguageOrderByWithAggregationInput = {
    language_id?: SortOrder
    customer_id?: SortOrder
    level?: SortOrder
    language?: SortOrder
    is_motherlanguage?: SortOrder
    certificate?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    created_by?: SortOrder
    updated_b?: SortOrder
    _count?: CustomerLanguageCountOrderByAggregateInput
    _avg?: CustomerLanguageAvgOrderByAggregateInput
    _max?: CustomerLanguageMaxOrderByAggregateInput
    _min?: CustomerLanguageMinOrderByAggregateInput
    _sum?: CustomerLanguageSumOrderByAggregateInput
  }

  export type CustomerLanguageScalarWhereWithAggregatesInput = {
    AND?: Enumerable<CustomerLanguageScalarWhereWithAggregatesInput>
    OR?: Enumerable<CustomerLanguageScalarWhereWithAggregatesInput>
    NOT?: Enumerable<CustomerLanguageScalarWhereWithAggregatesInput>
    language_id?: StringWithAggregatesFilter | string
    customer_id?: StringWithAggregatesFilter | string
    level?: EnumLanguageLevelNullableWithAggregatesFilter | LanguageLevel | null
    language?: IntNullableWithAggregatesFilter | number | null
    is_motherlanguage?: BoolWithAggregatesFilter | boolean
    certificate?: JsonNullableWithAggregatesFilter
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
    created_by?: StringNullableWithAggregatesFilter | string | null
    updated_b?: StringNullableWithAggregatesFilter | string | null
  }

  export type CustomerQualificationWhereInput = {
    AND?: Enumerable<CustomerQualificationWhereInput>
    OR?: Enumerable<CustomerQualificationWhereInput>
    NOT?: Enumerable<CustomerQualificationWhereInput>
    qualification_id?: StringFilter | string
    customer_id?: StringFilter | string
    customers?: XOR<CustomerRelationFilter, CustomerWhereInput>
    qualification?: JsonNullableFilter
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    created_by?: StringNullableFilter | string | null
    updated_by?: StringNullableFilter | string | null
  }

  export type CustomerQualificationOrderByWithRelationInput = {
    qualification_id?: SortOrder
    customer_id?: SortOrder
    customers?: CustomerOrderByWithRelationInput
    qualification?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
  }

  export type CustomerQualificationWhereUniqueInput = {
    qualification_id?: string
  }

  export type CustomerQualificationOrderByWithAggregationInput = {
    qualification_id?: SortOrder
    customer_id?: SortOrder
    qualification?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
    _count?: CustomerQualificationCountOrderByAggregateInput
    _max?: CustomerQualificationMaxOrderByAggregateInput
    _min?: CustomerQualificationMinOrderByAggregateInput
  }

  export type CustomerQualificationScalarWhereWithAggregatesInput = {
    AND?: Enumerable<CustomerQualificationScalarWhereWithAggregatesInput>
    OR?: Enumerable<CustomerQualificationScalarWhereWithAggregatesInput>
    NOT?: Enumerable<CustomerQualificationScalarWhereWithAggregatesInput>
    qualification_id?: StringWithAggregatesFilter | string
    customer_id?: StringWithAggregatesFilter | string
    qualification?: JsonNullableWithAggregatesFilter
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeWithAggregatesFilter | Date | string
    created_by?: StringNullableWithAggregatesFilter | string | null
    updated_by?: StringNullableWithAggregatesFilter | string | null
  }

  export type CustomerVisaWhereInput = {
    AND?: Enumerable<CustomerVisaWhereInput>
    OR?: Enumerable<CustomerVisaWhereInput>
    NOT?: Enumerable<CustomerVisaWhereInput>
    visa_id?: StringFilter | string
    customer_id?: StringFilter | string
    customer?: XOR<CustomerRelationFilter, CustomerWhereInput>
    status_visa?: EnumStatusVisaNullableFilter | StatusVisa | null
    date_expire?: DateTimeNullableFilter | Date | string | null
    country_citizenship?: StringNullableFilter | string | null
    back_visafile?: StringNullableFilter | string | null
    front_visafile?: StringNullableFilter | string | null
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    created_by?: StringNullableFilter | string | null
    updated_by?: StringNullableFilter | string | null
  }

  export type CustomerVisaOrderByWithRelationInput = {
    visa_id?: SortOrder
    customer_id?: SortOrder
    customer?: CustomerOrderByWithRelationInput
    status_visa?: SortOrder
    date_expire?: SortOrder
    country_citizenship?: SortOrder
    back_visafile?: SortOrder
    front_visafile?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
  }

  export type CustomerVisaWhereUniqueInput = {
    visa_id?: string
  }

  export type CustomerVisaOrderByWithAggregationInput = {
    visa_id?: SortOrder
    customer_id?: SortOrder
    status_visa?: SortOrder
    date_expire?: SortOrder
    country_citizenship?: SortOrder
    back_visafile?: SortOrder
    front_visafile?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
    _count?: CustomerVisaCountOrderByAggregateInput
    _max?: CustomerVisaMaxOrderByAggregateInput
    _min?: CustomerVisaMinOrderByAggregateInput
  }

  export type CustomerVisaScalarWhereWithAggregatesInput = {
    AND?: Enumerable<CustomerVisaScalarWhereWithAggregatesInput>
    OR?: Enumerable<CustomerVisaScalarWhereWithAggregatesInput>
    NOT?: Enumerable<CustomerVisaScalarWhereWithAggregatesInput>
    visa_id?: StringWithAggregatesFilter | string
    customer_id?: StringWithAggregatesFilter | string
    status_visa?: EnumStatusVisaNullableWithAggregatesFilter | StatusVisa | null
    date_expire?: DateTimeNullableWithAggregatesFilter | Date | string | null
    country_citizenship?: StringNullableWithAggregatesFilter | string | null
    back_visafile?: StringNullableWithAggregatesFilter | string | null
    front_visafile?: StringNullableWithAggregatesFilter | string | null
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeWithAggregatesFilter | Date | string
    created_by?: StringNullableWithAggregatesFilter | string | null
    updated_by?: StringNullableWithAggregatesFilter | string | null
  }

  export type CustomerWorkHistoryWhereInput = {
    AND?: Enumerable<CustomerWorkHistoryWhereInput>
    OR?: Enumerable<CustomerWorkHistoryWhereInput>
    NOT?: Enumerable<CustomerWorkHistoryWhereInput>
    workhistory_id?: StringFilter | string
    customer_id?: StringFilter | string
    customer?: XOR<CustomerRelationFilter, CustomerWhereInput>
    company_id?: StringNullableFilter | string | null
    company_info?: JsonNullableFilter
    occupation?: JsonNullableFilter
    industry?: JsonNullableFilter
    position?: EnumJobPositionNullableFilter | JobPosition | null
    enter_date?: DateTimeNullableFilter | Date | string | null
    leave_date?: DateTimeNullableFilter | Date | string | null
    working_month?: IntNullableFilter | number | null
    is_current?: BoolNullableFilter | boolean | null
    duties?: StringNullableFilter | string | null
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    created_by?: StringNullableFilter | string | null
    updated_by?: StringNullableFilter | string | null
  }

  export type CustomerWorkHistoryOrderByWithRelationInput = {
    workhistory_id?: SortOrder
    customer_id?: SortOrder
    customer?: CustomerOrderByWithRelationInput
    company_id?: SortOrder
    company_info?: SortOrder
    occupation?: SortOrder
    industry?: SortOrder
    position?: SortOrder
    enter_date?: SortOrder
    leave_date?: SortOrder
    working_month?: SortOrder
    is_current?: SortOrder
    duties?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
  }

  export type CustomerWorkHistoryWhereUniqueInput = {
    workhistory_id?: string
  }

  export type CustomerWorkHistoryOrderByWithAggregationInput = {
    workhistory_id?: SortOrder
    customer_id?: SortOrder
    company_id?: SortOrder
    company_info?: SortOrder
    occupation?: SortOrder
    industry?: SortOrder
    position?: SortOrder
    enter_date?: SortOrder
    leave_date?: SortOrder
    working_month?: SortOrder
    is_current?: SortOrder
    duties?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
    _count?: CustomerWorkHistoryCountOrderByAggregateInput
    _avg?: CustomerWorkHistoryAvgOrderByAggregateInput
    _max?: CustomerWorkHistoryMaxOrderByAggregateInput
    _min?: CustomerWorkHistoryMinOrderByAggregateInput
    _sum?: CustomerWorkHistorySumOrderByAggregateInput
  }

  export type CustomerWorkHistoryScalarWhereWithAggregatesInput = {
    AND?: Enumerable<CustomerWorkHistoryScalarWhereWithAggregatesInput>
    OR?: Enumerable<CustomerWorkHistoryScalarWhereWithAggregatesInput>
    NOT?: Enumerable<CustomerWorkHistoryScalarWhereWithAggregatesInput>
    workhistory_id?: StringWithAggregatesFilter | string
    customer_id?: StringWithAggregatesFilter | string
    company_id?: StringNullableWithAggregatesFilter | string | null
    company_info?: JsonNullableWithAggregatesFilter
    occupation?: JsonNullableWithAggregatesFilter
    industry?: JsonNullableWithAggregatesFilter
    position?: EnumJobPositionNullableWithAggregatesFilter | JobPosition | null
    enter_date?: DateTimeNullableWithAggregatesFilter | Date | string | null
    leave_date?: DateTimeNullableWithAggregatesFilter | Date | string | null
    working_month?: IntNullableWithAggregatesFilter | number | null
    is_current?: BoolNullableWithAggregatesFilter | boolean | null
    duties?: StringNullableWithAggregatesFilter | string | null
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeWithAggregatesFilter | Date | string
    created_by?: StringNullableWithAggregatesFilter | string | null
    updated_by?: StringNullableWithAggregatesFilter | string | null
  }

  export type DictionaryWhereInput = {
    AND?: Enumerable<DictionaryWhereInput>
    OR?: Enumerable<DictionaryWhereInput>
    NOT?: Enumerable<DictionaryWhereInput>
    dictionaries_id?: StringFilter | string
    dictionary_id?: IntFilter | number
    language_code?: StringFilter | string
    dic_value?: StringFilter | string
    created_at?: DateTimeFilter | Date | string
    reference_listitems?: ReferenceListItemsListRelationFilter
  }

  export type DictionaryOrderByWithRelationInput = {
    dictionaries_id?: SortOrder
    dictionary_id?: SortOrder
    language_code?: SortOrder
    dic_value?: SortOrder
    created_at?: SortOrder
    reference_listitems?: ReferenceListItemsOrderByRelationAggregateInput
  }

  export type DictionaryWhereUniqueInput = {
    dictionaries_id?: string
    dictionary_id_language_code?: DictionaryDictionary_idLanguage_codeCompoundUniqueInput
  }

  export type DictionaryOrderByWithAggregationInput = {
    dictionaries_id?: SortOrder
    dictionary_id?: SortOrder
    language_code?: SortOrder
    dic_value?: SortOrder
    created_at?: SortOrder
    _count?: DictionaryCountOrderByAggregateInput
    _avg?: DictionaryAvgOrderByAggregateInput
    _max?: DictionaryMaxOrderByAggregateInput
    _min?: DictionaryMinOrderByAggregateInput
    _sum?: DictionarySumOrderByAggregateInput
  }

  export type DictionaryScalarWhereWithAggregatesInput = {
    AND?: Enumerable<DictionaryScalarWhereWithAggregatesInput>
    OR?: Enumerable<DictionaryScalarWhereWithAggregatesInput>
    NOT?: Enumerable<DictionaryScalarWhereWithAggregatesInput>
    dictionaries_id?: StringWithAggregatesFilter | string
    dictionary_id?: IntWithAggregatesFilter | number
    language_code?: StringWithAggregatesFilter | string
    dic_value?: StringWithAggregatesFilter | string
    created_at?: DateTimeWithAggregatesFilter | Date | string
  }

  export type EntityWhereInput = {
    AND?: Enumerable<EntityWhereInput>
    OR?: Enumerable<EntityWhereInput>
    NOT?: Enumerable<EntityWhereInput>
    entity_id?: IntFilter | number
    name?: StringFilter | string
    kana?: StringNullableFilter | string | null
    logo?: StringNullableFilter | string | null
    socials?: JsonNullableFilter
    gps?: JsonNullableFilter
    contact_person?: JsonNullableFilter
    contact_details?: JsonNullableFilter
    is_system?: BoolFilter | boolean
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    created_by?: StringNullableFilter | string | null
    updated_by?: StringNullableFilter | string | null
    entity_details?: EntityDetailListRelationFilter
    entity_branches?: EntityBranchListRelationFilter
    entity_accountinfos?: EntityAccountInfoListRelationFilter
    inquiries?: InquiryListRelationFilter
  }

  export type EntityOrderByWithRelationInput = {
    entity_id?: SortOrder
    name?: SortOrder
    kana?: SortOrder
    logo?: SortOrder
    socials?: SortOrder
    gps?: SortOrder
    contact_person?: SortOrder
    contact_details?: SortOrder
    is_system?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
    entity_details?: EntityDetailOrderByRelationAggregateInput
    entity_branches?: EntityBranchOrderByRelationAggregateInput
    entity_accountinfos?: EntityAccountInfoOrderByRelationAggregateInput
    inquiries?: InquiryOrderByRelationAggregateInput
  }

  export type EntityWhereUniqueInput = {
    entity_id?: number
  }

  export type EntityOrderByWithAggregationInput = {
    entity_id?: SortOrder
    name?: SortOrder
    kana?: SortOrder
    logo?: SortOrder
    socials?: SortOrder
    gps?: SortOrder
    contact_person?: SortOrder
    contact_details?: SortOrder
    is_system?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
    _count?: EntityCountOrderByAggregateInput
    _avg?: EntityAvgOrderByAggregateInput
    _max?: EntityMaxOrderByAggregateInput
    _min?: EntityMinOrderByAggregateInput
    _sum?: EntitySumOrderByAggregateInput
  }

  export type EntityScalarWhereWithAggregatesInput = {
    AND?: Enumerable<EntityScalarWhereWithAggregatesInput>
    OR?: Enumerable<EntityScalarWhereWithAggregatesInput>
    NOT?: Enumerable<EntityScalarWhereWithAggregatesInput>
    entity_id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    kana?: StringNullableWithAggregatesFilter | string | null
    logo?: StringNullableWithAggregatesFilter | string | null
    socials?: JsonNullableWithAggregatesFilter
    gps?: JsonNullableWithAggregatesFilter
    contact_person?: JsonNullableWithAggregatesFilter
    contact_details?: JsonNullableWithAggregatesFilter
    is_system?: BoolWithAggregatesFilter | boolean
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeWithAggregatesFilter | Date | string
    created_by?: StringNullableWithAggregatesFilter | string | null
    updated_by?: StringNullableWithAggregatesFilter | string | null
  }

  export type EntityAccountInfoWhereInput = {
    AND?: Enumerable<EntityAccountInfoWhereInput>
    OR?: Enumerable<EntityAccountInfoWhereInput>
    NOT?: Enumerable<EntityAccountInfoWhereInput>
    entity_accountinfo_id?: StringFilter | string
    entity_id?: IntNullableFilter | number | null
    entity?: XOR<EntityRelationFilter, EntityWhereInput> | null
    bank_code?: StringNullableFilter | string | null
    branch_code?: StringNullableFilter | string | null
    account_id?: StringNullableFilter | string | null
    is_default?: BoolNullableFilter | boolean | null
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    updated_by?: StringNullableFilter | string | null
    created_by?: StringNullableFilter | string | null
  }

  export type EntityAccountInfoOrderByWithRelationInput = {
    entity_accountinfo_id?: SortOrder
    entity_id?: SortOrder
    entity?: EntityOrderByWithRelationInput
    bank_code?: SortOrder
    branch_code?: SortOrder
    account_id?: SortOrder
    is_default?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    updated_by?: SortOrder
    created_by?: SortOrder
  }

  export type EntityAccountInfoWhereUniqueInput = {
    entity_accountinfo_id?: string
  }

  export type EntityAccountInfoOrderByWithAggregationInput = {
    entity_accountinfo_id?: SortOrder
    entity_id?: SortOrder
    bank_code?: SortOrder
    branch_code?: SortOrder
    account_id?: SortOrder
    is_default?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    updated_by?: SortOrder
    created_by?: SortOrder
    _count?: EntityAccountInfoCountOrderByAggregateInput
    _avg?: EntityAccountInfoAvgOrderByAggregateInput
    _max?: EntityAccountInfoMaxOrderByAggregateInput
    _min?: EntityAccountInfoMinOrderByAggregateInput
    _sum?: EntityAccountInfoSumOrderByAggregateInput
  }

  export type EntityAccountInfoScalarWhereWithAggregatesInput = {
    AND?: Enumerable<EntityAccountInfoScalarWhereWithAggregatesInput>
    OR?: Enumerable<EntityAccountInfoScalarWhereWithAggregatesInput>
    NOT?: Enumerable<EntityAccountInfoScalarWhereWithAggregatesInput>
    entity_accountinfo_id?: StringWithAggregatesFilter | string
    entity_id?: IntNullableWithAggregatesFilter | number | null
    bank_code?: StringNullableWithAggregatesFilter | string | null
    branch_code?: StringNullableWithAggregatesFilter | string | null
    account_id?: StringNullableWithAggregatesFilter | string | null
    is_default?: BoolNullableWithAggregatesFilter | boolean | null
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeWithAggregatesFilter | Date | string
    updated_by?: StringNullableWithAggregatesFilter | string | null
    created_by?: StringNullableWithAggregatesFilter | string | null
  }

  export type EntityBranchWhereInput = {
    AND?: Enumerable<EntityBranchWhereInput>
    OR?: Enumerable<EntityBranchWhereInput>
    NOT?: Enumerable<EntityBranchWhereInput>
    branch_id?: IntFilter | number
    branch_name?: StringNullableFilter | string | null
    kana?: StringNullableFilter | string | null
    is_jeadquarter?: BoolFilter | boolean
    image?: StringNullableFilter | string | null
    prefecture?: JsonNullableFilter
    post_code?: StringNullableFilter | string | null
    city?: StringNullableFilter | string | null
    district?: StringNullableFilter | string | null
    address?: StringNullableFilter | string | null
    address1?: StringNullableFilter | string | null
    nearest_station?: StringNullableFilter | string | null
    socials?: JsonNullableFilter
    gps?: JsonNullableFilter
    contact_person?: JsonNullableFilter
    contact_details?: JsonNullableFilter
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    created_by?: StringNullableFilter | string | null
    updated_by?: StringNullableFilter | string | null
    entity?: XOR<EntityRelationFilter, EntityWhereInput>
    entity_id?: IntFilter | number
    jobs?: JobListRelationFilter
  }

  export type EntityBranchOrderByWithRelationInput = {
    branch_id?: SortOrder
    branch_name?: SortOrder
    kana?: SortOrder
    is_jeadquarter?: SortOrder
    image?: SortOrder
    prefecture?: SortOrder
    post_code?: SortOrder
    city?: SortOrder
    district?: SortOrder
    address?: SortOrder
    address1?: SortOrder
    nearest_station?: SortOrder
    socials?: SortOrder
    gps?: SortOrder
    contact_person?: SortOrder
    contact_details?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
    entity?: EntityOrderByWithRelationInput
    entity_id?: SortOrder
    jobs?: JobOrderByRelationAggregateInput
  }

  export type EntityBranchWhereUniqueInput = {
    branch_id?: number
  }

  export type EntityBranchOrderByWithAggregationInput = {
    branch_id?: SortOrder
    branch_name?: SortOrder
    kana?: SortOrder
    is_jeadquarter?: SortOrder
    image?: SortOrder
    prefecture?: SortOrder
    post_code?: SortOrder
    city?: SortOrder
    district?: SortOrder
    address?: SortOrder
    address1?: SortOrder
    nearest_station?: SortOrder
    socials?: SortOrder
    gps?: SortOrder
    contact_person?: SortOrder
    contact_details?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
    entity_id?: SortOrder
    _count?: EntityBranchCountOrderByAggregateInput
    _avg?: EntityBranchAvgOrderByAggregateInput
    _max?: EntityBranchMaxOrderByAggregateInput
    _min?: EntityBranchMinOrderByAggregateInput
    _sum?: EntityBranchSumOrderByAggregateInput
  }

  export type EntityBranchScalarWhereWithAggregatesInput = {
    AND?: Enumerable<EntityBranchScalarWhereWithAggregatesInput>
    OR?: Enumerable<EntityBranchScalarWhereWithAggregatesInput>
    NOT?: Enumerable<EntityBranchScalarWhereWithAggregatesInput>
    branch_id?: IntWithAggregatesFilter | number
    branch_name?: StringNullableWithAggregatesFilter | string | null
    kana?: StringNullableWithAggregatesFilter | string | null
    is_jeadquarter?: BoolWithAggregatesFilter | boolean
    image?: StringNullableWithAggregatesFilter | string | null
    prefecture?: JsonNullableWithAggregatesFilter
    post_code?: StringNullableWithAggregatesFilter | string | null
    city?: StringNullableWithAggregatesFilter | string | null
    district?: StringNullableWithAggregatesFilter | string | null
    address?: StringNullableWithAggregatesFilter | string | null
    address1?: StringNullableWithAggregatesFilter | string | null
    nearest_station?: StringNullableWithAggregatesFilter | string | null
    socials?: JsonNullableWithAggregatesFilter
    gps?: JsonNullableWithAggregatesFilter
    contact_person?: JsonNullableWithAggregatesFilter
    contact_details?: JsonNullableWithAggregatesFilter
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeWithAggregatesFilter | Date | string
    created_by?: StringNullableWithAggregatesFilter | string | null
    updated_by?: StringNullableWithAggregatesFilter | string | null
    entity_id?: IntWithAggregatesFilter | number
  }

  export type EntityDetailWhereInput = {
    AND?: Enumerable<EntityDetailWhereInput>
    OR?: Enumerable<EntityDetailWhereInput>
    NOT?: Enumerable<EntityDetailWhereInput>
    entity_detail_id?: StringFilter | string
    entity_id?: IntNullableFilter | number | null
    entity?: XOR<EntityRelationFilter, EntityWhereInput> | null
    establishment?: DateTimeNullableFilter | Date | string | null
    capital?: IntNullableFilter | number | null
    numberof_employees?: IntNullableFilter | number | null
    business_performance?: JsonNullableFilter
    representative_telephone?: StringNullableFilter | string | null
    representative?: StringNullableFilter | string | null
    average_age?: IntNullableFilter | number | null
    foreign_capitalratio?: IntNullableFilter | number | null
    homepage?: StringNullableFilter | string | null
    business_summary?: StringNullableFilter | string | null
    organizational_structure?: StringNullableFilter | string | null
    company_sales?: StringNullableFilter | string | null
    workplace_environment?: StringNullableFilter | string | null
    shareholder?: JsonNullableFilter
    related_company?: IntNullableFilter | number | null
    recruitment_personname?: StringNullableFilter | string | null
    memo?: StringNullableFilter | string | null
    business_status?: StringNullableFilter | string | null
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    created_by?: StringNullableFilter | string | null
    updated_by?: StringNullableFilter | string | null
  }

  export type EntityDetailOrderByWithRelationInput = {
    entity_detail_id?: SortOrder
    entity_id?: SortOrder
    entity?: EntityOrderByWithRelationInput
    establishment?: SortOrder
    capital?: SortOrder
    numberof_employees?: SortOrder
    business_performance?: SortOrder
    representative_telephone?: SortOrder
    representative?: SortOrder
    average_age?: SortOrder
    foreign_capitalratio?: SortOrder
    homepage?: SortOrder
    business_summary?: SortOrder
    organizational_structure?: SortOrder
    company_sales?: SortOrder
    workplace_environment?: SortOrder
    shareholder?: SortOrder
    related_company?: SortOrder
    recruitment_personname?: SortOrder
    memo?: SortOrder
    business_status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
  }

  export type EntityDetailWhereUniqueInput = {
    entity_detail_id?: string
  }

  export type EntityDetailOrderByWithAggregationInput = {
    entity_detail_id?: SortOrder
    entity_id?: SortOrder
    establishment?: SortOrder
    capital?: SortOrder
    numberof_employees?: SortOrder
    business_performance?: SortOrder
    representative_telephone?: SortOrder
    representative?: SortOrder
    average_age?: SortOrder
    foreign_capitalratio?: SortOrder
    homepage?: SortOrder
    business_summary?: SortOrder
    organizational_structure?: SortOrder
    company_sales?: SortOrder
    workplace_environment?: SortOrder
    shareholder?: SortOrder
    related_company?: SortOrder
    recruitment_personname?: SortOrder
    memo?: SortOrder
    business_status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
    _count?: EntityDetailCountOrderByAggregateInput
    _avg?: EntityDetailAvgOrderByAggregateInput
    _max?: EntityDetailMaxOrderByAggregateInput
    _min?: EntityDetailMinOrderByAggregateInput
    _sum?: EntityDetailSumOrderByAggregateInput
  }

  export type EntityDetailScalarWhereWithAggregatesInput = {
    AND?: Enumerable<EntityDetailScalarWhereWithAggregatesInput>
    OR?: Enumerable<EntityDetailScalarWhereWithAggregatesInput>
    NOT?: Enumerable<EntityDetailScalarWhereWithAggregatesInput>
    entity_detail_id?: StringWithAggregatesFilter | string
    entity_id?: IntNullableWithAggregatesFilter | number | null
    establishment?: DateTimeNullableWithAggregatesFilter | Date | string | null
    capital?: IntNullableWithAggregatesFilter | number | null
    numberof_employees?: IntNullableWithAggregatesFilter | number | null
    business_performance?: JsonNullableWithAggregatesFilter
    representative_telephone?: StringNullableWithAggregatesFilter | string | null
    representative?: StringNullableWithAggregatesFilter | string | null
    average_age?: IntNullableWithAggregatesFilter | number | null
    foreign_capitalratio?: IntNullableWithAggregatesFilter | number | null
    homepage?: StringNullableWithAggregatesFilter | string | null
    business_summary?: StringNullableWithAggregatesFilter | string | null
    organizational_structure?: StringNullableWithAggregatesFilter | string | null
    company_sales?: StringNullableWithAggregatesFilter | string | null
    workplace_environment?: StringNullableWithAggregatesFilter | string | null
    shareholder?: JsonNullableWithAggregatesFilter
    related_company?: IntNullableWithAggregatesFilter | number | null
    recruitment_personname?: StringNullableWithAggregatesFilter | string | null
    memo?: StringNullableWithAggregatesFilter | string | null
    business_status?: StringNullableWithAggregatesFilter | string | null
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeWithAggregatesFilter | Date | string
    created_by?: StringNullableWithAggregatesFilter | string | null
    updated_by?: StringNullableWithAggregatesFilter | string | null
  }

  export type FilesWhereInput = {
    AND?: Enumerable<FilesWhereInput>
    OR?: Enumerable<FilesWhereInput>
    NOT?: Enumerable<FilesWhereInput>
    file_id?: StringFilter | string
    file_name?: StringFilter | string
    target_id?: StringFilter | string
    file_path?: StringFilter | string
    file_type?: EnumFileTypeFilter | FileType
    fiel_source?: EnumFileSourceFilter | FileSource
    created_at?: DateTimeFilter | Date | string
    created_by?: StringFilter | string
  }

  export type FilesOrderByWithRelationInput = {
    file_id?: SortOrder
    file_name?: SortOrder
    target_id?: SortOrder
    file_path?: SortOrder
    file_type?: SortOrder
    fiel_source?: SortOrder
    created_at?: SortOrder
    created_by?: SortOrder
  }

  export type FilesWhereUniqueInput = {
    file_id?: string
  }

  export type FilesOrderByWithAggregationInput = {
    file_id?: SortOrder
    file_name?: SortOrder
    target_id?: SortOrder
    file_path?: SortOrder
    file_type?: SortOrder
    fiel_source?: SortOrder
    created_at?: SortOrder
    created_by?: SortOrder
    _count?: FilesCountOrderByAggregateInput
    _max?: FilesMaxOrderByAggregateInput
    _min?: FilesMinOrderByAggregateInput
  }

  export type FilesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<FilesScalarWhereWithAggregatesInput>
    OR?: Enumerable<FilesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<FilesScalarWhereWithAggregatesInput>
    file_id?: StringWithAggregatesFilter | string
    file_name?: StringWithAggregatesFilter | string
    target_id?: StringWithAggregatesFilter | string
    file_path?: StringWithAggregatesFilter | string
    file_type?: EnumFileTypeWithAggregatesFilter | FileType
    fiel_source?: EnumFileSourceWithAggregatesFilter | FileSource
    created_at?: DateTimeWithAggregatesFilter | Date | string
    created_by?: StringWithAggregatesFilter | string
  }

  export type InquiryWhereInput = {
    AND?: Enumerable<InquiryWhereInput>
    OR?: Enumerable<InquiryWhereInput>
    NOT?: Enumerable<InquiryWhereInput>
    inquire_id?: StringFilter | string
    parent_id?: StringNullableFilter | string | null
    fromuser_id?: StringNullableFilter | string | null
    fromuser?: XOR<UserRelationFilter, UserWhereInput> | null
    entity_id?: IntNullableFilter | number | null
    entity?: XOR<EntityRelationFilter, EntityWhereInput> | null
    assigned_user_id?: StringNullableFilter | string | null
    assignUser?: XOR<UserRelationFilter, UserWhereInput> | null
    subject?: StringFilter | string
    body?: StringFilter | string
    inquiry_status?: EnumInquiryStatusNullableFilter | InquiryStatus | null
    is_read?: BoolFilter | boolean
    is_answer?: BoolFilter | boolean
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    created_by?: StringNullableFilter | string | null
  }

  export type InquiryOrderByWithRelationInput = {
    inquire_id?: SortOrder
    parent_id?: SortOrder
    fromuser_id?: SortOrder
    fromuser?: UserOrderByWithRelationInput
    entity_id?: SortOrder
    entity?: EntityOrderByWithRelationInput
    assigned_user_id?: SortOrder
    assignUser?: UserOrderByWithRelationInput
    subject?: SortOrder
    body?: SortOrder
    inquiry_status?: SortOrder
    is_read?: SortOrder
    is_answer?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    created_by?: SortOrder
  }

  export type InquiryWhereUniqueInput = {
    inquire_id?: string
  }

  export type InquiryOrderByWithAggregationInput = {
    inquire_id?: SortOrder
    parent_id?: SortOrder
    fromuser_id?: SortOrder
    entity_id?: SortOrder
    assigned_user_id?: SortOrder
    subject?: SortOrder
    body?: SortOrder
    inquiry_status?: SortOrder
    is_read?: SortOrder
    is_answer?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    created_by?: SortOrder
    _count?: InquiryCountOrderByAggregateInput
    _avg?: InquiryAvgOrderByAggregateInput
    _max?: InquiryMaxOrderByAggregateInput
    _min?: InquiryMinOrderByAggregateInput
    _sum?: InquirySumOrderByAggregateInput
  }

  export type InquiryScalarWhereWithAggregatesInput = {
    AND?: Enumerable<InquiryScalarWhereWithAggregatesInput>
    OR?: Enumerable<InquiryScalarWhereWithAggregatesInput>
    NOT?: Enumerable<InquiryScalarWhereWithAggregatesInput>
    inquire_id?: StringWithAggregatesFilter | string
    parent_id?: StringNullableWithAggregatesFilter | string | null
    fromuser_id?: StringNullableWithAggregatesFilter | string | null
    entity_id?: IntNullableWithAggregatesFilter | number | null
    assigned_user_id?: StringNullableWithAggregatesFilter | string | null
    subject?: StringWithAggregatesFilter | string
    body?: StringWithAggregatesFilter | string
    inquiry_status?: EnumInquiryStatusNullableWithAggregatesFilter | InquiryStatus | null
    is_read?: BoolWithAggregatesFilter | boolean
    is_answer?: BoolWithAggregatesFilter | boolean
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeWithAggregatesFilter | Date | string
    created_by?: StringNullableWithAggregatesFilter | string | null
  }

  export type JobWhereInput = {
    AND?: Enumerable<JobWhereInput>
    OR?: Enumerable<JobWhereInput>
    NOT?: Enumerable<JobWhereInput>
    job_id?: StringFilter | string
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    created_by?: StringFilter | string
    updated_by?: StringNullableFilter | string | null
    job_publish?: EnumJobPublishFilter | JobPublish
    job_references?: JobReferenceListListRelationFilter
    location_details?: StringNullableFilter | string | null
    career_level?: EnumJobPositionNullableListFilter
    benefit_other?: StringNullableFilter | string | null
    smoke?: EnumSmokeNullableListFilter
    employment_status?: EnumEmploymentStatusFilter | EmploymentStatus
    japanese_level?: EnumLanguageLevelFilter | LanguageLevel
    english_level?: EnumLanguageLevelFilter | LanguageLevel
    job_other_languages?: JobOtherLanguageListRelationFilter
    experienced_count?: IntFilter | number
    age_min?: IntNullableFilter | number | null
    age_max?: IntNullableFilter | number | null
    set_age_reason?: StringNullableFilter | string | null
    recruitment_type?: EnumReqriutmentTypeNullableFilter | ReqriutmentType | null
    job_title?: StringFilter | string
    job_description?: StringFilter | string
    japanese_percentage?: IntNullableFilter | number | null
    must_condition?: StringFilter | string
    want_condition?: StringNullableFilter | string | null
    position_name?: StringNullableFilter | string | null
    working_hour?: StringFilter | string
    salary_type?: EnumSalaryTypeFilter | SalaryType
    salary_min?: IntNullableFilter | number | null
    salary_max?: IntNullableFilter | number | null
    salary_detail?: StringFilter | string
    day_off?: StringNullableFilter | string | null
    progress_detail?: StringFilter | string
    entity_branch_id?: IntFilter | number
    expire_date?: DateTimeNullableFilter | Date | string | null
    entity_branch?: XOR<EntityBranchRelationFilter, EntityBranchWhereInput> | null
    job_candidates?: JobCandidateListRelationFilter
    JobRequirement?: JobRequirementListRelationFilter
  }

  export type JobOrderByWithRelationInput = {
    job_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
    job_publish?: SortOrder
    job_references?: JobReferenceListOrderByRelationAggregateInput
    location_details?: SortOrder
    career_level?: SortOrder
    benefit_other?: SortOrder
    smoke?: SortOrder
    employment_status?: SortOrder
    japanese_level?: SortOrder
    english_level?: SortOrder
    job_other_languages?: JobOtherLanguageOrderByRelationAggregateInput
    experienced_count?: SortOrder
    age_min?: SortOrder
    age_max?: SortOrder
    set_age_reason?: SortOrder
    recruitment_type?: SortOrder
    job_title?: SortOrder
    job_description?: SortOrder
    japanese_percentage?: SortOrder
    must_condition?: SortOrder
    want_condition?: SortOrder
    position_name?: SortOrder
    working_hour?: SortOrder
    salary_type?: SortOrder
    salary_min?: SortOrder
    salary_max?: SortOrder
    salary_detail?: SortOrder
    day_off?: SortOrder
    progress_detail?: SortOrder
    entity_branch_id?: SortOrder
    expire_date?: SortOrder
    entity_branch?: EntityBranchOrderByWithRelationInput
    job_candidates?: JobCandidateOrderByRelationAggregateInput
    JobRequirement?: JobRequirementOrderByRelationAggregateInput
  }

  export type JobWhereUniqueInput = {
    job_id?: string
  }

  export type JobOrderByWithAggregationInput = {
    job_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
    job_publish?: SortOrder
    location_details?: SortOrder
    career_level?: SortOrder
    benefit_other?: SortOrder
    smoke?: SortOrder
    employment_status?: SortOrder
    japanese_level?: SortOrder
    english_level?: SortOrder
    experienced_count?: SortOrder
    age_min?: SortOrder
    age_max?: SortOrder
    set_age_reason?: SortOrder
    recruitment_type?: SortOrder
    job_title?: SortOrder
    job_description?: SortOrder
    japanese_percentage?: SortOrder
    must_condition?: SortOrder
    want_condition?: SortOrder
    position_name?: SortOrder
    working_hour?: SortOrder
    salary_type?: SortOrder
    salary_min?: SortOrder
    salary_max?: SortOrder
    salary_detail?: SortOrder
    day_off?: SortOrder
    progress_detail?: SortOrder
    entity_branch_id?: SortOrder
    expire_date?: SortOrder
    _count?: JobCountOrderByAggregateInput
    _avg?: JobAvgOrderByAggregateInput
    _max?: JobMaxOrderByAggregateInput
    _min?: JobMinOrderByAggregateInput
    _sum?: JobSumOrderByAggregateInput
  }

  export type JobScalarWhereWithAggregatesInput = {
    AND?: Enumerable<JobScalarWhereWithAggregatesInput>
    OR?: Enumerable<JobScalarWhereWithAggregatesInput>
    NOT?: Enumerable<JobScalarWhereWithAggregatesInput>
    job_id?: StringWithAggregatesFilter | string
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeWithAggregatesFilter | Date | string
    created_by?: StringWithAggregatesFilter | string
    updated_by?: StringNullableWithAggregatesFilter | string | null
    job_publish?: EnumJobPublishWithAggregatesFilter | JobPublish
    location_details?: StringNullableWithAggregatesFilter | string | null
    career_level?: EnumJobPositionNullableListFilter
    benefit_other?: StringNullableWithAggregatesFilter | string | null
    smoke?: EnumSmokeNullableListFilter
    employment_status?: EnumEmploymentStatusWithAggregatesFilter | EmploymentStatus
    japanese_level?: EnumLanguageLevelWithAggregatesFilter | LanguageLevel
    english_level?: EnumLanguageLevelWithAggregatesFilter | LanguageLevel
    experienced_count?: IntWithAggregatesFilter | number
    age_min?: IntNullableWithAggregatesFilter | number | null
    age_max?: IntNullableWithAggregatesFilter | number | null
    set_age_reason?: StringNullableWithAggregatesFilter | string | null
    recruitment_type?: EnumReqriutmentTypeNullableWithAggregatesFilter | ReqriutmentType | null
    job_title?: StringWithAggregatesFilter | string
    job_description?: StringWithAggregatesFilter | string
    japanese_percentage?: IntNullableWithAggregatesFilter | number | null
    must_condition?: StringWithAggregatesFilter | string
    want_condition?: StringNullableWithAggregatesFilter | string | null
    position_name?: StringNullableWithAggregatesFilter | string | null
    working_hour?: StringWithAggregatesFilter | string
    salary_type?: EnumSalaryTypeWithAggregatesFilter | SalaryType
    salary_min?: IntNullableWithAggregatesFilter | number | null
    salary_max?: IntNullableWithAggregatesFilter | number | null
    salary_detail?: StringWithAggregatesFilter | string
    day_off?: StringNullableWithAggregatesFilter | string | null
    progress_detail?: StringWithAggregatesFilter | string
    entity_branch_id?: IntWithAggregatesFilter | number
    expire_date?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type JobOtherLanguageWhereInput = {
    AND?: Enumerable<JobOtherLanguageWhereInput>
    OR?: Enumerable<JobOtherLanguageWhereInput>
    NOT?: Enumerable<JobOtherLanguageWhereInput>
    job_other_language_id?: StringFilter | string
    language_id?: IntFilter | number
    language_level?: EnumLanguageLevelFilter | LanguageLevel
    job_id?: StringFilter | string
    job?: XOR<JobRelationFilter, JobWhereInput>
  }

  export type JobOtherLanguageOrderByWithRelationInput = {
    job_other_language_id?: SortOrder
    language_id?: SortOrder
    language_level?: SortOrder
    job_id?: SortOrder
    job?: JobOrderByWithRelationInput
  }

  export type JobOtherLanguageWhereUniqueInput = {
    job_other_language_id?: string
  }

  export type JobOtherLanguageOrderByWithAggregationInput = {
    job_other_language_id?: SortOrder
    language_id?: SortOrder
    language_level?: SortOrder
    job_id?: SortOrder
    _count?: JobOtherLanguageCountOrderByAggregateInput
    _avg?: JobOtherLanguageAvgOrderByAggregateInput
    _max?: JobOtherLanguageMaxOrderByAggregateInput
    _min?: JobOtherLanguageMinOrderByAggregateInput
    _sum?: JobOtherLanguageSumOrderByAggregateInput
  }

  export type JobOtherLanguageScalarWhereWithAggregatesInput = {
    AND?: Enumerable<JobOtherLanguageScalarWhereWithAggregatesInput>
    OR?: Enumerable<JobOtherLanguageScalarWhereWithAggregatesInput>
    NOT?: Enumerable<JobOtherLanguageScalarWhereWithAggregatesInput>
    job_other_language_id?: StringWithAggregatesFilter | string
    language_id?: IntWithAggregatesFilter | number
    language_level?: EnumLanguageLevelWithAggregatesFilter | LanguageLevel
    job_id?: StringWithAggregatesFilter | string
  }

  export type JobReferenceListWhereInput = {
    AND?: Enumerable<JobReferenceListWhereInput>
    OR?: Enumerable<JobReferenceListWhereInput>
    NOT?: Enumerable<JobReferenceListWhereInput>
    job_reference_id?: StringFilter | string
    job_id?: StringFilter | string
    reference_list_id?: IntFilter | number
    reference_list_item_id?: IntFilter | number
    job?: XOR<JobRelationFilter, JobWhereInput>
    reference_list?: XOR<ReferenceListRelationFilter, ReferenceListWhereInput>
    reference_list_item?: XOR<ReferenceListItemsRelationFilter, ReferenceListItemsWhereInput>
  }

  export type JobReferenceListOrderByWithRelationInput = {
    job_reference_id?: SortOrder
    job_id?: SortOrder
    reference_list_id?: SortOrder
    reference_list_item_id?: SortOrder
    job?: JobOrderByWithRelationInput
    reference_list?: ReferenceListOrderByWithRelationInput
    reference_list_item?: ReferenceListItemsOrderByWithRelationInput
  }

  export type JobReferenceListWhereUniqueInput = {
    job_reference_id?: string
  }

  export type JobReferenceListOrderByWithAggregationInput = {
    job_reference_id?: SortOrder
    job_id?: SortOrder
    reference_list_id?: SortOrder
    reference_list_item_id?: SortOrder
    _count?: JobReferenceListCountOrderByAggregateInput
    _avg?: JobReferenceListAvgOrderByAggregateInput
    _max?: JobReferenceListMaxOrderByAggregateInput
    _min?: JobReferenceListMinOrderByAggregateInput
    _sum?: JobReferenceListSumOrderByAggregateInput
  }

  export type JobReferenceListScalarWhereWithAggregatesInput = {
    AND?: Enumerable<JobReferenceListScalarWhereWithAggregatesInput>
    OR?: Enumerable<JobReferenceListScalarWhereWithAggregatesInput>
    NOT?: Enumerable<JobReferenceListScalarWhereWithAggregatesInput>
    job_reference_id?: StringWithAggregatesFilter | string
    job_id?: StringWithAggregatesFilter | string
    reference_list_id?: IntWithAggregatesFilter | number
    reference_list_item_id?: IntWithAggregatesFilter | number
  }

  export type JobCandidateWhereInput = {
    AND?: Enumerable<JobCandidateWhereInput>
    OR?: Enumerable<JobCandidateWhereInput>
    NOT?: Enumerable<JobCandidateWhereInput>
    job_candidate_id?: StringFilter | string
    job_id?: StringFilter | string
    job?: XOR<JobRelationFilter, JobWhereInput>
    customer_id?: StringFilter | string
    customer?: XOR<CustomerRelationFilter, CustomerWhereInput>
    candidate_status?: IntFilter | number
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    created_by?: StringNullableFilter | string | null
    updated_by?: StringNullableFilter | string | null
  }

  export type JobCandidateOrderByWithRelationInput = {
    job_candidate_id?: SortOrder
    job_id?: SortOrder
    job?: JobOrderByWithRelationInput
    customer_id?: SortOrder
    customer?: CustomerOrderByWithRelationInput
    candidate_status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
  }

  export type JobCandidateWhereUniqueInput = {
    job_candidate_id?: string
  }

  export type JobCandidateOrderByWithAggregationInput = {
    job_candidate_id?: SortOrder
    job_id?: SortOrder
    customer_id?: SortOrder
    candidate_status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
    _count?: JobCandidateCountOrderByAggregateInput
    _avg?: JobCandidateAvgOrderByAggregateInput
    _max?: JobCandidateMaxOrderByAggregateInput
    _min?: JobCandidateMinOrderByAggregateInput
    _sum?: JobCandidateSumOrderByAggregateInput
  }

  export type JobCandidateScalarWhereWithAggregatesInput = {
    AND?: Enumerable<JobCandidateScalarWhereWithAggregatesInput>
    OR?: Enumerable<JobCandidateScalarWhereWithAggregatesInput>
    NOT?: Enumerable<JobCandidateScalarWhereWithAggregatesInput>
    job_candidate_id?: StringWithAggregatesFilter | string
    job_id?: StringWithAggregatesFilter | string
    customer_id?: StringWithAggregatesFilter | string
    candidate_status?: IntWithAggregatesFilter | number
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeWithAggregatesFilter | Date | string
    created_by?: StringNullableWithAggregatesFilter | string | null
    updated_by?: StringNullableWithAggregatesFilter | string | null
  }

  export type JobRequirementWhereInput = {
    AND?: Enumerable<JobRequirementWhereInput>
    OR?: Enumerable<JobRequirementWhereInput>
    NOT?: Enumerable<JobRequirementWhereInput>
    job_require_id?: StringFilter | string
    job_id?: StringFilter | string
    jobs?: XOR<JobRelationFilter, JobWhereInput>
    require_id?: IntFilter | number
    require_detial?: JsonNullableFilter
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    created_by?: StringNullableFilter | string | null
    updated_by?: StringNullableFilter | string | null
  }

  export type JobRequirementOrderByWithRelationInput = {
    job_require_id?: SortOrder
    job_id?: SortOrder
    jobs?: JobOrderByWithRelationInput
    require_id?: SortOrder
    require_detial?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
  }

  export type JobRequirementWhereUniqueInput = {
    job_require_id?: string
  }

  export type JobRequirementOrderByWithAggregationInput = {
    job_require_id?: SortOrder
    job_id?: SortOrder
    require_id?: SortOrder
    require_detial?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
    _count?: JobRequirementCountOrderByAggregateInput
    _avg?: JobRequirementAvgOrderByAggregateInput
    _max?: JobRequirementMaxOrderByAggregateInput
    _min?: JobRequirementMinOrderByAggregateInput
    _sum?: JobRequirementSumOrderByAggregateInput
  }

  export type JobRequirementScalarWhereWithAggregatesInput = {
    AND?: Enumerable<JobRequirementScalarWhereWithAggregatesInput>
    OR?: Enumerable<JobRequirementScalarWhereWithAggregatesInput>
    NOT?: Enumerable<JobRequirementScalarWhereWithAggregatesInput>
    job_require_id?: StringWithAggregatesFilter | string
    job_id?: StringWithAggregatesFilter | string
    require_id?: IntWithAggregatesFilter | number
    require_detial?: JsonNullableWithAggregatesFilter
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeWithAggregatesFilter | Date | string
    created_by?: StringNullableWithAggregatesFilter | string | null
    updated_by?: StringNullableWithAggregatesFilter | string | null
  }

  export type SystemLangaugeWhereInput = {
    AND?: Enumerable<SystemLangaugeWhereInput>
    OR?: Enumerable<SystemLangaugeWhereInput>
    NOT?: Enumerable<SystemLangaugeWhereInput>
    language_id?: IntFilter | number
    language_code?: StringFilter | string
    is_default?: BoolFilter | boolean
  }

  export type SystemLangaugeOrderByWithRelationInput = {
    language_id?: SortOrder
    language_code?: SortOrder
    is_default?: SortOrder
  }

  export type SystemLangaugeWhereUniqueInput = {
    language_id?: number
    language_code?: string
  }

  export type SystemLangaugeOrderByWithAggregationInput = {
    language_id?: SortOrder
    language_code?: SortOrder
    is_default?: SortOrder
    _count?: SystemLangaugeCountOrderByAggregateInput
    _avg?: SystemLangaugeAvgOrderByAggregateInput
    _max?: SystemLangaugeMaxOrderByAggregateInput
    _min?: SystemLangaugeMinOrderByAggregateInput
    _sum?: SystemLangaugeSumOrderByAggregateInput
  }

  export type SystemLangaugeScalarWhereWithAggregatesInput = {
    AND?: Enumerable<SystemLangaugeScalarWhereWithAggregatesInput>
    OR?: Enumerable<SystemLangaugeScalarWhereWithAggregatesInput>
    NOT?: Enumerable<SystemLangaugeScalarWhereWithAggregatesInput>
    language_id?: IntWithAggregatesFilter | number
    language_code?: StringWithAggregatesFilter | string
    is_default?: BoolWithAggregatesFilter | boolean
  }

  export type LoggerWhereInput = {
    AND?: Enumerable<LoggerWhereInput>
    OR?: Enumerable<LoggerWhereInput>
    NOT?: Enumerable<LoggerWhereInput>
    log_id?: StringFilter | string
    action_user?: EnumUserActionFilter | UserAction
    user_id?: StringNullableFilter | string | null
    User?: XOR<UserRelationFilter, UserWhereInput> | null
    new_value?: JsonNullableFilter
    old_value?: JsonNullableFilter
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    created_by?: StringNullableFilter | string | null
    updated_by?: StringNullableFilter | string | null
  }

  export type LoggerOrderByWithRelationInput = {
    log_id?: SortOrder
    action_user?: SortOrder
    user_id?: SortOrder
    User?: UserOrderByWithRelationInput
    new_value?: SortOrder
    old_value?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
  }

  export type LoggerWhereUniqueInput = {
    log_id?: string
  }

  export type LoggerOrderByWithAggregationInput = {
    log_id?: SortOrder
    action_user?: SortOrder
    user_id?: SortOrder
    new_value?: SortOrder
    old_value?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
    _count?: LoggerCountOrderByAggregateInput
    _max?: LoggerMaxOrderByAggregateInput
    _min?: LoggerMinOrderByAggregateInput
  }

  export type LoggerScalarWhereWithAggregatesInput = {
    AND?: Enumerable<LoggerScalarWhereWithAggregatesInput>
    OR?: Enumerable<LoggerScalarWhereWithAggregatesInput>
    NOT?: Enumerable<LoggerScalarWhereWithAggregatesInput>
    log_id?: StringWithAggregatesFilter | string
    action_user?: EnumUserActionWithAggregatesFilter | UserAction
    user_id?: StringNullableWithAggregatesFilter | string | null
    new_value?: JsonNullableWithAggregatesFilter
    old_value?: JsonNullableWithAggregatesFilter
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeWithAggregatesFilter | Date | string
    created_by?: StringNullableWithAggregatesFilter | string | null
    updated_by?: StringNullableWithAggregatesFilter | string | null
  }

  export type NewsWhereInput = {
    AND?: Enumerable<NewsWhereInput>
    OR?: Enumerable<NewsWhereInput>
    NOT?: Enumerable<NewsWhereInput>
    news_id?: StringFilter | string
    page_id?: IntFilter | number
    pages?: XOR<PagesRelationFilter, PagesWhereInput>
    title?: StringFilter | string
    brief?: StringFilter | string
    image_id?: StringFilter | string
    content?: StringFilter | string
    is_top?: BoolFilter | boolean
    is_publish?: BoolFilter | boolean
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    created_by?: StringFilter | string
    update_by?: StringFilter | string
  }

  export type NewsOrderByWithRelationInput = {
    news_id?: SortOrder
    page_id?: SortOrder
    pages?: PagesOrderByWithRelationInput
    title?: SortOrder
    brief?: SortOrder
    image_id?: SortOrder
    content?: SortOrder
    is_top?: SortOrder
    is_publish?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    created_by?: SortOrder
    update_by?: SortOrder
  }

  export type NewsWhereUniqueInput = {
    news_id?: string
  }

  export type NewsOrderByWithAggregationInput = {
    news_id?: SortOrder
    page_id?: SortOrder
    title?: SortOrder
    brief?: SortOrder
    image_id?: SortOrder
    content?: SortOrder
    is_top?: SortOrder
    is_publish?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    created_by?: SortOrder
    update_by?: SortOrder
    _count?: NewsCountOrderByAggregateInput
    _avg?: NewsAvgOrderByAggregateInput
    _max?: NewsMaxOrderByAggregateInput
    _min?: NewsMinOrderByAggregateInput
    _sum?: NewsSumOrderByAggregateInput
  }

  export type NewsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<NewsScalarWhereWithAggregatesInput>
    OR?: Enumerable<NewsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<NewsScalarWhereWithAggregatesInput>
    news_id?: StringWithAggregatesFilter | string
    page_id?: IntWithAggregatesFilter | number
    title?: StringWithAggregatesFilter | string
    brief?: StringWithAggregatesFilter | string
    image_id?: StringWithAggregatesFilter | string
    content?: StringWithAggregatesFilter | string
    is_top?: BoolWithAggregatesFilter | boolean
    is_publish?: BoolWithAggregatesFilter | boolean
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeWithAggregatesFilter | Date | string
    created_by?: StringWithAggregatesFilter | string
    update_by?: StringWithAggregatesFilter | string
  }

  export type NotificationWhereInput = {
    AND?: Enumerable<NotificationWhereInput>
    OR?: Enumerable<NotificationWhereInput>
    NOT?: Enumerable<NotificationWhereInput>
    notifiation_id?: StringFilter | string
    user_id?: StringFilter | string
    User?: XOR<UserRelationFilter, UserWhereInput>
    link?: StringFilter | string
    message?: StringFilter | string
    is_new?: BoolFilter | boolean
    is_badge?: BoolFilter | boolean
    created_at?: DateTimeFilter | Date | string
    created_by?: StringFilter | string
  }

  export type NotificationOrderByWithRelationInput = {
    notifiation_id?: SortOrder
    user_id?: SortOrder
    User?: UserOrderByWithRelationInput
    link?: SortOrder
    message?: SortOrder
    is_new?: SortOrder
    is_badge?: SortOrder
    created_at?: SortOrder
    created_by?: SortOrder
  }

  export type NotificationWhereUniqueInput = {
    notifiation_id?: string
  }

  export type NotificationOrderByWithAggregationInput = {
    notifiation_id?: SortOrder
    user_id?: SortOrder
    link?: SortOrder
    message?: SortOrder
    is_new?: SortOrder
    is_badge?: SortOrder
    created_at?: SortOrder
    created_by?: SortOrder
    _count?: NotificationCountOrderByAggregateInput
    _max?: NotificationMaxOrderByAggregateInput
    _min?: NotificationMinOrderByAggregateInput
  }

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?: Enumerable<NotificationScalarWhereWithAggregatesInput>
    OR?: Enumerable<NotificationScalarWhereWithAggregatesInput>
    NOT?: Enumerable<NotificationScalarWhereWithAggregatesInput>
    notifiation_id?: StringWithAggregatesFilter | string
    user_id?: StringWithAggregatesFilter | string
    link?: StringWithAggregatesFilter | string
    message?: StringWithAggregatesFilter | string
    is_new?: BoolWithAggregatesFilter | boolean
    is_badge?: BoolWithAggregatesFilter | boolean
    created_at?: DateTimeWithAggregatesFilter | Date | string
    created_by?: StringWithAggregatesFilter | string
  }

  export type PagesWhereInput = {
    AND?: Enumerable<PagesWhereInput>
    OR?: Enumerable<PagesWhereInput>
    NOT?: Enumerable<PagesWhereInput>
    page_id?: IntFilter | number
    page_name?: StringFilter | string
    page_type?: IntFilter | number
    created_at?: DateTimeFilter | Date | string
    created_by?: StringFilter | string
    news?: NewsListRelationFilter
  }

  export type PagesOrderByWithRelationInput = {
    page_id?: SortOrder
    page_name?: SortOrder
    page_type?: SortOrder
    created_at?: SortOrder
    created_by?: SortOrder
    news?: NewsOrderByRelationAggregateInput
  }

  export type PagesWhereUniqueInput = {
    page_id?: number
  }

  export type PagesOrderByWithAggregationInput = {
    page_id?: SortOrder
    page_name?: SortOrder
    page_type?: SortOrder
    created_at?: SortOrder
    created_by?: SortOrder
    _count?: PagesCountOrderByAggregateInput
    _avg?: PagesAvgOrderByAggregateInput
    _max?: PagesMaxOrderByAggregateInput
    _min?: PagesMinOrderByAggregateInput
    _sum?: PagesSumOrderByAggregateInput
  }

  export type PagesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<PagesScalarWhereWithAggregatesInput>
    OR?: Enumerable<PagesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<PagesScalarWhereWithAggregatesInput>
    page_id?: IntWithAggregatesFilter | number
    page_name?: StringWithAggregatesFilter | string
    page_type?: IntWithAggregatesFilter | number
    created_at?: DateTimeWithAggregatesFilter | Date | string
    created_by?: StringWithAggregatesFilter | string
  }

  export type ReferenceListWhereInput = {
    AND?: Enumerable<ReferenceListWhereInput>
    OR?: Enumerable<ReferenceListWhereInput>
    NOT?: Enumerable<ReferenceListWhereInput>
    list_id?: IntFilter | number
    list_name?: StringFilter | string
    created_at?: DateTimeFilter | Date | string
    listitems?: ReferenceListItemsListRelationFilter
    JobReferenceList?: JobReferenceListListRelationFilter
  }

  export type ReferenceListOrderByWithRelationInput = {
    list_id?: SortOrder
    list_name?: SortOrder
    created_at?: SortOrder
    listitems?: ReferenceListItemsOrderByRelationAggregateInput
    JobReferenceList?: JobReferenceListOrderByRelationAggregateInput
  }

  export type ReferenceListWhereUniqueInput = {
    list_id?: number
  }

  export type ReferenceListOrderByWithAggregationInput = {
    list_id?: SortOrder
    list_name?: SortOrder
    created_at?: SortOrder
    _count?: ReferenceListCountOrderByAggregateInput
    _avg?: ReferenceListAvgOrderByAggregateInput
    _max?: ReferenceListMaxOrderByAggregateInput
    _min?: ReferenceListMinOrderByAggregateInput
    _sum?: ReferenceListSumOrderByAggregateInput
  }

  export type ReferenceListScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ReferenceListScalarWhereWithAggregatesInput>
    OR?: Enumerable<ReferenceListScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ReferenceListScalarWhereWithAggregatesInput>
    list_id?: IntWithAggregatesFilter | number
    list_name?: StringWithAggregatesFilter | string
    created_at?: DateTimeWithAggregatesFilter | Date | string
  }

  export type ReferenceListItemsWhereInput = {
    AND?: Enumerable<ReferenceListItemsWhereInput>
    OR?: Enumerable<ReferenceListItemsWhereInput>
    NOT?: Enumerable<ReferenceListItemsWhereInput>
    listitem_id?: IntFilter | number
    list_id?: IntFilter | number
    list?: XOR<ReferenceListRelationFilter, ReferenceListWhereInput>
    dictionary_id?: IntFilter | number
    code?: StringNullableFilter | string | null
    listitem_value?: StringNullableFilter | string | null
    parent_id?: IntNullableFilter | number | null
    value?: StringNullableFilter | string | null
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    customer_experiences?: CustomerExperienceListRelationFilter
    Dictionary?: XOR<DictionaryRelationFilter, DictionaryWhereInput> | null
    dictionaryDictionaries_id?: StringNullableFilter | string | null
    JobReferenceList?: JobReferenceListListRelationFilter
  }

  export type ReferenceListItemsOrderByWithRelationInput = {
    listitem_id?: SortOrder
    list_id?: SortOrder
    list?: ReferenceListOrderByWithRelationInput
    dictionary_id?: SortOrder
    code?: SortOrder
    listitem_value?: SortOrder
    parent_id?: SortOrder
    value?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    customer_experiences?: CustomerExperienceOrderByRelationAggregateInput
    Dictionary?: DictionaryOrderByWithRelationInput
    dictionaryDictionaries_id?: SortOrder
    JobReferenceList?: JobReferenceListOrderByRelationAggregateInput
  }

  export type ReferenceListItemsWhereUniqueInput = {
    listitem_id?: number
  }

  export type ReferenceListItemsOrderByWithAggregationInput = {
    listitem_id?: SortOrder
    list_id?: SortOrder
    dictionary_id?: SortOrder
    code?: SortOrder
    listitem_value?: SortOrder
    parent_id?: SortOrder
    value?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    dictionaryDictionaries_id?: SortOrder
    _count?: ReferenceListItemsCountOrderByAggregateInput
    _avg?: ReferenceListItemsAvgOrderByAggregateInput
    _max?: ReferenceListItemsMaxOrderByAggregateInput
    _min?: ReferenceListItemsMinOrderByAggregateInput
    _sum?: ReferenceListItemsSumOrderByAggregateInput
  }

  export type ReferenceListItemsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ReferenceListItemsScalarWhereWithAggregatesInput>
    OR?: Enumerable<ReferenceListItemsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ReferenceListItemsScalarWhereWithAggregatesInput>
    listitem_id?: IntWithAggregatesFilter | number
    list_id?: IntWithAggregatesFilter | number
    dictionary_id?: IntWithAggregatesFilter | number
    code?: StringNullableWithAggregatesFilter | string | null
    listitem_value?: StringNullableWithAggregatesFilter | string | null
    parent_id?: IntNullableWithAggregatesFilter | number | null
    value?: StringNullableWithAggregatesFilter | string | null
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeWithAggregatesFilter | Date | string
    dictionaryDictionaries_id?: StringNullableWithAggregatesFilter | string | null
  }

  export type ScoutFavWhereInput = {
    AND?: Enumerable<ScoutFavWhereInput>
    OR?: Enumerable<ScoutFavWhereInput>
    NOT?: Enumerable<ScoutFavWhereInput>
    scout_id?: StringFilter | string
    entity_id?: IntNullableFilter | number | null
    branch_id?: IntNullableFilter | number | null
    user_id?: StringFilter | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    job_id?: StringNullableFilter | string | null
    note?: StringFilter | string
    created_at?: DateTimeFilter | Date | string
    created_by?: StringFilter | string
  }

  export type ScoutFavOrderByWithRelationInput = {
    scout_id?: SortOrder
    entity_id?: SortOrder
    branch_id?: SortOrder
    user_id?: SortOrder
    user?: UserOrderByWithRelationInput
    job_id?: SortOrder
    note?: SortOrder
    created_at?: SortOrder
    created_by?: SortOrder
  }

  export type ScoutFavWhereUniqueInput = {
    scout_id?: string
  }

  export type ScoutFavOrderByWithAggregationInput = {
    scout_id?: SortOrder
    entity_id?: SortOrder
    branch_id?: SortOrder
    user_id?: SortOrder
    job_id?: SortOrder
    note?: SortOrder
    created_at?: SortOrder
    created_by?: SortOrder
    _count?: ScoutFavCountOrderByAggregateInput
    _avg?: ScoutFavAvgOrderByAggregateInput
    _max?: ScoutFavMaxOrderByAggregateInput
    _min?: ScoutFavMinOrderByAggregateInput
    _sum?: ScoutFavSumOrderByAggregateInput
  }

  export type ScoutFavScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ScoutFavScalarWhereWithAggregatesInput>
    OR?: Enumerable<ScoutFavScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ScoutFavScalarWhereWithAggregatesInput>
    scout_id?: StringWithAggregatesFilter | string
    entity_id?: IntNullableWithAggregatesFilter | number | null
    branch_id?: IntNullableWithAggregatesFilter | number | null
    user_id?: StringWithAggregatesFilter | string
    job_id?: StringNullableWithAggregatesFilter | string | null
    note?: StringWithAggregatesFilter | string
    created_at?: DateTimeWithAggregatesFilter | Date | string
    created_by?: StringWithAggregatesFilter | string
  }

  export type UserWhereInput = {
    AND?: Enumerable<UserWhereInput>
    OR?: Enumerable<UserWhereInput>
    NOT?: Enumerable<UserWhereInput>
    user_id?: StringFilter | string
    email?: StringFilter | string
    mobile?: StringNullableFilter | string | null
    name?: StringNullableFilter | string | null
    password_hash?: StringFilter | string
    role?: EnumUserRoleFilter | UserRole
    company_id?: IntFilter | number
    customer_id?: StringNullableFilter | string | null
    attemptpass_count?: IntNullableFilter | number | null
    reset_code?: StringFilter | string
    is_emailverified?: BoolFilter | boolean
    is_mobileverified?: BoolFilter | boolean
    user_status?: EnumUserStatusFilter | UserStatus
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    deleted_at?: DateTimeNullableFilter | Date | string | null
    favs?: JsonFilter
    Customer?: XOR<CustomerRelationFilter, CustomerWhereInput> | null
    loggers?: LoggerListRelationFilter
    from_inquiries?: InquiryListRelationFilter
    assign_inquiries?: InquiryListRelationFilter
    notifications?: NotificationListRelationFilter
    ScoutFav?: ScoutFavListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    user_id?: SortOrder
    email?: SortOrder
    mobile?: SortOrder
    name?: SortOrder
    password_hash?: SortOrder
    role?: SortOrder
    company_id?: SortOrder
    customer_id?: SortOrder
    attemptpass_count?: SortOrder
    reset_code?: SortOrder
    is_emailverified?: SortOrder
    is_mobileverified?: SortOrder
    user_status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
    favs?: SortOrder
    Customer?: CustomerOrderByWithRelationInput
    loggers?: LoggerOrderByRelationAggregateInput
    from_inquiries?: InquiryOrderByRelationAggregateInput
    assign_inquiries?: InquiryOrderByRelationAggregateInput
    notifications?: NotificationOrderByRelationAggregateInput
    ScoutFav?: ScoutFavOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = {
    user_id?: string
    customer_id?: string
    email_mobile?: UserEmailMobileCompoundUniqueInput
  }

  export type UserOrderByWithAggregationInput = {
    user_id?: SortOrder
    email?: SortOrder
    mobile?: SortOrder
    name?: SortOrder
    password_hash?: SortOrder
    role?: SortOrder
    company_id?: SortOrder
    customer_id?: SortOrder
    attemptpass_count?: SortOrder
    reset_code?: SortOrder
    is_emailverified?: SortOrder
    is_mobileverified?: SortOrder
    user_status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
    favs?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: Enumerable<UserScalarWhereWithAggregatesInput>
    OR?: Enumerable<UserScalarWhereWithAggregatesInput>
    NOT?: Enumerable<UserScalarWhereWithAggregatesInput>
    user_id?: StringWithAggregatesFilter | string
    email?: StringWithAggregatesFilter | string
    mobile?: StringNullableWithAggregatesFilter | string | null
    name?: StringNullableWithAggregatesFilter | string | null
    password_hash?: StringWithAggregatesFilter | string
    role?: EnumUserRoleWithAggregatesFilter | UserRole
    company_id?: IntWithAggregatesFilter | number
    customer_id?: StringNullableWithAggregatesFilter | string | null
    attemptpass_count?: IntNullableWithAggregatesFilter | number | null
    reset_code?: StringWithAggregatesFilter | string
    is_emailverified?: BoolWithAggregatesFilter | boolean
    is_mobileverified?: BoolWithAggregatesFilter | boolean
    user_status?: EnumUserStatusWithAggregatesFilter | UserStatus
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeWithAggregatesFilter | Date | string
    deleted_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
    favs?: JsonWithAggregatesFilter
  }

  export type ActionRoleCreateInput = {
    action_role_id?: string
    controller_path?: string | null
    action_user?: UserAction
    role?: UserRole
    is_can: boolean
    is_company: boolean
    parent_id?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: string | null
    updated_by?: string | null
  }

  export type ActionRoleUncheckedCreateInput = {
    action_role_id?: string
    controller_path?: string | null
    action_user?: UserAction
    role?: UserRole
    is_can: boolean
    is_company: boolean
    parent_id?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: string | null
    updated_by?: string | null
  }

  export type ActionRoleUpdateInput = {
    action_role_id?: StringFieldUpdateOperationsInput | string
    controller_path?: NullableStringFieldUpdateOperationsInput | string | null
    action_user?: EnumUserActionFieldUpdateOperationsInput | UserAction
    role?: EnumUserRoleFieldUpdateOperationsInput | UserRole
    is_can?: BoolFieldUpdateOperationsInput | boolean
    is_company?: BoolFieldUpdateOperationsInput | boolean
    parent_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ActionRoleUncheckedUpdateInput = {
    action_role_id?: StringFieldUpdateOperationsInput | string
    controller_path?: NullableStringFieldUpdateOperationsInput | string | null
    action_user?: EnumUserActionFieldUpdateOperationsInput | UserAction
    role?: EnumUserRoleFieldUpdateOperationsInput | UserRole
    is_can?: BoolFieldUpdateOperationsInput | boolean
    is_company?: BoolFieldUpdateOperationsInput | boolean
    parent_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ActionRoleCreateManyInput = {
    action_role_id?: string
    controller_path?: string | null
    action_user?: UserAction
    role?: UserRole
    is_can: boolean
    is_company: boolean
    parent_id?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: string | null
    updated_by?: string | null
  }

  export type ActionRoleUpdateManyMutationInput = {
    action_role_id?: StringFieldUpdateOperationsInput | string
    controller_path?: NullableStringFieldUpdateOperationsInput | string | null
    action_user?: EnumUserActionFieldUpdateOperationsInput | UserAction
    role?: EnumUserRoleFieldUpdateOperationsInput | UserRole
    is_can?: BoolFieldUpdateOperationsInput | boolean
    is_company?: BoolFieldUpdateOperationsInput | boolean
    parent_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ActionRoleUncheckedUpdateManyInput = {
    action_role_id?: StringFieldUpdateOperationsInput | string
    controller_path?: NullableStringFieldUpdateOperationsInput | string | null
    action_user?: EnumUserActionFieldUpdateOperationsInput | UserAction
    role?: EnumUserRoleFieldUpdateOperationsInput | UserRole
    is_can?: BoolFieldUpdateOperationsInput | boolean
    is_company?: BoolFieldUpdateOperationsInput | boolean
    parent_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CustomerCreateInput = {
    customer_id?: string
    first_name: string
    last_name: string
    first_name_kana: string
    last_name_kana: string
    gender?: Gender | null
    birth_date?: Date | string | null
    spouse?: NullableJsonNullValueInput | InputJsonValue
    family_size?: number | null
    email?: string | null
    mobile?: string | null
    phone?: string | null
    profile_image?: string | null
    cv_file?: string | null
    resume_file?: string | null
    prefecture?: NullableJsonNullValueInput | InputJsonValue
    post_code?: string | null
    city?: string | null
    district?: string | null
    address?: string | null
    address1?: string | null
    nearest_station?: string | null
    socials?: NullableJsonNullValueInput | InputJsonValue
    country?: string | null
    experienced_year?: number | null
    from_data?: number | null
    status_customer?: CustomerStatus | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: string | null
    updated_by?: string | null
    user?: UserCreateNestedOneWithoutCustomerInput
    customer_visas?: CustomerVisaCreateNestedManyWithoutCustomerInput
    customer_jobdetails?: CustomerJobDetailCreateNestedManyWithoutCustomerInput
    customer_educations?: CustomerEducationCreateNestedManyWithoutCustomerInput
    customer_languages?: CustomerLanguageCreateNestedManyWithoutCustomerInput
    customer_qualifications?: CustomerQualificationCreateNestedManyWithoutCustomersInput
    customer_workhistories?: CustomerWorkHistoryCreateNestedManyWithoutCustomerInput
    job_candidates?: JobCandidateCreateNestedManyWithoutCustomerInput
    customer_desired?: CustomerDesiredCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateInput = {
    customer_id?: string
    first_name: string
    last_name: string
    first_name_kana: string
    last_name_kana: string
    gender?: Gender | null
    birth_date?: Date | string | null
    spouse?: NullableJsonNullValueInput | InputJsonValue
    family_size?: number | null
    email?: string | null
    mobile?: string | null
    phone?: string | null
    profile_image?: string | null
    cv_file?: string | null
    resume_file?: string | null
    prefecture?: NullableJsonNullValueInput | InputJsonValue
    post_code?: string | null
    city?: string | null
    district?: string | null
    address?: string | null
    address1?: string | null
    nearest_station?: string | null
    socials?: NullableJsonNullValueInput | InputJsonValue
    country?: string | null
    experienced_year?: number | null
    from_data?: number | null
    status_customer?: CustomerStatus | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: string | null
    updated_by?: string | null
    user?: UserUncheckedCreateNestedOneWithoutCustomerInput
    customer_visas?: CustomerVisaUncheckedCreateNestedManyWithoutCustomerInput
    customer_jobdetails?: CustomerJobDetailUncheckedCreateNestedManyWithoutCustomerInput
    customer_educations?: CustomerEducationUncheckedCreateNestedManyWithoutCustomerInput
    customer_languages?: CustomerLanguageUncheckedCreateNestedManyWithoutCustomerInput
    customer_qualifications?: CustomerQualificationUncheckedCreateNestedManyWithoutCustomersInput
    customer_workhistories?: CustomerWorkHistoryUncheckedCreateNestedManyWithoutCustomerInput
    job_candidates?: JobCandidateUncheckedCreateNestedManyWithoutCustomerInput
    customer_desired?: CustomerDesiredUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUpdateInput = {
    customer_id?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    first_name_kana?: StringFieldUpdateOperationsInput | string
    last_name_kana?: StringFieldUpdateOperationsInput | string
    gender?: NullableEnumGenderFieldUpdateOperationsInput | Gender | null
    birth_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    spouse?: NullableJsonNullValueInput | InputJsonValue
    family_size?: NullableIntFieldUpdateOperationsInput | number | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profile_image?: NullableStringFieldUpdateOperationsInput | string | null
    cv_file?: NullableStringFieldUpdateOperationsInput | string | null
    resume_file?: NullableStringFieldUpdateOperationsInput | string | null
    prefecture?: NullableJsonNullValueInput | InputJsonValue
    post_code?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    address1?: NullableStringFieldUpdateOperationsInput | string | null
    nearest_station?: NullableStringFieldUpdateOperationsInput | string | null
    socials?: NullableJsonNullValueInput | InputJsonValue
    country?: NullableStringFieldUpdateOperationsInput | string | null
    experienced_year?: NullableIntFieldUpdateOperationsInput | number | null
    from_data?: NullableIntFieldUpdateOperationsInput | number | null
    status_customer?: NullableEnumCustomerStatusFieldUpdateOperationsInput | CustomerStatus | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneWithoutCustomerNestedInput
    customer_visas?: CustomerVisaUpdateManyWithoutCustomerNestedInput
    customer_jobdetails?: CustomerJobDetailUpdateManyWithoutCustomerNestedInput
    customer_educations?: CustomerEducationUpdateManyWithoutCustomerNestedInput
    customer_languages?: CustomerLanguageUpdateManyWithoutCustomerNestedInput
    customer_qualifications?: CustomerQualificationUpdateManyWithoutCustomersNestedInput
    customer_workhistories?: CustomerWorkHistoryUpdateManyWithoutCustomerNestedInput
    job_candidates?: JobCandidateUpdateManyWithoutCustomerNestedInput
    customer_desired?: CustomerDesiredUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateInput = {
    customer_id?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    first_name_kana?: StringFieldUpdateOperationsInput | string
    last_name_kana?: StringFieldUpdateOperationsInput | string
    gender?: NullableEnumGenderFieldUpdateOperationsInput | Gender | null
    birth_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    spouse?: NullableJsonNullValueInput | InputJsonValue
    family_size?: NullableIntFieldUpdateOperationsInput | number | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profile_image?: NullableStringFieldUpdateOperationsInput | string | null
    cv_file?: NullableStringFieldUpdateOperationsInput | string | null
    resume_file?: NullableStringFieldUpdateOperationsInput | string | null
    prefecture?: NullableJsonNullValueInput | InputJsonValue
    post_code?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    address1?: NullableStringFieldUpdateOperationsInput | string | null
    nearest_station?: NullableStringFieldUpdateOperationsInput | string | null
    socials?: NullableJsonNullValueInput | InputJsonValue
    country?: NullableStringFieldUpdateOperationsInput | string | null
    experienced_year?: NullableIntFieldUpdateOperationsInput | number | null
    from_data?: NullableIntFieldUpdateOperationsInput | number | null
    status_customer?: NullableEnumCustomerStatusFieldUpdateOperationsInput | CustomerStatus | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUncheckedUpdateOneWithoutCustomerNestedInput
    customer_visas?: CustomerVisaUncheckedUpdateManyWithoutCustomerNestedInput
    customer_jobdetails?: CustomerJobDetailUncheckedUpdateManyWithoutCustomerNestedInput
    customer_educations?: CustomerEducationUncheckedUpdateManyWithoutCustomerNestedInput
    customer_languages?: CustomerLanguageUncheckedUpdateManyWithoutCustomerNestedInput
    customer_qualifications?: CustomerQualificationUncheckedUpdateManyWithoutCustomersNestedInput
    customer_workhistories?: CustomerWorkHistoryUncheckedUpdateManyWithoutCustomerNestedInput
    job_candidates?: JobCandidateUncheckedUpdateManyWithoutCustomerNestedInput
    customer_desired?: CustomerDesiredUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerCreateManyInput = {
    customer_id?: string
    first_name: string
    last_name: string
    first_name_kana: string
    last_name_kana: string
    gender?: Gender | null
    birth_date?: Date | string | null
    spouse?: NullableJsonNullValueInput | InputJsonValue
    family_size?: number | null
    email?: string | null
    mobile?: string | null
    phone?: string | null
    profile_image?: string | null
    cv_file?: string | null
    resume_file?: string | null
    prefecture?: NullableJsonNullValueInput | InputJsonValue
    post_code?: string | null
    city?: string | null
    district?: string | null
    address?: string | null
    address1?: string | null
    nearest_station?: string | null
    socials?: NullableJsonNullValueInput | InputJsonValue
    country?: string | null
    experienced_year?: number | null
    from_data?: number | null
    status_customer?: CustomerStatus | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: string | null
    updated_by?: string | null
  }

  export type CustomerUpdateManyMutationInput = {
    customer_id?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    first_name_kana?: StringFieldUpdateOperationsInput | string
    last_name_kana?: StringFieldUpdateOperationsInput | string
    gender?: NullableEnumGenderFieldUpdateOperationsInput | Gender | null
    birth_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    spouse?: NullableJsonNullValueInput | InputJsonValue
    family_size?: NullableIntFieldUpdateOperationsInput | number | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profile_image?: NullableStringFieldUpdateOperationsInput | string | null
    cv_file?: NullableStringFieldUpdateOperationsInput | string | null
    resume_file?: NullableStringFieldUpdateOperationsInput | string | null
    prefecture?: NullableJsonNullValueInput | InputJsonValue
    post_code?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    address1?: NullableStringFieldUpdateOperationsInput | string | null
    nearest_station?: NullableStringFieldUpdateOperationsInput | string | null
    socials?: NullableJsonNullValueInput | InputJsonValue
    country?: NullableStringFieldUpdateOperationsInput | string | null
    experienced_year?: NullableIntFieldUpdateOperationsInput | number | null
    from_data?: NullableIntFieldUpdateOperationsInput | number | null
    status_customer?: NullableEnumCustomerStatusFieldUpdateOperationsInput | CustomerStatus | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CustomerUncheckedUpdateManyInput = {
    customer_id?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    first_name_kana?: StringFieldUpdateOperationsInput | string
    last_name_kana?: StringFieldUpdateOperationsInput | string
    gender?: NullableEnumGenderFieldUpdateOperationsInput | Gender | null
    birth_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    spouse?: NullableJsonNullValueInput | InputJsonValue
    family_size?: NullableIntFieldUpdateOperationsInput | number | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profile_image?: NullableStringFieldUpdateOperationsInput | string | null
    cv_file?: NullableStringFieldUpdateOperationsInput | string | null
    resume_file?: NullableStringFieldUpdateOperationsInput | string | null
    prefecture?: NullableJsonNullValueInput | InputJsonValue
    post_code?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    address1?: NullableStringFieldUpdateOperationsInput | string | null
    nearest_station?: NullableStringFieldUpdateOperationsInput | string | null
    socials?: NullableJsonNullValueInput | InputJsonValue
    country?: NullableStringFieldUpdateOperationsInput | string | null
    experienced_year?: NullableIntFieldUpdateOperationsInput | number | null
    from_data?: NullableIntFieldUpdateOperationsInput | number | null
    status_customer?: NullableEnumCustomerStatusFieldUpdateOperationsInput | CustomerStatus | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CustomerDesiredCreateInput = {
    desired_id?: string
    customer?: CustomerCreateNestedOneWithoutCustomer_desiredInput
    occupation?: CustomerDesiredCreateoccupationInput | Enumerable<InputJsonValue>
    industry?: CustomerDesiredCreateindustryInput | Enumerable<InputJsonValue>
    location?: CustomerDesiredCreatelocationInput | Enumerable<InputJsonValue>
    career_level?: CustomerDesiredCreatecareer_levelInput | Enumerable<InputJsonValue>
    contract_type?: CustomerDesiredCreatecontract_typeInput | Enumerable<InputJsonValue>
    desired_company?: CustomerDesiredCreatedesired_companyInput | Enumerable<InputJsonValue>
    time_to: string
    annual_income: number
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: string | null
    updated_by?: string | null
  }

  export type CustomerDesiredUncheckedCreateInput = {
    desired_id?: string
    customer_id?: string | null
    occupation?: CustomerDesiredCreateoccupationInput | Enumerable<InputJsonValue>
    industry?: CustomerDesiredCreateindustryInput | Enumerable<InputJsonValue>
    location?: CustomerDesiredCreatelocationInput | Enumerable<InputJsonValue>
    career_level?: CustomerDesiredCreatecareer_levelInput | Enumerable<InputJsonValue>
    contract_type?: CustomerDesiredCreatecontract_typeInput | Enumerable<InputJsonValue>
    desired_company?: CustomerDesiredCreatedesired_companyInput | Enumerable<InputJsonValue>
    time_to: string
    annual_income: number
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: string | null
    updated_by?: string | null
  }

  export type CustomerDesiredUpdateInput = {
    desired_id?: StringFieldUpdateOperationsInput | string
    customer?: CustomerUpdateOneWithoutCustomer_desiredNestedInput
    occupation?: CustomerDesiredUpdateoccupationInput | Enumerable<InputJsonValue>
    industry?: CustomerDesiredUpdateindustryInput | Enumerable<InputJsonValue>
    location?: CustomerDesiredUpdatelocationInput | Enumerable<InputJsonValue>
    career_level?: CustomerDesiredUpdatecareer_levelInput | Enumerable<InputJsonValue>
    contract_type?: CustomerDesiredUpdatecontract_typeInput | Enumerable<InputJsonValue>
    desired_company?: CustomerDesiredUpdatedesired_companyInput | Enumerable<InputJsonValue>
    time_to?: StringFieldUpdateOperationsInput | string
    annual_income?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CustomerDesiredUncheckedUpdateInput = {
    desired_id?: StringFieldUpdateOperationsInput | string
    customer_id?: NullableStringFieldUpdateOperationsInput | string | null
    occupation?: CustomerDesiredUpdateoccupationInput | Enumerable<InputJsonValue>
    industry?: CustomerDesiredUpdateindustryInput | Enumerable<InputJsonValue>
    location?: CustomerDesiredUpdatelocationInput | Enumerable<InputJsonValue>
    career_level?: CustomerDesiredUpdatecareer_levelInput | Enumerable<InputJsonValue>
    contract_type?: CustomerDesiredUpdatecontract_typeInput | Enumerable<InputJsonValue>
    desired_company?: CustomerDesiredUpdatedesired_companyInput | Enumerable<InputJsonValue>
    time_to?: StringFieldUpdateOperationsInput | string
    annual_income?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CustomerDesiredCreateManyInput = {
    desired_id?: string
    customer_id?: string | null
    occupation?: CustomerDesiredCreateoccupationInput | Enumerable<InputJsonValue>
    industry?: CustomerDesiredCreateindustryInput | Enumerable<InputJsonValue>
    location?: CustomerDesiredCreatelocationInput | Enumerable<InputJsonValue>
    career_level?: CustomerDesiredCreatecareer_levelInput | Enumerable<InputJsonValue>
    contract_type?: CustomerDesiredCreatecontract_typeInput | Enumerable<InputJsonValue>
    desired_company?: CustomerDesiredCreatedesired_companyInput | Enumerable<InputJsonValue>
    time_to: string
    annual_income: number
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: string | null
    updated_by?: string | null
  }

  export type CustomerDesiredUpdateManyMutationInput = {
    desired_id?: StringFieldUpdateOperationsInput | string
    occupation?: CustomerDesiredUpdateoccupationInput | Enumerable<InputJsonValue>
    industry?: CustomerDesiredUpdateindustryInput | Enumerable<InputJsonValue>
    location?: CustomerDesiredUpdatelocationInput | Enumerable<InputJsonValue>
    career_level?: CustomerDesiredUpdatecareer_levelInput | Enumerable<InputJsonValue>
    contract_type?: CustomerDesiredUpdatecontract_typeInput | Enumerable<InputJsonValue>
    desired_company?: CustomerDesiredUpdatedesired_companyInput | Enumerable<InputJsonValue>
    time_to?: StringFieldUpdateOperationsInput | string
    annual_income?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CustomerDesiredUncheckedUpdateManyInput = {
    desired_id?: StringFieldUpdateOperationsInput | string
    customer_id?: NullableStringFieldUpdateOperationsInput | string | null
    occupation?: CustomerDesiredUpdateoccupationInput | Enumerable<InputJsonValue>
    industry?: CustomerDesiredUpdateindustryInput | Enumerable<InputJsonValue>
    location?: CustomerDesiredUpdatelocationInput | Enumerable<InputJsonValue>
    career_level?: CustomerDesiredUpdatecareer_levelInput | Enumerable<InputJsonValue>
    contract_type?: CustomerDesiredUpdatecontract_typeInput | Enumerable<InputJsonValue>
    desired_company?: CustomerDesiredUpdatedesired_companyInput | Enumerable<InputJsonValue>
    time_to?: StringFieldUpdateOperationsInput | string
    annual_income?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CustomerEducationCreateInput = {
    education_id?: string
    customer?: CustomerCreateNestedOneWithoutCustomer_educationsInput
    country?: string | null
    degree?: NullableJsonNullValueInput | InputJsonValue
    entrollment_date?: Date | string | null
    graduate_date?: Date | string | null
    is_current?: boolean | null
    school_id?: number | null
    school?: NullableJsonNullValueInput | InputJsonValue
    faculty?: string | null
    department?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: string | null
    updated_by?: string | null
  }

  export type CustomerEducationUncheckedCreateInput = {
    education_id?: string
    customer_id?: string | null
    country?: string | null
    degree?: NullableJsonNullValueInput | InputJsonValue
    entrollment_date?: Date | string | null
    graduate_date?: Date | string | null
    is_current?: boolean | null
    school_id?: number | null
    school?: NullableJsonNullValueInput | InputJsonValue
    faculty?: string | null
    department?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: string | null
    updated_by?: string | null
  }

  export type CustomerEducationUpdateInput = {
    education_id?: StringFieldUpdateOperationsInput | string
    customer?: CustomerUpdateOneWithoutCustomer_educationsNestedInput
    country?: NullableStringFieldUpdateOperationsInput | string | null
    degree?: NullableJsonNullValueInput | InputJsonValue
    entrollment_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    graduate_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_current?: NullableBoolFieldUpdateOperationsInput | boolean | null
    school_id?: NullableIntFieldUpdateOperationsInput | number | null
    school?: NullableJsonNullValueInput | InputJsonValue
    faculty?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CustomerEducationUncheckedUpdateInput = {
    education_id?: StringFieldUpdateOperationsInput | string
    customer_id?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    degree?: NullableJsonNullValueInput | InputJsonValue
    entrollment_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    graduate_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_current?: NullableBoolFieldUpdateOperationsInput | boolean | null
    school_id?: NullableIntFieldUpdateOperationsInput | number | null
    school?: NullableJsonNullValueInput | InputJsonValue
    faculty?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CustomerEducationCreateManyInput = {
    education_id?: string
    customer_id?: string | null
    country?: string | null
    degree?: NullableJsonNullValueInput | InputJsonValue
    entrollment_date?: Date | string | null
    graduate_date?: Date | string | null
    is_current?: boolean | null
    school_id?: number | null
    school?: NullableJsonNullValueInput | InputJsonValue
    faculty?: string | null
    department?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: string | null
    updated_by?: string | null
  }

  export type CustomerEducationUpdateManyMutationInput = {
    education_id?: StringFieldUpdateOperationsInput | string
    country?: NullableStringFieldUpdateOperationsInput | string | null
    degree?: NullableJsonNullValueInput | InputJsonValue
    entrollment_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    graduate_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_current?: NullableBoolFieldUpdateOperationsInput | boolean | null
    school_id?: NullableIntFieldUpdateOperationsInput | number | null
    school?: NullableJsonNullValueInput | InputJsonValue
    faculty?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CustomerEducationUncheckedUpdateManyInput = {
    education_id?: StringFieldUpdateOperationsInput | string
    customer_id?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    degree?: NullableJsonNullValueInput | InputJsonValue
    entrollment_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    graduate_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_current?: NullableBoolFieldUpdateOperationsInput | boolean | null
    school_id?: NullableIntFieldUpdateOperationsInput | number | null
    school?: NullableJsonNullValueInput | InputJsonValue
    faculty?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CustomerExperienceCreateInput = {
    experience_id?: string
    jobdetails: CustomerJobDetailCreateNestedOneWithoutCustomer_experiencesInput
    listitems: ReferenceListItemsCreateNestedOneWithoutCustomer_experiencesInput
    over_year?: number | null
    created_at?: Date | string
    updated_at?: Date | string | null
    created_by?: string | null
    updated_by?: string | null
  }

  export type CustomerExperienceUncheckedCreateInput = {
    experience_id?: string
    jobdetail_id: string
    skill_id: number
    over_year?: number | null
    created_at?: Date | string
    updated_at?: Date | string | null
    created_by?: string | null
    updated_by?: string | null
  }

  export type CustomerExperienceUpdateInput = {
    experience_id?: StringFieldUpdateOperationsInput | string
    jobdetails?: CustomerJobDetailUpdateOneRequiredWithoutCustomer_experiencesNestedInput
    listitems?: ReferenceListItemsUpdateOneRequiredWithoutCustomer_experiencesNestedInput
    over_year?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CustomerExperienceUncheckedUpdateInput = {
    experience_id?: StringFieldUpdateOperationsInput | string
    jobdetail_id?: StringFieldUpdateOperationsInput | string
    skill_id?: IntFieldUpdateOperationsInput | number
    over_year?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CustomerExperienceCreateManyInput = {
    experience_id?: string
    jobdetail_id: string
    skill_id: number
    over_year?: number | null
    created_at?: Date | string
    updated_at?: Date | string | null
    created_by?: string | null
    updated_by?: string | null
  }

  export type CustomerExperienceUpdateManyMutationInput = {
    experience_id?: StringFieldUpdateOperationsInput | string
    over_year?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CustomerExperienceUncheckedUpdateManyInput = {
    experience_id?: StringFieldUpdateOperationsInput | string
    jobdetail_id?: StringFieldUpdateOperationsInput | string
    skill_id?: IntFieldUpdateOperationsInput | number
    over_year?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CustomerJobDetailCreateInput = {
    jobdetail_id?: string
    customer?: CustomerCreateNestedOneWithoutCustomer_jobdetailsInput
    customer_experiences?: CustomerExperienceCreateNestedManyWithoutJobdetailsInput
    experienced_company?: number
    annual_income?: number | null
    has_management_exp?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: string | null
    updated_by?: string | null
  }

  export type CustomerJobDetailUncheckedCreateInput = {
    jobdetail_id?: string
    customer_id?: string | null
    customer_experiences?: CustomerExperienceUncheckedCreateNestedManyWithoutJobdetailsInput
    experienced_company?: number
    annual_income?: number | null
    has_management_exp?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: string | null
    updated_by?: string | null
  }

  export type CustomerJobDetailUpdateInput = {
    jobdetail_id?: StringFieldUpdateOperationsInput | string
    customer?: CustomerUpdateOneWithoutCustomer_jobdetailsNestedInput
    customer_experiences?: CustomerExperienceUpdateManyWithoutJobdetailsNestedInput
    experienced_company?: IntFieldUpdateOperationsInput | number
    annual_income?: NullableIntFieldUpdateOperationsInput | number | null
    has_management_exp?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CustomerJobDetailUncheckedUpdateInput = {
    jobdetail_id?: StringFieldUpdateOperationsInput | string
    customer_id?: NullableStringFieldUpdateOperationsInput | string | null
    customer_experiences?: CustomerExperienceUncheckedUpdateManyWithoutJobdetailsNestedInput
    experienced_company?: IntFieldUpdateOperationsInput | number
    annual_income?: NullableIntFieldUpdateOperationsInput | number | null
    has_management_exp?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CustomerJobDetailCreateManyInput = {
    jobdetail_id?: string
    customer_id?: string | null
    experienced_company?: number
    annual_income?: number | null
    has_management_exp?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: string | null
    updated_by?: string | null
  }

  export type CustomerJobDetailUpdateManyMutationInput = {
    jobdetail_id?: StringFieldUpdateOperationsInput | string
    experienced_company?: IntFieldUpdateOperationsInput | number
    annual_income?: NullableIntFieldUpdateOperationsInput | number | null
    has_management_exp?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CustomerJobDetailUncheckedUpdateManyInput = {
    jobdetail_id?: StringFieldUpdateOperationsInput | string
    customer_id?: NullableStringFieldUpdateOperationsInput | string | null
    experienced_company?: IntFieldUpdateOperationsInput | number
    annual_income?: NullableIntFieldUpdateOperationsInput | number | null
    has_management_exp?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CustomerLanguageCreateInput = {
    language_id?: string
    customer: CustomerCreateNestedOneWithoutCustomer_languagesInput
    level?: LanguageLevel | null
    language?: number | null
    is_motherlanguage?: boolean
    certificate?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string | null
    created_by?: string | null
    updated_b?: string | null
  }

  export type CustomerLanguageUncheckedCreateInput = {
    language_id?: string
    customer_id: string
    level?: LanguageLevel | null
    language?: number | null
    is_motherlanguage?: boolean
    certificate?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string | null
    created_by?: string | null
    updated_b?: string | null
  }

  export type CustomerLanguageUpdateInput = {
    language_id?: StringFieldUpdateOperationsInput | string
    customer?: CustomerUpdateOneRequiredWithoutCustomer_languagesNestedInput
    level?: NullableEnumLanguageLevelFieldUpdateOperationsInput | LanguageLevel | null
    language?: NullableIntFieldUpdateOperationsInput | number | null
    is_motherlanguage?: BoolFieldUpdateOperationsInput | boolean
    certificate?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_b?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CustomerLanguageUncheckedUpdateInput = {
    language_id?: StringFieldUpdateOperationsInput | string
    customer_id?: StringFieldUpdateOperationsInput | string
    level?: NullableEnumLanguageLevelFieldUpdateOperationsInput | LanguageLevel | null
    language?: NullableIntFieldUpdateOperationsInput | number | null
    is_motherlanguage?: BoolFieldUpdateOperationsInput | boolean
    certificate?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_b?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CustomerLanguageCreateManyInput = {
    language_id?: string
    customer_id: string
    level?: LanguageLevel | null
    language?: number | null
    is_motherlanguage?: boolean
    certificate?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string | null
    created_by?: string | null
    updated_b?: string | null
  }

  export type CustomerLanguageUpdateManyMutationInput = {
    language_id?: StringFieldUpdateOperationsInput | string
    level?: NullableEnumLanguageLevelFieldUpdateOperationsInput | LanguageLevel | null
    language?: NullableIntFieldUpdateOperationsInput | number | null
    is_motherlanguage?: BoolFieldUpdateOperationsInput | boolean
    certificate?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_b?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CustomerLanguageUncheckedUpdateManyInput = {
    language_id?: StringFieldUpdateOperationsInput | string
    customer_id?: StringFieldUpdateOperationsInput | string
    level?: NullableEnumLanguageLevelFieldUpdateOperationsInput | LanguageLevel | null
    language?: NullableIntFieldUpdateOperationsInput | number | null
    is_motherlanguage?: BoolFieldUpdateOperationsInput | boolean
    certificate?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_b?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CustomerQualificationCreateInput = {
    qualification_id?: string
    customers: CustomerCreateNestedOneWithoutCustomer_qualificationsInput
    qualification?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: string | null
    updated_by?: string | null
  }

  export type CustomerQualificationUncheckedCreateInput = {
    qualification_id?: string
    customer_id: string
    qualification?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: string | null
    updated_by?: string | null
  }

  export type CustomerQualificationUpdateInput = {
    qualification_id?: StringFieldUpdateOperationsInput | string
    customers?: CustomerUpdateOneRequiredWithoutCustomer_qualificationsNestedInput
    qualification?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CustomerQualificationUncheckedUpdateInput = {
    qualification_id?: StringFieldUpdateOperationsInput | string
    customer_id?: StringFieldUpdateOperationsInput | string
    qualification?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CustomerQualificationCreateManyInput = {
    qualification_id?: string
    customer_id: string
    qualification?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: string | null
    updated_by?: string | null
  }

  export type CustomerQualificationUpdateManyMutationInput = {
    qualification_id?: StringFieldUpdateOperationsInput | string
    qualification?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CustomerQualificationUncheckedUpdateManyInput = {
    qualification_id?: StringFieldUpdateOperationsInput | string
    customer_id?: StringFieldUpdateOperationsInput | string
    qualification?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CustomerVisaCreateInput = {
    visa_id?: string
    customer: CustomerCreateNestedOneWithoutCustomer_visasInput
    status_visa?: StatusVisa | null
    date_expire?: Date | string | null
    country_citizenship?: string | null
    back_visafile?: string | null
    front_visafile?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: string | null
    updated_by?: string | null
  }

  export type CustomerVisaUncheckedCreateInput = {
    visa_id?: string
    customer_id: string
    status_visa?: StatusVisa | null
    date_expire?: Date | string | null
    country_citizenship?: string | null
    back_visafile?: string | null
    front_visafile?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: string | null
    updated_by?: string | null
  }

  export type CustomerVisaUpdateInput = {
    visa_id?: StringFieldUpdateOperationsInput | string
    customer?: CustomerUpdateOneRequiredWithoutCustomer_visasNestedInput
    status_visa?: NullableEnumStatusVisaFieldUpdateOperationsInput | StatusVisa | null
    date_expire?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    country_citizenship?: NullableStringFieldUpdateOperationsInput | string | null
    back_visafile?: NullableStringFieldUpdateOperationsInput | string | null
    front_visafile?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CustomerVisaUncheckedUpdateInput = {
    visa_id?: StringFieldUpdateOperationsInput | string
    customer_id?: StringFieldUpdateOperationsInput | string
    status_visa?: NullableEnumStatusVisaFieldUpdateOperationsInput | StatusVisa | null
    date_expire?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    country_citizenship?: NullableStringFieldUpdateOperationsInput | string | null
    back_visafile?: NullableStringFieldUpdateOperationsInput | string | null
    front_visafile?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CustomerVisaCreateManyInput = {
    visa_id?: string
    customer_id: string
    status_visa?: StatusVisa | null
    date_expire?: Date | string | null
    country_citizenship?: string | null
    back_visafile?: string | null
    front_visafile?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: string | null
    updated_by?: string | null
  }

  export type CustomerVisaUpdateManyMutationInput = {
    visa_id?: StringFieldUpdateOperationsInput | string
    status_visa?: NullableEnumStatusVisaFieldUpdateOperationsInput | StatusVisa | null
    date_expire?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    country_citizenship?: NullableStringFieldUpdateOperationsInput | string | null
    back_visafile?: NullableStringFieldUpdateOperationsInput | string | null
    front_visafile?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CustomerVisaUncheckedUpdateManyInput = {
    visa_id?: StringFieldUpdateOperationsInput | string
    customer_id?: StringFieldUpdateOperationsInput | string
    status_visa?: NullableEnumStatusVisaFieldUpdateOperationsInput | StatusVisa | null
    date_expire?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    country_citizenship?: NullableStringFieldUpdateOperationsInput | string | null
    back_visafile?: NullableStringFieldUpdateOperationsInput | string | null
    front_visafile?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CustomerWorkHistoryCreateInput = {
    workhistory_id?: string
    customer: CustomerCreateNestedOneWithoutCustomer_workhistoriesInput
    company_id?: string | null
    company_info?: NullableJsonNullValueInput | InputJsonValue
    occupation?: NullableJsonNullValueInput | InputJsonValue
    industry?: NullableJsonNullValueInput | InputJsonValue
    position?: JobPosition | null
    enter_date?: Date | string | null
    leave_date?: Date | string | null
    working_month?: number | null
    is_current?: boolean | null
    duties?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: string | null
    updated_by?: string | null
  }

  export type CustomerWorkHistoryUncheckedCreateInput = {
    workhistory_id?: string
    customer_id: string
    company_id?: string | null
    company_info?: NullableJsonNullValueInput | InputJsonValue
    occupation?: NullableJsonNullValueInput | InputJsonValue
    industry?: NullableJsonNullValueInput | InputJsonValue
    position?: JobPosition | null
    enter_date?: Date | string | null
    leave_date?: Date | string | null
    working_month?: number | null
    is_current?: boolean | null
    duties?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: string | null
    updated_by?: string | null
  }

  export type CustomerWorkHistoryUpdateInput = {
    workhistory_id?: StringFieldUpdateOperationsInput | string
    customer?: CustomerUpdateOneRequiredWithoutCustomer_workhistoriesNestedInput
    company_id?: NullableStringFieldUpdateOperationsInput | string | null
    company_info?: NullableJsonNullValueInput | InputJsonValue
    occupation?: NullableJsonNullValueInput | InputJsonValue
    industry?: NullableJsonNullValueInput | InputJsonValue
    position?: NullableEnumJobPositionFieldUpdateOperationsInput | JobPosition | null
    enter_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    leave_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    working_month?: NullableIntFieldUpdateOperationsInput | number | null
    is_current?: NullableBoolFieldUpdateOperationsInput | boolean | null
    duties?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CustomerWorkHistoryUncheckedUpdateInput = {
    workhistory_id?: StringFieldUpdateOperationsInput | string
    customer_id?: StringFieldUpdateOperationsInput | string
    company_id?: NullableStringFieldUpdateOperationsInput | string | null
    company_info?: NullableJsonNullValueInput | InputJsonValue
    occupation?: NullableJsonNullValueInput | InputJsonValue
    industry?: NullableJsonNullValueInput | InputJsonValue
    position?: NullableEnumJobPositionFieldUpdateOperationsInput | JobPosition | null
    enter_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    leave_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    working_month?: NullableIntFieldUpdateOperationsInput | number | null
    is_current?: NullableBoolFieldUpdateOperationsInput | boolean | null
    duties?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CustomerWorkHistoryCreateManyInput = {
    workhistory_id?: string
    customer_id: string
    company_id?: string | null
    company_info?: NullableJsonNullValueInput | InputJsonValue
    occupation?: NullableJsonNullValueInput | InputJsonValue
    industry?: NullableJsonNullValueInput | InputJsonValue
    position?: JobPosition | null
    enter_date?: Date | string | null
    leave_date?: Date | string | null
    working_month?: number | null
    is_current?: boolean | null
    duties?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: string | null
    updated_by?: string | null
  }

  export type CustomerWorkHistoryUpdateManyMutationInput = {
    workhistory_id?: StringFieldUpdateOperationsInput | string
    company_id?: NullableStringFieldUpdateOperationsInput | string | null
    company_info?: NullableJsonNullValueInput | InputJsonValue
    occupation?: NullableJsonNullValueInput | InputJsonValue
    industry?: NullableJsonNullValueInput | InputJsonValue
    position?: NullableEnumJobPositionFieldUpdateOperationsInput | JobPosition | null
    enter_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    leave_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    working_month?: NullableIntFieldUpdateOperationsInput | number | null
    is_current?: NullableBoolFieldUpdateOperationsInput | boolean | null
    duties?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CustomerWorkHistoryUncheckedUpdateManyInput = {
    workhistory_id?: StringFieldUpdateOperationsInput | string
    customer_id?: StringFieldUpdateOperationsInput | string
    company_id?: NullableStringFieldUpdateOperationsInput | string | null
    company_info?: NullableJsonNullValueInput | InputJsonValue
    occupation?: NullableJsonNullValueInput | InputJsonValue
    industry?: NullableJsonNullValueInput | InputJsonValue
    position?: NullableEnumJobPositionFieldUpdateOperationsInput | JobPosition | null
    enter_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    leave_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    working_month?: NullableIntFieldUpdateOperationsInput | number | null
    is_current?: NullableBoolFieldUpdateOperationsInput | boolean | null
    duties?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DictionaryCreateInput = {
    dictionaries_id?: string
    dictionary_id: number
    language_code: string
    dic_value: string
    created_at?: Date | string
    reference_listitems?: ReferenceListItemsCreateNestedManyWithoutDictionaryInput
  }

  export type DictionaryUncheckedCreateInput = {
    dictionaries_id?: string
    dictionary_id: number
    language_code: string
    dic_value: string
    created_at?: Date | string
    reference_listitems?: ReferenceListItemsUncheckedCreateNestedManyWithoutDictionaryInput
  }

  export type DictionaryUpdateInput = {
    dictionaries_id?: StringFieldUpdateOperationsInput | string
    dictionary_id?: IntFieldUpdateOperationsInput | number
    language_code?: StringFieldUpdateOperationsInput | string
    dic_value?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    reference_listitems?: ReferenceListItemsUpdateManyWithoutDictionaryNestedInput
  }

  export type DictionaryUncheckedUpdateInput = {
    dictionaries_id?: StringFieldUpdateOperationsInput | string
    dictionary_id?: IntFieldUpdateOperationsInput | number
    language_code?: StringFieldUpdateOperationsInput | string
    dic_value?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    reference_listitems?: ReferenceListItemsUncheckedUpdateManyWithoutDictionaryNestedInput
  }

  export type DictionaryCreateManyInput = {
    dictionaries_id?: string
    dictionary_id: number
    language_code: string
    dic_value: string
    created_at?: Date | string
  }

  export type DictionaryUpdateManyMutationInput = {
    dictionaries_id?: StringFieldUpdateOperationsInput | string
    dictionary_id?: IntFieldUpdateOperationsInput | number
    language_code?: StringFieldUpdateOperationsInput | string
    dic_value?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DictionaryUncheckedUpdateManyInput = {
    dictionaries_id?: StringFieldUpdateOperationsInput | string
    dictionary_id?: IntFieldUpdateOperationsInput | number
    language_code?: StringFieldUpdateOperationsInput | string
    dic_value?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EntityCreateInput = {
    name: string
    kana?: string | null
    logo?: string | null
    socials?: NullableJsonNullValueInput | InputJsonValue
    gps?: NullableJsonNullValueInput | InputJsonValue
    contact_person?: NullableJsonNullValueInput | InputJsonValue
    contact_details?: NullableJsonNullValueInput | InputJsonValue
    is_system?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: string | null
    updated_by?: string | null
    entity_details?: EntityDetailCreateNestedManyWithoutEntityInput
    entity_branches?: EntityBranchCreateNestedManyWithoutEntityInput
    entity_accountinfos?: EntityAccountInfoCreateNestedManyWithoutEntityInput
    inquiries?: InquiryCreateNestedManyWithoutEntityInput
  }

  export type EntityUncheckedCreateInput = {
    entity_id?: number
    name: string
    kana?: string | null
    logo?: string | null
    socials?: NullableJsonNullValueInput | InputJsonValue
    gps?: NullableJsonNullValueInput | InputJsonValue
    contact_person?: NullableJsonNullValueInput | InputJsonValue
    contact_details?: NullableJsonNullValueInput | InputJsonValue
    is_system?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: string | null
    updated_by?: string | null
    entity_details?: EntityDetailUncheckedCreateNestedManyWithoutEntityInput
    entity_branches?: EntityBranchUncheckedCreateNestedManyWithoutEntityInput
    entity_accountinfos?: EntityAccountInfoUncheckedCreateNestedManyWithoutEntityInput
    inquiries?: InquiryUncheckedCreateNestedManyWithoutEntityInput
  }

  export type EntityUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    kana?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    socials?: NullableJsonNullValueInput | InputJsonValue
    gps?: NullableJsonNullValueInput | InputJsonValue
    contact_person?: NullableJsonNullValueInput | InputJsonValue
    contact_details?: NullableJsonNullValueInput | InputJsonValue
    is_system?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    entity_details?: EntityDetailUpdateManyWithoutEntityNestedInput
    entity_branches?: EntityBranchUpdateManyWithoutEntityNestedInput
    entity_accountinfos?: EntityAccountInfoUpdateManyWithoutEntityNestedInput
    inquiries?: InquiryUpdateManyWithoutEntityNestedInput
  }

  export type EntityUncheckedUpdateInput = {
    entity_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    kana?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    socials?: NullableJsonNullValueInput | InputJsonValue
    gps?: NullableJsonNullValueInput | InputJsonValue
    contact_person?: NullableJsonNullValueInput | InputJsonValue
    contact_details?: NullableJsonNullValueInput | InputJsonValue
    is_system?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    entity_details?: EntityDetailUncheckedUpdateManyWithoutEntityNestedInput
    entity_branches?: EntityBranchUncheckedUpdateManyWithoutEntityNestedInput
    entity_accountinfos?: EntityAccountInfoUncheckedUpdateManyWithoutEntityNestedInput
    inquiries?: InquiryUncheckedUpdateManyWithoutEntityNestedInput
  }

  export type EntityCreateManyInput = {
    entity_id?: number
    name: string
    kana?: string | null
    logo?: string | null
    socials?: NullableJsonNullValueInput | InputJsonValue
    gps?: NullableJsonNullValueInput | InputJsonValue
    contact_person?: NullableJsonNullValueInput | InputJsonValue
    contact_details?: NullableJsonNullValueInput | InputJsonValue
    is_system?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: string | null
    updated_by?: string | null
  }

  export type EntityUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    kana?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    socials?: NullableJsonNullValueInput | InputJsonValue
    gps?: NullableJsonNullValueInput | InputJsonValue
    contact_person?: NullableJsonNullValueInput | InputJsonValue
    contact_details?: NullableJsonNullValueInput | InputJsonValue
    is_system?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EntityUncheckedUpdateManyInput = {
    entity_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    kana?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    socials?: NullableJsonNullValueInput | InputJsonValue
    gps?: NullableJsonNullValueInput | InputJsonValue
    contact_person?: NullableJsonNullValueInput | InputJsonValue
    contact_details?: NullableJsonNullValueInput | InputJsonValue
    is_system?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EntityAccountInfoCreateInput = {
    entity_accountinfo_id?: string
    entity?: EntityCreateNestedOneWithoutEntity_accountinfosInput
    bank_code?: string | null
    branch_code?: string | null
    account_id?: string | null
    is_default?: boolean | null
    created_at?: Date | string
    updated_at?: Date | string
    updated_by?: string | null
    created_by?: string | null
  }

  export type EntityAccountInfoUncheckedCreateInput = {
    entity_accountinfo_id?: string
    entity_id?: number | null
    bank_code?: string | null
    branch_code?: string | null
    account_id?: string | null
    is_default?: boolean | null
    created_at?: Date | string
    updated_at?: Date | string
    updated_by?: string | null
    created_by?: string | null
  }

  export type EntityAccountInfoUpdateInput = {
    entity_accountinfo_id?: StringFieldUpdateOperationsInput | string
    entity?: EntityUpdateOneWithoutEntity_accountinfosNestedInput
    bank_code?: NullableStringFieldUpdateOperationsInput | string | null
    branch_code?: NullableStringFieldUpdateOperationsInput | string | null
    account_id?: NullableStringFieldUpdateOperationsInput | string | null
    is_default?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EntityAccountInfoUncheckedUpdateInput = {
    entity_accountinfo_id?: StringFieldUpdateOperationsInput | string
    entity_id?: NullableIntFieldUpdateOperationsInput | number | null
    bank_code?: NullableStringFieldUpdateOperationsInput | string | null
    branch_code?: NullableStringFieldUpdateOperationsInput | string | null
    account_id?: NullableStringFieldUpdateOperationsInput | string | null
    is_default?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EntityAccountInfoCreateManyInput = {
    entity_accountinfo_id?: string
    entity_id?: number | null
    bank_code?: string | null
    branch_code?: string | null
    account_id?: string | null
    is_default?: boolean | null
    created_at?: Date | string
    updated_at?: Date | string
    updated_by?: string | null
    created_by?: string | null
  }

  export type EntityAccountInfoUpdateManyMutationInput = {
    entity_accountinfo_id?: StringFieldUpdateOperationsInput | string
    bank_code?: NullableStringFieldUpdateOperationsInput | string | null
    branch_code?: NullableStringFieldUpdateOperationsInput | string | null
    account_id?: NullableStringFieldUpdateOperationsInput | string | null
    is_default?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EntityAccountInfoUncheckedUpdateManyInput = {
    entity_accountinfo_id?: StringFieldUpdateOperationsInput | string
    entity_id?: NullableIntFieldUpdateOperationsInput | number | null
    bank_code?: NullableStringFieldUpdateOperationsInput | string | null
    branch_code?: NullableStringFieldUpdateOperationsInput | string | null
    account_id?: NullableStringFieldUpdateOperationsInput | string | null
    is_default?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EntityBranchCreateInput = {
    branch_name?: string | null
    kana?: string | null
    is_jeadquarter?: boolean
    image?: string | null
    prefecture?: NullableJsonNullValueInput | InputJsonValue
    post_code?: string | null
    city?: string | null
    district?: string | null
    address?: string | null
    address1?: string | null
    nearest_station?: string | null
    socials?: NullableJsonNullValueInput | InputJsonValue
    gps?: NullableJsonNullValueInput | InputJsonValue
    contact_person?: NullableJsonNullValueInput | InputJsonValue
    contact_details?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: string | null
    updated_by?: string | null
    entity: EntityCreateNestedOneWithoutEntity_branchesInput
    jobs?: JobCreateNestedManyWithoutEntity_branchInput
  }

  export type EntityBranchUncheckedCreateInput = {
    branch_id?: number
    branch_name?: string | null
    kana?: string | null
    is_jeadquarter?: boolean
    image?: string | null
    prefecture?: NullableJsonNullValueInput | InputJsonValue
    post_code?: string | null
    city?: string | null
    district?: string | null
    address?: string | null
    address1?: string | null
    nearest_station?: string | null
    socials?: NullableJsonNullValueInput | InputJsonValue
    gps?: NullableJsonNullValueInput | InputJsonValue
    contact_person?: NullableJsonNullValueInput | InputJsonValue
    contact_details?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: string | null
    updated_by?: string | null
    entity_id: number
    jobs?: JobUncheckedCreateNestedManyWithoutEntity_branchInput
  }

  export type EntityBranchUpdateInput = {
    branch_name?: NullableStringFieldUpdateOperationsInput | string | null
    kana?: NullableStringFieldUpdateOperationsInput | string | null
    is_jeadquarter?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    prefecture?: NullableJsonNullValueInput | InputJsonValue
    post_code?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    address1?: NullableStringFieldUpdateOperationsInput | string | null
    nearest_station?: NullableStringFieldUpdateOperationsInput | string | null
    socials?: NullableJsonNullValueInput | InputJsonValue
    gps?: NullableJsonNullValueInput | InputJsonValue
    contact_person?: NullableJsonNullValueInput | InputJsonValue
    contact_details?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    entity?: EntityUpdateOneRequiredWithoutEntity_branchesNestedInput
    jobs?: JobUpdateManyWithoutEntity_branchNestedInput
  }

  export type EntityBranchUncheckedUpdateInput = {
    branch_id?: IntFieldUpdateOperationsInput | number
    branch_name?: NullableStringFieldUpdateOperationsInput | string | null
    kana?: NullableStringFieldUpdateOperationsInput | string | null
    is_jeadquarter?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    prefecture?: NullableJsonNullValueInput | InputJsonValue
    post_code?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    address1?: NullableStringFieldUpdateOperationsInput | string | null
    nearest_station?: NullableStringFieldUpdateOperationsInput | string | null
    socials?: NullableJsonNullValueInput | InputJsonValue
    gps?: NullableJsonNullValueInput | InputJsonValue
    contact_person?: NullableJsonNullValueInput | InputJsonValue
    contact_details?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    entity_id?: IntFieldUpdateOperationsInput | number
    jobs?: JobUncheckedUpdateManyWithoutEntity_branchNestedInput
  }

  export type EntityBranchCreateManyInput = {
    branch_id?: number
    branch_name?: string | null
    kana?: string | null
    is_jeadquarter?: boolean
    image?: string | null
    prefecture?: NullableJsonNullValueInput | InputJsonValue
    post_code?: string | null
    city?: string | null
    district?: string | null
    address?: string | null
    address1?: string | null
    nearest_station?: string | null
    socials?: NullableJsonNullValueInput | InputJsonValue
    gps?: NullableJsonNullValueInput | InputJsonValue
    contact_person?: NullableJsonNullValueInput | InputJsonValue
    contact_details?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: string | null
    updated_by?: string | null
    entity_id: number
  }

  export type EntityBranchUpdateManyMutationInput = {
    branch_name?: NullableStringFieldUpdateOperationsInput | string | null
    kana?: NullableStringFieldUpdateOperationsInput | string | null
    is_jeadquarter?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    prefecture?: NullableJsonNullValueInput | InputJsonValue
    post_code?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    address1?: NullableStringFieldUpdateOperationsInput | string | null
    nearest_station?: NullableStringFieldUpdateOperationsInput | string | null
    socials?: NullableJsonNullValueInput | InputJsonValue
    gps?: NullableJsonNullValueInput | InputJsonValue
    contact_person?: NullableJsonNullValueInput | InputJsonValue
    contact_details?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EntityBranchUncheckedUpdateManyInput = {
    branch_id?: IntFieldUpdateOperationsInput | number
    branch_name?: NullableStringFieldUpdateOperationsInput | string | null
    kana?: NullableStringFieldUpdateOperationsInput | string | null
    is_jeadquarter?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    prefecture?: NullableJsonNullValueInput | InputJsonValue
    post_code?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    address1?: NullableStringFieldUpdateOperationsInput | string | null
    nearest_station?: NullableStringFieldUpdateOperationsInput | string | null
    socials?: NullableJsonNullValueInput | InputJsonValue
    gps?: NullableJsonNullValueInput | InputJsonValue
    contact_person?: NullableJsonNullValueInput | InputJsonValue
    contact_details?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    entity_id?: IntFieldUpdateOperationsInput | number
  }

  export type EntityDetailCreateInput = {
    entity_detail_id?: string
    entity?: EntityCreateNestedOneWithoutEntity_detailsInput
    establishment?: Date | string | null
    capital?: number | null
    numberof_employees?: number | null
    business_performance?: NullableJsonNullValueInput | InputJsonValue
    representative_telephone?: string | null
    representative?: string | null
    average_age?: number | null
    foreign_capitalratio?: number | null
    homepage?: string | null
    business_summary?: string | null
    organizational_structure?: string | null
    company_sales?: string | null
    workplace_environment?: string | null
    shareholder?: NullableJsonNullValueInput | InputJsonValue
    related_company?: number | null
    recruitment_personname?: string | null
    memo?: string | null
    business_status?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: string | null
    updated_by?: string | null
  }

  export type EntityDetailUncheckedCreateInput = {
    entity_detail_id?: string
    entity_id?: number | null
    establishment?: Date | string | null
    capital?: number | null
    numberof_employees?: number | null
    business_performance?: NullableJsonNullValueInput | InputJsonValue
    representative_telephone?: string | null
    representative?: string | null
    average_age?: number | null
    foreign_capitalratio?: number | null
    homepage?: string | null
    business_summary?: string | null
    organizational_structure?: string | null
    company_sales?: string | null
    workplace_environment?: string | null
    shareholder?: NullableJsonNullValueInput | InputJsonValue
    related_company?: number | null
    recruitment_personname?: string | null
    memo?: string | null
    business_status?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: string | null
    updated_by?: string | null
  }

  export type EntityDetailUpdateInput = {
    entity_detail_id?: StringFieldUpdateOperationsInput | string
    entity?: EntityUpdateOneWithoutEntity_detailsNestedInput
    establishment?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    capital?: NullableIntFieldUpdateOperationsInput | number | null
    numberof_employees?: NullableIntFieldUpdateOperationsInput | number | null
    business_performance?: NullableJsonNullValueInput | InputJsonValue
    representative_telephone?: NullableStringFieldUpdateOperationsInput | string | null
    representative?: NullableStringFieldUpdateOperationsInput | string | null
    average_age?: NullableIntFieldUpdateOperationsInput | number | null
    foreign_capitalratio?: NullableIntFieldUpdateOperationsInput | number | null
    homepage?: NullableStringFieldUpdateOperationsInput | string | null
    business_summary?: NullableStringFieldUpdateOperationsInput | string | null
    organizational_structure?: NullableStringFieldUpdateOperationsInput | string | null
    company_sales?: NullableStringFieldUpdateOperationsInput | string | null
    workplace_environment?: NullableStringFieldUpdateOperationsInput | string | null
    shareholder?: NullableJsonNullValueInput | InputJsonValue
    related_company?: NullableIntFieldUpdateOperationsInput | number | null
    recruitment_personname?: NullableStringFieldUpdateOperationsInput | string | null
    memo?: NullableStringFieldUpdateOperationsInput | string | null
    business_status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EntityDetailUncheckedUpdateInput = {
    entity_detail_id?: StringFieldUpdateOperationsInput | string
    entity_id?: NullableIntFieldUpdateOperationsInput | number | null
    establishment?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    capital?: NullableIntFieldUpdateOperationsInput | number | null
    numberof_employees?: NullableIntFieldUpdateOperationsInput | number | null
    business_performance?: NullableJsonNullValueInput | InputJsonValue
    representative_telephone?: NullableStringFieldUpdateOperationsInput | string | null
    representative?: NullableStringFieldUpdateOperationsInput | string | null
    average_age?: NullableIntFieldUpdateOperationsInput | number | null
    foreign_capitalratio?: NullableIntFieldUpdateOperationsInput | number | null
    homepage?: NullableStringFieldUpdateOperationsInput | string | null
    business_summary?: NullableStringFieldUpdateOperationsInput | string | null
    organizational_structure?: NullableStringFieldUpdateOperationsInput | string | null
    company_sales?: NullableStringFieldUpdateOperationsInput | string | null
    workplace_environment?: NullableStringFieldUpdateOperationsInput | string | null
    shareholder?: NullableJsonNullValueInput | InputJsonValue
    related_company?: NullableIntFieldUpdateOperationsInput | number | null
    recruitment_personname?: NullableStringFieldUpdateOperationsInput | string | null
    memo?: NullableStringFieldUpdateOperationsInput | string | null
    business_status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EntityDetailCreateManyInput = {
    entity_detail_id?: string
    entity_id?: number | null
    establishment?: Date | string | null
    capital?: number | null
    numberof_employees?: number | null
    business_performance?: NullableJsonNullValueInput | InputJsonValue
    representative_telephone?: string | null
    representative?: string | null
    average_age?: number | null
    foreign_capitalratio?: number | null
    homepage?: string | null
    business_summary?: string | null
    organizational_structure?: string | null
    company_sales?: string | null
    workplace_environment?: string | null
    shareholder?: NullableJsonNullValueInput | InputJsonValue
    related_company?: number | null
    recruitment_personname?: string | null
    memo?: string | null
    business_status?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: string | null
    updated_by?: string | null
  }

  export type EntityDetailUpdateManyMutationInput = {
    entity_detail_id?: StringFieldUpdateOperationsInput | string
    establishment?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    capital?: NullableIntFieldUpdateOperationsInput | number | null
    numberof_employees?: NullableIntFieldUpdateOperationsInput | number | null
    business_performance?: NullableJsonNullValueInput | InputJsonValue
    representative_telephone?: NullableStringFieldUpdateOperationsInput | string | null
    representative?: NullableStringFieldUpdateOperationsInput | string | null
    average_age?: NullableIntFieldUpdateOperationsInput | number | null
    foreign_capitalratio?: NullableIntFieldUpdateOperationsInput | number | null
    homepage?: NullableStringFieldUpdateOperationsInput | string | null
    business_summary?: NullableStringFieldUpdateOperationsInput | string | null
    organizational_structure?: NullableStringFieldUpdateOperationsInput | string | null
    company_sales?: NullableStringFieldUpdateOperationsInput | string | null
    workplace_environment?: NullableStringFieldUpdateOperationsInput | string | null
    shareholder?: NullableJsonNullValueInput | InputJsonValue
    related_company?: NullableIntFieldUpdateOperationsInput | number | null
    recruitment_personname?: NullableStringFieldUpdateOperationsInput | string | null
    memo?: NullableStringFieldUpdateOperationsInput | string | null
    business_status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EntityDetailUncheckedUpdateManyInput = {
    entity_detail_id?: StringFieldUpdateOperationsInput | string
    entity_id?: NullableIntFieldUpdateOperationsInput | number | null
    establishment?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    capital?: NullableIntFieldUpdateOperationsInput | number | null
    numberof_employees?: NullableIntFieldUpdateOperationsInput | number | null
    business_performance?: NullableJsonNullValueInput | InputJsonValue
    representative_telephone?: NullableStringFieldUpdateOperationsInput | string | null
    representative?: NullableStringFieldUpdateOperationsInput | string | null
    average_age?: NullableIntFieldUpdateOperationsInput | number | null
    foreign_capitalratio?: NullableIntFieldUpdateOperationsInput | number | null
    homepage?: NullableStringFieldUpdateOperationsInput | string | null
    business_summary?: NullableStringFieldUpdateOperationsInput | string | null
    organizational_structure?: NullableStringFieldUpdateOperationsInput | string | null
    company_sales?: NullableStringFieldUpdateOperationsInput | string | null
    workplace_environment?: NullableStringFieldUpdateOperationsInput | string | null
    shareholder?: NullableJsonNullValueInput | InputJsonValue
    related_company?: NullableIntFieldUpdateOperationsInput | number | null
    recruitment_personname?: NullableStringFieldUpdateOperationsInput | string | null
    memo?: NullableStringFieldUpdateOperationsInput | string | null
    business_status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FilesCreateInput = {
    file_id?: string
    file_name: string
    target_id: string
    file_path: string
    file_type: FileType
    fiel_source: FileSource
    created_at?: Date | string
    created_by: string
  }

  export type FilesUncheckedCreateInput = {
    file_id?: string
    file_name: string
    target_id: string
    file_path: string
    file_type: FileType
    fiel_source: FileSource
    created_at?: Date | string
    created_by: string
  }

  export type FilesUpdateInput = {
    file_id?: StringFieldUpdateOperationsInput | string
    file_name?: StringFieldUpdateOperationsInput | string
    target_id?: StringFieldUpdateOperationsInput | string
    file_path?: StringFieldUpdateOperationsInput | string
    file_type?: EnumFileTypeFieldUpdateOperationsInput | FileType
    fiel_source?: EnumFileSourceFieldUpdateOperationsInput | FileSource
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: StringFieldUpdateOperationsInput | string
  }

  export type FilesUncheckedUpdateInput = {
    file_id?: StringFieldUpdateOperationsInput | string
    file_name?: StringFieldUpdateOperationsInput | string
    target_id?: StringFieldUpdateOperationsInput | string
    file_path?: StringFieldUpdateOperationsInput | string
    file_type?: EnumFileTypeFieldUpdateOperationsInput | FileType
    fiel_source?: EnumFileSourceFieldUpdateOperationsInput | FileSource
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: StringFieldUpdateOperationsInput | string
  }

  export type FilesCreateManyInput = {
    file_id?: string
    file_name: string
    target_id: string
    file_path: string
    file_type: FileType
    fiel_source: FileSource
    created_at?: Date | string
    created_by: string
  }

  export type FilesUpdateManyMutationInput = {
    file_id?: StringFieldUpdateOperationsInput | string
    file_name?: StringFieldUpdateOperationsInput | string
    target_id?: StringFieldUpdateOperationsInput | string
    file_path?: StringFieldUpdateOperationsInput | string
    file_type?: EnumFileTypeFieldUpdateOperationsInput | FileType
    fiel_source?: EnumFileSourceFieldUpdateOperationsInput | FileSource
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: StringFieldUpdateOperationsInput | string
  }

  export type FilesUncheckedUpdateManyInput = {
    file_id?: StringFieldUpdateOperationsInput | string
    file_name?: StringFieldUpdateOperationsInput | string
    target_id?: StringFieldUpdateOperationsInput | string
    file_path?: StringFieldUpdateOperationsInput | string
    file_type?: EnumFileTypeFieldUpdateOperationsInput | FileType
    fiel_source?: EnumFileSourceFieldUpdateOperationsInput | FileSource
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: StringFieldUpdateOperationsInput | string
  }

  export type InquiryCreateInput = {
    inquire_id?: string
    parent_id?: string | null
    fromuser?: UserCreateNestedOneWithoutFrom_inquiriesInput
    entity?: EntityCreateNestedOneWithoutInquiriesInput
    assignUser?: UserCreateNestedOneWithoutAssign_inquiriesInput
    subject: string
    body: string
    inquiry_status?: InquiryStatus | null
    is_read?: boolean
    is_answer?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: string | null
  }

  export type InquiryUncheckedCreateInput = {
    inquire_id?: string
    parent_id?: string | null
    fromuser_id?: string | null
    entity_id?: number | null
    assigned_user_id?: string | null
    subject: string
    body: string
    inquiry_status?: InquiryStatus | null
    is_read?: boolean
    is_answer?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: string | null
  }

  export type InquiryUpdateInput = {
    inquire_id?: StringFieldUpdateOperationsInput | string
    parent_id?: NullableStringFieldUpdateOperationsInput | string | null
    fromuser?: UserUpdateOneWithoutFrom_inquiriesNestedInput
    entity?: EntityUpdateOneWithoutInquiriesNestedInput
    assignUser?: UserUpdateOneWithoutAssign_inquiriesNestedInput
    subject?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    inquiry_status?: NullableEnumInquiryStatusFieldUpdateOperationsInput | InquiryStatus | null
    is_read?: BoolFieldUpdateOperationsInput | boolean
    is_answer?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InquiryUncheckedUpdateInput = {
    inquire_id?: StringFieldUpdateOperationsInput | string
    parent_id?: NullableStringFieldUpdateOperationsInput | string | null
    fromuser_id?: NullableStringFieldUpdateOperationsInput | string | null
    entity_id?: NullableIntFieldUpdateOperationsInput | number | null
    assigned_user_id?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    inquiry_status?: NullableEnumInquiryStatusFieldUpdateOperationsInput | InquiryStatus | null
    is_read?: BoolFieldUpdateOperationsInput | boolean
    is_answer?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InquiryCreateManyInput = {
    inquire_id?: string
    parent_id?: string | null
    fromuser_id?: string | null
    entity_id?: number | null
    assigned_user_id?: string | null
    subject: string
    body: string
    inquiry_status?: InquiryStatus | null
    is_read?: boolean
    is_answer?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: string | null
  }

  export type InquiryUpdateManyMutationInput = {
    inquire_id?: StringFieldUpdateOperationsInput | string
    parent_id?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    inquiry_status?: NullableEnumInquiryStatusFieldUpdateOperationsInput | InquiryStatus | null
    is_read?: BoolFieldUpdateOperationsInput | boolean
    is_answer?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InquiryUncheckedUpdateManyInput = {
    inquire_id?: StringFieldUpdateOperationsInput | string
    parent_id?: NullableStringFieldUpdateOperationsInput | string | null
    fromuser_id?: NullableStringFieldUpdateOperationsInput | string | null
    entity_id?: NullableIntFieldUpdateOperationsInput | number | null
    assigned_user_id?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    inquiry_status?: NullableEnumInquiryStatusFieldUpdateOperationsInput | InquiryStatus | null
    is_read?: BoolFieldUpdateOperationsInput | boolean
    is_answer?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type JobCreateInput = {
    job_id?: string
    created_at?: Date | string
    updated_at?: Date | string
    created_by: string
    updated_by?: string | null
    job_publish: JobPublish
    job_references?: JobReferenceListCreateNestedManyWithoutJobInput
    location_details?: string | null
    career_level?: JobCreatecareer_levelInput | Enumerable<JobPosition>
    benefit_other?: string | null
    smoke?: JobCreatesmokeInput | Enumerable<Smoke>
    employment_status: EmploymentStatus
    japanese_level: LanguageLevel
    english_level: LanguageLevel
    job_other_languages?: JobOtherLanguageCreateNestedManyWithoutJobInput
    experienced_count: number
    age_min?: number | null
    age_max?: number | null
    set_age_reason?: string | null
    recruitment_type?: ReqriutmentType | null
    job_title: string
    job_description: string
    japanese_percentage?: number | null
    must_condition: string
    want_condition?: string | null
    position_name?: string | null
    working_hour: string
    salary_type: SalaryType
    salary_min?: number | null
    salary_max?: number | null
    salary_detail: string
    day_off?: string | null
    progress_detail: string
    expire_date?: Date | string | null
    entity_branch?: EntityBranchCreateNestedOneWithoutJobsInput
    job_candidates?: JobCandidateCreateNestedManyWithoutJobInput
    JobRequirement?: JobRequirementCreateNestedManyWithoutJobsInput
  }

  export type JobUncheckedCreateInput = {
    job_id?: string
    created_at?: Date | string
    updated_at?: Date | string
    created_by: string
    updated_by?: string | null
    job_publish: JobPublish
    job_references?: JobReferenceListUncheckedCreateNestedManyWithoutJobInput
    location_details?: string | null
    career_level?: JobCreatecareer_levelInput | Enumerable<JobPosition>
    benefit_other?: string | null
    smoke?: JobCreatesmokeInput | Enumerable<Smoke>
    employment_status: EmploymentStatus
    japanese_level: LanguageLevel
    english_level: LanguageLevel
    job_other_languages?: JobOtherLanguageUncheckedCreateNestedManyWithoutJobInput
    experienced_count: number
    age_min?: number | null
    age_max?: number | null
    set_age_reason?: string | null
    recruitment_type?: ReqriutmentType | null
    job_title: string
    job_description: string
    japanese_percentage?: number | null
    must_condition: string
    want_condition?: string | null
    position_name?: string | null
    working_hour: string
    salary_type: SalaryType
    salary_min?: number | null
    salary_max?: number | null
    salary_detail: string
    day_off?: string | null
    progress_detail: string
    entity_branch_id: number
    expire_date?: Date | string | null
    job_candidates?: JobCandidateUncheckedCreateNestedManyWithoutJobInput
    JobRequirement?: JobRequirementUncheckedCreateNestedManyWithoutJobsInput
  }

  export type JobUpdateInput = {
    job_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    job_publish?: EnumJobPublishFieldUpdateOperationsInput | JobPublish
    job_references?: JobReferenceListUpdateManyWithoutJobNestedInput
    location_details?: NullableStringFieldUpdateOperationsInput | string | null
    career_level?: JobUpdatecareer_levelInput | Enumerable<JobPosition>
    benefit_other?: NullableStringFieldUpdateOperationsInput | string | null
    smoke?: JobUpdatesmokeInput | Enumerable<Smoke>
    employment_status?: EnumEmploymentStatusFieldUpdateOperationsInput | EmploymentStatus
    japanese_level?: EnumLanguageLevelFieldUpdateOperationsInput | LanguageLevel
    english_level?: EnumLanguageLevelFieldUpdateOperationsInput | LanguageLevel
    job_other_languages?: JobOtherLanguageUpdateManyWithoutJobNestedInput
    experienced_count?: IntFieldUpdateOperationsInput | number
    age_min?: NullableIntFieldUpdateOperationsInput | number | null
    age_max?: NullableIntFieldUpdateOperationsInput | number | null
    set_age_reason?: NullableStringFieldUpdateOperationsInput | string | null
    recruitment_type?: NullableEnumReqriutmentTypeFieldUpdateOperationsInput | ReqriutmentType | null
    job_title?: StringFieldUpdateOperationsInput | string
    job_description?: StringFieldUpdateOperationsInput | string
    japanese_percentage?: NullableIntFieldUpdateOperationsInput | number | null
    must_condition?: StringFieldUpdateOperationsInput | string
    want_condition?: NullableStringFieldUpdateOperationsInput | string | null
    position_name?: NullableStringFieldUpdateOperationsInput | string | null
    working_hour?: StringFieldUpdateOperationsInput | string
    salary_type?: EnumSalaryTypeFieldUpdateOperationsInput | SalaryType
    salary_min?: NullableIntFieldUpdateOperationsInput | number | null
    salary_max?: NullableIntFieldUpdateOperationsInput | number | null
    salary_detail?: StringFieldUpdateOperationsInput | string
    day_off?: NullableStringFieldUpdateOperationsInput | string | null
    progress_detail?: StringFieldUpdateOperationsInput | string
    expire_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    entity_branch?: EntityBranchUpdateOneWithoutJobsNestedInput
    job_candidates?: JobCandidateUpdateManyWithoutJobNestedInput
    JobRequirement?: JobRequirementUpdateManyWithoutJobsNestedInput
  }

  export type JobUncheckedUpdateInput = {
    job_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    job_publish?: EnumJobPublishFieldUpdateOperationsInput | JobPublish
    job_references?: JobReferenceListUncheckedUpdateManyWithoutJobNestedInput
    location_details?: NullableStringFieldUpdateOperationsInput | string | null
    career_level?: JobUpdatecareer_levelInput | Enumerable<JobPosition>
    benefit_other?: NullableStringFieldUpdateOperationsInput | string | null
    smoke?: JobUpdatesmokeInput | Enumerable<Smoke>
    employment_status?: EnumEmploymentStatusFieldUpdateOperationsInput | EmploymentStatus
    japanese_level?: EnumLanguageLevelFieldUpdateOperationsInput | LanguageLevel
    english_level?: EnumLanguageLevelFieldUpdateOperationsInput | LanguageLevel
    job_other_languages?: JobOtherLanguageUncheckedUpdateManyWithoutJobNestedInput
    experienced_count?: IntFieldUpdateOperationsInput | number
    age_min?: NullableIntFieldUpdateOperationsInput | number | null
    age_max?: NullableIntFieldUpdateOperationsInput | number | null
    set_age_reason?: NullableStringFieldUpdateOperationsInput | string | null
    recruitment_type?: NullableEnumReqriutmentTypeFieldUpdateOperationsInput | ReqriutmentType | null
    job_title?: StringFieldUpdateOperationsInput | string
    job_description?: StringFieldUpdateOperationsInput | string
    japanese_percentage?: NullableIntFieldUpdateOperationsInput | number | null
    must_condition?: StringFieldUpdateOperationsInput | string
    want_condition?: NullableStringFieldUpdateOperationsInput | string | null
    position_name?: NullableStringFieldUpdateOperationsInput | string | null
    working_hour?: StringFieldUpdateOperationsInput | string
    salary_type?: EnumSalaryTypeFieldUpdateOperationsInput | SalaryType
    salary_min?: NullableIntFieldUpdateOperationsInput | number | null
    salary_max?: NullableIntFieldUpdateOperationsInput | number | null
    salary_detail?: StringFieldUpdateOperationsInput | string
    day_off?: NullableStringFieldUpdateOperationsInput | string | null
    progress_detail?: StringFieldUpdateOperationsInput | string
    entity_branch_id?: IntFieldUpdateOperationsInput | number
    expire_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    job_candidates?: JobCandidateUncheckedUpdateManyWithoutJobNestedInput
    JobRequirement?: JobRequirementUncheckedUpdateManyWithoutJobsNestedInput
  }

  export type JobCreateManyInput = {
    job_id?: string
    created_at?: Date | string
    updated_at?: Date | string
    created_by: string
    updated_by?: string | null
    job_publish: JobPublish
    location_details?: string | null
    career_level?: JobCreatecareer_levelInput | Enumerable<JobPosition>
    benefit_other?: string | null
    smoke?: JobCreatesmokeInput | Enumerable<Smoke>
    employment_status: EmploymentStatus
    japanese_level: LanguageLevel
    english_level: LanguageLevel
    experienced_count: number
    age_min?: number | null
    age_max?: number | null
    set_age_reason?: string | null
    recruitment_type?: ReqriutmentType | null
    job_title: string
    job_description: string
    japanese_percentage?: number | null
    must_condition: string
    want_condition?: string | null
    position_name?: string | null
    working_hour: string
    salary_type: SalaryType
    salary_min?: number | null
    salary_max?: number | null
    salary_detail: string
    day_off?: string | null
    progress_detail: string
    entity_branch_id: number
    expire_date?: Date | string | null
  }

  export type JobUpdateManyMutationInput = {
    job_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    job_publish?: EnumJobPublishFieldUpdateOperationsInput | JobPublish
    location_details?: NullableStringFieldUpdateOperationsInput | string | null
    career_level?: JobUpdatecareer_levelInput | Enumerable<JobPosition>
    benefit_other?: NullableStringFieldUpdateOperationsInput | string | null
    smoke?: JobUpdatesmokeInput | Enumerable<Smoke>
    employment_status?: EnumEmploymentStatusFieldUpdateOperationsInput | EmploymentStatus
    japanese_level?: EnumLanguageLevelFieldUpdateOperationsInput | LanguageLevel
    english_level?: EnumLanguageLevelFieldUpdateOperationsInput | LanguageLevel
    experienced_count?: IntFieldUpdateOperationsInput | number
    age_min?: NullableIntFieldUpdateOperationsInput | number | null
    age_max?: NullableIntFieldUpdateOperationsInput | number | null
    set_age_reason?: NullableStringFieldUpdateOperationsInput | string | null
    recruitment_type?: NullableEnumReqriutmentTypeFieldUpdateOperationsInput | ReqriutmentType | null
    job_title?: StringFieldUpdateOperationsInput | string
    job_description?: StringFieldUpdateOperationsInput | string
    japanese_percentage?: NullableIntFieldUpdateOperationsInput | number | null
    must_condition?: StringFieldUpdateOperationsInput | string
    want_condition?: NullableStringFieldUpdateOperationsInput | string | null
    position_name?: NullableStringFieldUpdateOperationsInput | string | null
    working_hour?: StringFieldUpdateOperationsInput | string
    salary_type?: EnumSalaryTypeFieldUpdateOperationsInput | SalaryType
    salary_min?: NullableIntFieldUpdateOperationsInput | number | null
    salary_max?: NullableIntFieldUpdateOperationsInput | number | null
    salary_detail?: StringFieldUpdateOperationsInput | string
    day_off?: NullableStringFieldUpdateOperationsInput | string | null
    progress_detail?: StringFieldUpdateOperationsInput | string
    expire_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type JobUncheckedUpdateManyInput = {
    job_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    job_publish?: EnumJobPublishFieldUpdateOperationsInput | JobPublish
    location_details?: NullableStringFieldUpdateOperationsInput | string | null
    career_level?: JobUpdatecareer_levelInput | Enumerable<JobPosition>
    benefit_other?: NullableStringFieldUpdateOperationsInput | string | null
    smoke?: JobUpdatesmokeInput | Enumerable<Smoke>
    employment_status?: EnumEmploymentStatusFieldUpdateOperationsInput | EmploymentStatus
    japanese_level?: EnumLanguageLevelFieldUpdateOperationsInput | LanguageLevel
    english_level?: EnumLanguageLevelFieldUpdateOperationsInput | LanguageLevel
    experienced_count?: IntFieldUpdateOperationsInput | number
    age_min?: NullableIntFieldUpdateOperationsInput | number | null
    age_max?: NullableIntFieldUpdateOperationsInput | number | null
    set_age_reason?: NullableStringFieldUpdateOperationsInput | string | null
    recruitment_type?: NullableEnumReqriutmentTypeFieldUpdateOperationsInput | ReqriutmentType | null
    job_title?: StringFieldUpdateOperationsInput | string
    job_description?: StringFieldUpdateOperationsInput | string
    japanese_percentage?: NullableIntFieldUpdateOperationsInput | number | null
    must_condition?: StringFieldUpdateOperationsInput | string
    want_condition?: NullableStringFieldUpdateOperationsInput | string | null
    position_name?: NullableStringFieldUpdateOperationsInput | string | null
    working_hour?: StringFieldUpdateOperationsInput | string
    salary_type?: EnumSalaryTypeFieldUpdateOperationsInput | SalaryType
    salary_min?: NullableIntFieldUpdateOperationsInput | number | null
    salary_max?: NullableIntFieldUpdateOperationsInput | number | null
    salary_detail?: StringFieldUpdateOperationsInput | string
    day_off?: NullableStringFieldUpdateOperationsInput | string | null
    progress_detail?: StringFieldUpdateOperationsInput | string
    entity_branch_id?: IntFieldUpdateOperationsInput | number
    expire_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type JobOtherLanguageCreateInput = {
    job_other_language_id?: string
    language_id: number
    language_level: LanguageLevel
    job: JobCreateNestedOneWithoutJob_other_languagesInput
  }

  export type JobOtherLanguageUncheckedCreateInput = {
    job_other_language_id?: string
    language_id: number
    language_level: LanguageLevel
    job_id: string
  }

  export type JobOtherLanguageUpdateInput = {
    job_other_language_id?: StringFieldUpdateOperationsInput | string
    language_id?: IntFieldUpdateOperationsInput | number
    language_level?: EnumLanguageLevelFieldUpdateOperationsInput | LanguageLevel
    job?: JobUpdateOneRequiredWithoutJob_other_languagesNestedInput
  }

  export type JobOtherLanguageUncheckedUpdateInput = {
    job_other_language_id?: StringFieldUpdateOperationsInput | string
    language_id?: IntFieldUpdateOperationsInput | number
    language_level?: EnumLanguageLevelFieldUpdateOperationsInput | LanguageLevel
    job_id?: StringFieldUpdateOperationsInput | string
  }

  export type JobOtherLanguageCreateManyInput = {
    job_other_language_id?: string
    language_id: number
    language_level: LanguageLevel
    job_id: string
  }

  export type JobOtherLanguageUpdateManyMutationInput = {
    job_other_language_id?: StringFieldUpdateOperationsInput | string
    language_id?: IntFieldUpdateOperationsInput | number
    language_level?: EnumLanguageLevelFieldUpdateOperationsInput | LanguageLevel
  }

  export type JobOtherLanguageUncheckedUpdateManyInput = {
    job_other_language_id?: StringFieldUpdateOperationsInput | string
    language_id?: IntFieldUpdateOperationsInput | number
    language_level?: EnumLanguageLevelFieldUpdateOperationsInput | LanguageLevel
    job_id?: StringFieldUpdateOperationsInput | string
  }

  export type JobReferenceListCreateInput = {
    job_reference_id?: string
    job: JobCreateNestedOneWithoutJob_referencesInput
    reference_list: ReferenceListCreateNestedOneWithoutJobReferenceListInput
    reference_list_item: ReferenceListItemsCreateNestedOneWithoutJobReferenceListInput
  }

  export type JobReferenceListUncheckedCreateInput = {
    job_reference_id?: string
    job_id: string
    reference_list_id: number
    reference_list_item_id: number
  }

  export type JobReferenceListUpdateInput = {
    job_reference_id?: StringFieldUpdateOperationsInput | string
    job?: JobUpdateOneRequiredWithoutJob_referencesNestedInput
    reference_list?: ReferenceListUpdateOneRequiredWithoutJobReferenceListNestedInput
    reference_list_item?: ReferenceListItemsUpdateOneRequiredWithoutJobReferenceListNestedInput
  }

  export type JobReferenceListUncheckedUpdateInput = {
    job_reference_id?: StringFieldUpdateOperationsInput | string
    job_id?: StringFieldUpdateOperationsInput | string
    reference_list_id?: IntFieldUpdateOperationsInput | number
    reference_list_item_id?: IntFieldUpdateOperationsInput | number
  }

  export type JobReferenceListCreateManyInput = {
    job_reference_id?: string
    job_id: string
    reference_list_id: number
    reference_list_item_id: number
  }

  export type JobReferenceListUpdateManyMutationInput = {
    job_reference_id?: StringFieldUpdateOperationsInput | string
  }

  export type JobReferenceListUncheckedUpdateManyInput = {
    job_reference_id?: StringFieldUpdateOperationsInput | string
    job_id?: StringFieldUpdateOperationsInput | string
    reference_list_id?: IntFieldUpdateOperationsInput | number
    reference_list_item_id?: IntFieldUpdateOperationsInput | number
  }

  export type JobCandidateCreateInput = {
    job_candidate_id?: string
    job: JobCreateNestedOneWithoutJob_candidatesInput
    customer: CustomerCreateNestedOneWithoutJob_candidatesInput
    candidate_status: number
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: string | null
    updated_by?: string | null
  }

  export type JobCandidateUncheckedCreateInput = {
    job_candidate_id?: string
    job_id: string
    customer_id: string
    candidate_status: number
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: string | null
    updated_by?: string | null
  }

  export type JobCandidateUpdateInput = {
    job_candidate_id?: StringFieldUpdateOperationsInput | string
    job?: JobUpdateOneRequiredWithoutJob_candidatesNestedInput
    customer?: CustomerUpdateOneRequiredWithoutJob_candidatesNestedInput
    candidate_status?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type JobCandidateUncheckedUpdateInput = {
    job_candidate_id?: StringFieldUpdateOperationsInput | string
    job_id?: StringFieldUpdateOperationsInput | string
    customer_id?: StringFieldUpdateOperationsInput | string
    candidate_status?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type JobCandidateCreateManyInput = {
    job_candidate_id?: string
    job_id: string
    customer_id: string
    candidate_status: number
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: string | null
    updated_by?: string | null
  }

  export type JobCandidateUpdateManyMutationInput = {
    job_candidate_id?: StringFieldUpdateOperationsInput | string
    candidate_status?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type JobCandidateUncheckedUpdateManyInput = {
    job_candidate_id?: StringFieldUpdateOperationsInput | string
    job_id?: StringFieldUpdateOperationsInput | string
    customer_id?: StringFieldUpdateOperationsInput | string
    candidate_status?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type JobRequirementCreateInput = {
    job_require_id?: string
    jobs: JobCreateNestedOneWithoutJobRequirementInput
    require_id: number
    require_detial?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: string | null
    updated_by?: string | null
  }

  export type JobRequirementUncheckedCreateInput = {
    job_require_id?: string
    job_id: string
    require_id: number
    require_detial?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: string | null
    updated_by?: string | null
  }

  export type JobRequirementUpdateInput = {
    job_require_id?: StringFieldUpdateOperationsInput | string
    jobs?: JobUpdateOneRequiredWithoutJobRequirementNestedInput
    require_id?: IntFieldUpdateOperationsInput | number
    require_detial?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type JobRequirementUncheckedUpdateInput = {
    job_require_id?: StringFieldUpdateOperationsInput | string
    job_id?: StringFieldUpdateOperationsInput | string
    require_id?: IntFieldUpdateOperationsInput | number
    require_detial?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type JobRequirementCreateManyInput = {
    job_require_id?: string
    job_id: string
    require_id: number
    require_detial?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: string | null
    updated_by?: string | null
  }

  export type JobRequirementUpdateManyMutationInput = {
    job_require_id?: StringFieldUpdateOperationsInput | string
    require_id?: IntFieldUpdateOperationsInput | number
    require_detial?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type JobRequirementUncheckedUpdateManyInput = {
    job_require_id?: StringFieldUpdateOperationsInput | string
    job_id?: StringFieldUpdateOperationsInput | string
    require_id?: IntFieldUpdateOperationsInput | number
    require_detial?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SystemLangaugeCreateInput = {
    language_code: string
    is_default?: boolean
  }

  export type SystemLangaugeUncheckedCreateInput = {
    language_id?: number
    language_code: string
    is_default?: boolean
  }

  export type SystemLangaugeUpdateInput = {
    language_code?: StringFieldUpdateOperationsInput | string
    is_default?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SystemLangaugeUncheckedUpdateInput = {
    language_id?: IntFieldUpdateOperationsInput | number
    language_code?: StringFieldUpdateOperationsInput | string
    is_default?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SystemLangaugeCreateManyInput = {
    language_id?: number
    language_code: string
    is_default?: boolean
  }

  export type SystemLangaugeUpdateManyMutationInput = {
    language_code?: StringFieldUpdateOperationsInput | string
    is_default?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SystemLangaugeUncheckedUpdateManyInput = {
    language_id?: IntFieldUpdateOperationsInput | number
    language_code?: StringFieldUpdateOperationsInput | string
    is_default?: BoolFieldUpdateOperationsInput | boolean
  }

  export type LoggerCreateInput = {
    log_id?: string
    action_user?: UserAction
    User?: UserCreateNestedOneWithoutLoggersInput
    new_value?: NullableJsonNullValueInput | InputJsonValue
    old_value?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: string | null
    updated_by?: string | null
  }

  export type LoggerUncheckedCreateInput = {
    log_id?: string
    action_user?: UserAction
    user_id?: string | null
    new_value?: NullableJsonNullValueInput | InputJsonValue
    old_value?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: string | null
    updated_by?: string | null
  }

  export type LoggerUpdateInput = {
    log_id?: StringFieldUpdateOperationsInput | string
    action_user?: EnumUserActionFieldUpdateOperationsInput | UserAction
    User?: UserUpdateOneWithoutLoggersNestedInput
    new_value?: NullableJsonNullValueInput | InputJsonValue
    old_value?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LoggerUncheckedUpdateInput = {
    log_id?: StringFieldUpdateOperationsInput | string
    action_user?: EnumUserActionFieldUpdateOperationsInput | UserAction
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    new_value?: NullableJsonNullValueInput | InputJsonValue
    old_value?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LoggerCreateManyInput = {
    log_id?: string
    action_user?: UserAction
    user_id?: string | null
    new_value?: NullableJsonNullValueInput | InputJsonValue
    old_value?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: string | null
    updated_by?: string | null
  }

  export type LoggerUpdateManyMutationInput = {
    log_id?: StringFieldUpdateOperationsInput | string
    action_user?: EnumUserActionFieldUpdateOperationsInput | UserAction
    new_value?: NullableJsonNullValueInput | InputJsonValue
    old_value?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LoggerUncheckedUpdateManyInput = {
    log_id?: StringFieldUpdateOperationsInput | string
    action_user?: EnumUserActionFieldUpdateOperationsInput | UserAction
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    new_value?: NullableJsonNullValueInput | InputJsonValue
    old_value?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NewsCreateInput = {
    news_id?: string
    pages: PagesCreateNestedOneWithoutNewsInput
    title: string
    brief: string
    image_id: string
    content: string
    is_top?: boolean
    is_publish?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    created_by: string
    update_by: string
  }

  export type NewsUncheckedCreateInput = {
    news_id?: string
    page_id: number
    title: string
    brief: string
    image_id: string
    content: string
    is_top?: boolean
    is_publish?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    created_by: string
    update_by: string
  }

  export type NewsUpdateInput = {
    news_id?: StringFieldUpdateOperationsInput | string
    pages?: PagesUpdateOneRequiredWithoutNewsNestedInput
    title?: StringFieldUpdateOperationsInput | string
    brief?: StringFieldUpdateOperationsInput | string
    image_id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    is_top?: BoolFieldUpdateOperationsInput | boolean
    is_publish?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: StringFieldUpdateOperationsInput | string
    update_by?: StringFieldUpdateOperationsInput | string
  }

  export type NewsUncheckedUpdateInput = {
    news_id?: StringFieldUpdateOperationsInput | string
    page_id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    brief?: StringFieldUpdateOperationsInput | string
    image_id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    is_top?: BoolFieldUpdateOperationsInput | boolean
    is_publish?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: StringFieldUpdateOperationsInput | string
    update_by?: StringFieldUpdateOperationsInput | string
  }

  export type NewsCreateManyInput = {
    news_id?: string
    page_id: number
    title: string
    brief: string
    image_id: string
    content: string
    is_top?: boolean
    is_publish?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    created_by: string
    update_by: string
  }

  export type NewsUpdateManyMutationInput = {
    news_id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    brief?: StringFieldUpdateOperationsInput | string
    image_id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    is_top?: BoolFieldUpdateOperationsInput | boolean
    is_publish?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: StringFieldUpdateOperationsInput | string
    update_by?: StringFieldUpdateOperationsInput | string
  }

  export type NewsUncheckedUpdateManyInput = {
    news_id?: StringFieldUpdateOperationsInput | string
    page_id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    brief?: StringFieldUpdateOperationsInput | string
    image_id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    is_top?: BoolFieldUpdateOperationsInput | boolean
    is_publish?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: StringFieldUpdateOperationsInput | string
    update_by?: StringFieldUpdateOperationsInput | string
  }

  export type NotificationCreateInput = {
    notifiation_id?: string
    User: UserCreateNestedOneWithoutNotificationsInput
    link: string
    message: string
    is_new?: boolean
    is_badge?: boolean
    created_at?: Date | string
    created_by: string
  }

  export type NotificationUncheckedCreateInput = {
    notifiation_id?: string
    user_id: string
    link: string
    message: string
    is_new?: boolean
    is_badge?: boolean
    created_at?: Date | string
    created_by: string
  }

  export type NotificationUpdateInput = {
    notifiation_id?: StringFieldUpdateOperationsInput | string
    User?: UserUpdateOneRequiredWithoutNotificationsNestedInput
    link?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    is_new?: BoolFieldUpdateOperationsInput | boolean
    is_badge?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: StringFieldUpdateOperationsInput | string
  }

  export type NotificationUncheckedUpdateInput = {
    notifiation_id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    link?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    is_new?: BoolFieldUpdateOperationsInput | boolean
    is_badge?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: StringFieldUpdateOperationsInput | string
  }

  export type NotificationCreateManyInput = {
    notifiation_id?: string
    user_id: string
    link: string
    message: string
    is_new?: boolean
    is_badge?: boolean
    created_at?: Date | string
    created_by: string
  }

  export type NotificationUpdateManyMutationInput = {
    notifiation_id?: StringFieldUpdateOperationsInput | string
    link?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    is_new?: BoolFieldUpdateOperationsInput | boolean
    is_badge?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: StringFieldUpdateOperationsInput | string
  }

  export type NotificationUncheckedUpdateManyInput = {
    notifiation_id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    link?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    is_new?: BoolFieldUpdateOperationsInput | boolean
    is_badge?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: StringFieldUpdateOperationsInput | string
  }

  export type PagesCreateInput = {
    page_name: string
    page_type?: number
    created_at?: Date | string
    created_by: string
    news?: NewsCreateNestedManyWithoutPagesInput
  }

  export type PagesUncheckedCreateInput = {
    page_id?: number
    page_name: string
    page_type?: number
    created_at?: Date | string
    created_by: string
    news?: NewsUncheckedCreateNestedManyWithoutPagesInput
  }

  export type PagesUpdateInput = {
    page_name?: StringFieldUpdateOperationsInput | string
    page_type?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: StringFieldUpdateOperationsInput | string
    news?: NewsUpdateManyWithoutPagesNestedInput
  }

  export type PagesUncheckedUpdateInput = {
    page_id?: IntFieldUpdateOperationsInput | number
    page_name?: StringFieldUpdateOperationsInput | string
    page_type?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: StringFieldUpdateOperationsInput | string
    news?: NewsUncheckedUpdateManyWithoutPagesNestedInput
  }

  export type PagesCreateManyInput = {
    page_id?: number
    page_name: string
    page_type?: number
    created_at?: Date | string
    created_by: string
  }

  export type PagesUpdateManyMutationInput = {
    page_name?: StringFieldUpdateOperationsInput | string
    page_type?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: StringFieldUpdateOperationsInput | string
  }

  export type PagesUncheckedUpdateManyInput = {
    page_id?: IntFieldUpdateOperationsInput | number
    page_name?: StringFieldUpdateOperationsInput | string
    page_type?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: StringFieldUpdateOperationsInput | string
  }

  export type ReferenceListCreateInput = {
    list_name: string
    created_at?: Date | string
    listitems?: ReferenceListItemsCreateNestedManyWithoutListInput
    JobReferenceList?: JobReferenceListCreateNestedManyWithoutReference_listInput
  }

  export type ReferenceListUncheckedCreateInput = {
    list_id?: number
    list_name: string
    created_at?: Date | string
    listitems?: ReferenceListItemsUncheckedCreateNestedManyWithoutListInput
    JobReferenceList?: JobReferenceListUncheckedCreateNestedManyWithoutReference_listInput
  }

  export type ReferenceListUpdateInput = {
    list_name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    listitems?: ReferenceListItemsUpdateManyWithoutListNestedInput
    JobReferenceList?: JobReferenceListUpdateManyWithoutReference_listNestedInput
  }

  export type ReferenceListUncheckedUpdateInput = {
    list_id?: IntFieldUpdateOperationsInput | number
    list_name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    listitems?: ReferenceListItemsUncheckedUpdateManyWithoutListNestedInput
    JobReferenceList?: JobReferenceListUncheckedUpdateManyWithoutReference_listNestedInput
  }

  export type ReferenceListCreateManyInput = {
    list_id?: number
    list_name: string
    created_at?: Date | string
  }

  export type ReferenceListUpdateManyMutationInput = {
    list_name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReferenceListUncheckedUpdateManyInput = {
    list_id?: IntFieldUpdateOperationsInput | number
    list_name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReferenceListItemsCreateInput = {
    list: ReferenceListCreateNestedOneWithoutListitemsInput
    dictionary_id: number
    code?: string | null
    listitem_value?: string | null
    parent_id?: number | null
    value?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    customer_experiences?: CustomerExperienceCreateNestedManyWithoutListitemsInput
    Dictionary?: DictionaryCreateNestedOneWithoutReference_listitemsInput
    JobReferenceList?: JobReferenceListCreateNestedManyWithoutReference_list_itemInput
  }

  export type ReferenceListItemsUncheckedCreateInput = {
    listitem_id?: number
    list_id: number
    dictionary_id: number
    code?: string | null
    listitem_value?: string | null
    parent_id?: number | null
    value?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    customer_experiences?: CustomerExperienceUncheckedCreateNestedManyWithoutListitemsInput
    dictionaryDictionaries_id?: string | null
    JobReferenceList?: JobReferenceListUncheckedCreateNestedManyWithoutReference_list_itemInput
  }

  export type ReferenceListItemsUpdateInput = {
    list?: ReferenceListUpdateOneRequiredWithoutListitemsNestedInput
    dictionary_id?: IntFieldUpdateOperationsInput | number
    code?: NullableStringFieldUpdateOperationsInput | string | null
    listitem_value?: NullableStringFieldUpdateOperationsInput | string | null
    parent_id?: NullableIntFieldUpdateOperationsInput | number | null
    value?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    customer_experiences?: CustomerExperienceUpdateManyWithoutListitemsNestedInput
    Dictionary?: DictionaryUpdateOneWithoutReference_listitemsNestedInput
    JobReferenceList?: JobReferenceListUpdateManyWithoutReference_list_itemNestedInput
  }

  export type ReferenceListItemsUncheckedUpdateInput = {
    listitem_id?: IntFieldUpdateOperationsInput | number
    list_id?: IntFieldUpdateOperationsInput | number
    dictionary_id?: IntFieldUpdateOperationsInput | number
    code?: NullableStringFieldUpdateOperationsInput | string | null
    listitem_value?: NullableStringFieldUpdateOperationsInput | string | null
    parent_id?: NullableIntFieldUpdateOperationsInput | number | null
    value?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    customer_experiences?: CustomerExperienceUncheckedUpdateManyWithoutListitemsNestedInput
    dictionaryDictionaries_id?: NullableStringFieldUpdateOperationsInput | string | null
    JobReferenceList?: JobReferenceListUncheckedUpdateManyWithoutReference_list_itemNestedInput
  }

  export type ReferenceListItemsCreateManyInput = {
    listitem_id?: number
    list_id: number
    dictionary_id: number
    code?: string | null
    listitem_value?: string | null
    parent_id?: number | null
    value?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    dictionaryDictionaries_id?: string | null
  }

  export type ReferenceListItemsUpdateManyMutationInput = {
    dictionary_id?: IntFieldUpdateOperationsInput | number
    code?: NullableStringFieldUpdateOperationsInput | string | null
    listitem_value?: NullableStringFieldUpdateOperationsInput | string | null
    parent_id?: NullableIntFieldUpdateOperationsInput | number | null
    value?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReferenceListItemsUncheckedUpdateManyInput = {
    listitem_id?: IntFieldUpdateOperationsInput | number
    list_id?: IntFieldUpdateOperationsInput | number
    dictionary_id?: IntFieldUpdateOperationsInput | number
    code?: NullableStringFieldUpdateOperationsInput | string | null
    listitem_value?: NullableStringFieldUpdateOperationsInput | string | null
    parent_id?: NullableIntFieldUpdateOperationsInput | number | null
    value?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    dictionaryDictionaries_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ScoutFavCreateInput = {
    scout_id?: string
    entity_id?: number | null
    branch_id?: number | null
    user: UserCreateNestedOneWithoutScoutFavInput
    job_id?: string | null
    note: string
    created_at?: Date | string
    created_by: string
  }

  export type ScoutFavUncheckedCreateInput = {
    scout_id?: string
    entity_id?: number | null
    branch_id?: number | null
    user_id: string
    job_id?: string | null
    note: string
    created_at?: Date | string
    created_by: string
  }

  export type ScoutFavUpdateInput = {
    scout_id?: StringFieldUpdateOperationsInput | string
    entity_id?: NullableIntFieldUpdateOperationsInput | number | null
    branch_id?: NullableIntFieldUpdateOperationsInput | number | null
    user?: UserUpdateOneRequiredWithoutScoutFavNestedInput
    job_id?: NullableStringFieldUpdateOperationsInput | string | null
    note?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: StringFieldUpdateOperationsInput | string
  }

  export type ScoutFavUncheckedUpdateInput = {
    scout_id?: StringFieldUpdateOperationsInput | string
    entity_id?: NullableIntFieldUpdateOperationsInput | number | null
    branch_id?: NullableIntFieldUpdateOperationsInput | number | null
    user_id?: StringFieldUpdateOperationsInput | string
    job_id?: NullableStringFieldUpdateOperationsInput | string | null
    note?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: StringFieldUpdateOperationsInput | string
  }

  export type ScoutFavCreateManyInput = {
    scout_id?: string
    entity_id?: number | null
    branch_id?: number | null
    user_id: string
    job_id?: string | null
    note: string
    created_at?: Date | string
    created_by: string
  }

  export type ScoutFavUpdateManyMutationInput = {
    scout_id?: StringFieldUpdateOperationsInput | string
    entity_id?: NullableIntFieldUpdateOperationsInput | number | null
    branch_id?: NullableIntFieldUpdateOperationsInput | number | null
    job_id?: NullableStringFieldUpdateOperationsInput | string | null
    note?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: StringFieldUpdateOperationsInput | string
  }

  export type ScoutFavUncheckedUpdateManyInput = {
    scout_id?: StringFieldUpdateOperationsInput | string
    entity_id?: NullableIntFieldUpdateOperationsInput | number | null
    branch_id?: NullableIntFieldUpdateOperationsInput | number | null
    user_id?: StringFieldUpdateOperationsInput | string
    job_id?: NullableStringFieldUpdateOperationsInput | string | null
    note?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: StringFieldUpdateOperationsInput | string
  }

  export type UserCreateInput = {
    user_id?: string
    email: string
    mobile?: string | null
    name?: string | null
    password_hash: string
    role?: UserRole
    company_id?: number
    attemptpass_count?: number | null
    reset_code?: string
    is_emailverified?: boolean
    is_mobileverified?: boolean
    user_status?: UserStatus
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    favs: JsonNullValueInput | InputJsonValue
    Customer?: CustomerCreateNestedOneWithoutUserInput
    loggers?: LoggerCreateNestedManyWithoutUserInput
    from_inquiries?: InquiryCreateNestedManyWithoutFromuserInput
    assign_inquiries?: InquiryCreateNestedManyWithoutAssignUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    ScoutFav?: ScoutFavCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    user_id?: string
    email: string
    mobile?: string | null
    name?: string | null
    password_hash: string
    role?: UserRole
    company_id?: number
    customer_id?: string | null
    attemptpass_count?: number | null
    reset_code?: string
    is_emailverified?: boolean
    is_mobileverified?: boolean
    user_status?: UserStatus
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    favs: JsonNullValueInput | InputJsonValue
    loggers?: LoggerUncheckedCreateNestedManyWithoutUserInput
    from_inquiries?: InquiryUncheckedCreateNestedManyWithoutFromuserInput
    assign_inquiries?: InquiryUncheckedCreateNestedManyWithoutAssignUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    ScoutFav?: ScoutFavUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    user_id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | UserRole
    company_id?: IntFieldUpdateOperationsInput | number
    attemptpass_count?: NullableIntFieldUpdateOperationsInput | number | null
    reset_code?: StringFieldUpdateOperationsInput | string
    is_emailverified?: BoolFieldUpdateOperationsInput | boolean
    is_mobileverified?: BoolFieldUpdateOperationsInput | boolean
    user_status?: EnumUserStatusFieldUpdateOperationsInput | UserStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    favs?: JsonNullValueInput | InputJsonValue
    Customer?: CustomerUpdateOneWithoutUserNestedInput
    loggers?: LoggerUpdateManyWithoutUserNestedInput
    from_inquiries?: InquiryUpdateManyWithoutFromuserNestedInput
    assign_inquiries?: InquiryUpdateManyWithoutAssignUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    ScoutFav?: ScoutFavUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    user_id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | UserRole
    company_id?: IntFieldUpdateOperationsInput | number
    customer_id?: NullableStringFieldUpdateOperationsInput | string | null
    attemptpass_count?: NullableIntFieldUpdateOperationsInput | number | null
    reset_code?: StringFieldUpdateOperationsInput | string
    is_emailverified?: BoolFieldUpdateOperationsInput | boolean
    is_mobileverified?: BoolFieldUpdateOperationsInput | boolean
    user_status?: EnumUserStatusFieldUpdateOperationsInput | UserStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    favs?: JsonNullValueInput | InputJsonValue
    loggers?: LoggerUncheckedUpdateManyWithoutUserNestedInput
    from_inquiries?: InquiryUncheckedUpdateManyWithoutFromuserNestedInput
    assign_inquiries?: InquiryUncheckedUpdateManyWithoutAssignUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    ScoutFav?: ScoutFavUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    user_id?: string
    email: string
    mobile?: string | null
    name?: string | null
    password_hash: string
    role?: UserRole
    company_id?: number
    customer_id?: string | null
    attemptpass_count?: number | null
    reset_code?: string
    is_emailverified?: boolean
    is_mobileverified?: boolean
    user_status?: UserStatus
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    favs: JsonNullValueInput | InputJsonValue
  }

  export type UserUpdateManyMutationInput = {
    user_id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | UserRole
    company_id?: IntFieldUpdateOperationsInput | number
    attemptpass_count?: NullableIntFieldUpdateOperationsInput | number | null
    reset_code?: StringFieldUpdateOperationsInput | string
    is_emailverified?: BoolFieldUpdateOperationsInput | boolean
    is_mobileverified?: BoolFieldUpdateOperationsInput | boolean
    user_status?: EnumUserStatusFieldUpdateOperationsInput | UserStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    favs?: JsonNullValueInput | InputJsonValue
  }

  export type UserUncheckedUpdateManyInput = {
    user_id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | UserRole
    company_id?: IntFieldUpdateOperationsInput | number
    customer_id?: NullableStringFieldUpdateOperationsInput | string | null
    attemptpass_count?: NullableIntFieldUpdateOperationsInput | number | null
    reset_code?: StringFieldUpdateOperationsInput | string
    is_emailverified?: BoolFieldUpdateOperationsInput | boolean
    is_mobileverified?: BoolFieldUpdateOperationsInput | boolean
    user_status?: EnumUserStatusFieldUpdateOperationsInput | UserStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    favs?: JsonNullValueInput | InputJsonValue
  }

  export type StringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringFilter | string
  }

  export type StringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringNullableFilter | string | null
  }

  export type EnumUserActionFilter = {
    equals?: UserAction
    in?: Enumerable<UserAction>
    notIn?: Enumerable<UserAction>
    not?: NestedEnumUserActionFilter | UserAction
  }

  export type EnumUserRoleFilter = {
    equals?: UserRole
    in?: Enumerable<UserRole>
    notIn?: Enumerable<UserRole>
    not?: NestedEnumUserRoleFilter | UserRole
  }

  export type BoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type DateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type ActionRoleCountOrderByAggregateInput = {
    action_role_id?: SortOrder
    controller_path?: SortOrder
    action_user?: SortOrder
    role?: SortOrder
    is_can?: SortOrder
    is_company?: SortOrder
    parent_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
  }

  export type ActionRoleMaxOrderByAggregateInput = {
    action_role_id?: SortOrder
    controller_path?: SortOrder
    action_user?: SortOrder
    role?: SortOrder
    is_can?: SortOrder
    is_company?: SortOrder
    parent_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
  }

  export type ActionRoleMinOrderByAggregateInput = {
    action_role_id?: SortOrder
    controller_path?: SortOrder
    action_user?: SortOrder
    role?: SortOrder
    is_can?: SortOrder
    is_company?: SortOrder
    parent_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
  }

  export type StringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type StringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type EnumUserActionWithAggregatesFilter = {
    equals?: UserAction
    in?: Enumerable<UserAction>
    notIn?: Enumerable<UserAction>
    not?: NestedEnumUserActionWithAggregatesFilter | UserAction
    _count?: NestedIntFilter
    _min?: NestedEnumUserActionFilter
    _max?: NestedEnumUserActionFilter
  }

  export type EnumUserRoleWithAggregatesFilter = {
    equals?: UserRole
    in?: Enumerable<UserRole>
    notIn?: Enumerable<UserRole>
    not?: NestedEnumUserRoleWithAggregatesFilter | UserRole
    _count?: NestedIntFilter
    _min?: NestedEnumUserRoleFilter
    _max?: NestedEnumUserRoleFilter
  }

  export type BoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    _min?: NestedBoolFilter
    _max?: NestedBoolFilter
  }

  export type DateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type EnumGenderNullableFilter = {
    equals?: Gender | null
    in?: Enumerable<Gender> | null
    notIn?: Enumerable<Gender> | null
    not?: NestedEnumGenderNullableFilter | Gender | null
  }

  export type DateTimeNullableFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableFilter | Date | string | null
  }
  export type JsonNullableFilter = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase>, Exclude<keyof Required<JsonNullableFilterBase>, 'path'>>,
        Required<JsonNullableFilterBase>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase>, 'path'>>

  export type JsonNullableFilterBase = {
    equals?: InputJsonValue | JsonNullValueFilter
    path?: Array<string>
    string_contains?: string
    string_starts_with?: string
    string_ends_with?: string
    array_contains?: InputJsonValue | null
    array_starts_with?: InputJsonValue | null
    array_ends_with?: InputJsonValue | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonNullValueFilter
  }

  export type IntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type EnumCustomerStatusNullableFilter = {
    equals?: CustomerStatus | null
    in?: Enumerable<CustomerStatus> | null
    notIn?: Enumerable<CustomerStatus> | null
    not?: NestedEnumCustomerStatusNullableFilter | CustomerStatus | null
  }

  export type UserRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type CustomerVisaListRelationFilter = {
    every?: CustomerVisaWhereInput
    some?: CustomerVisaWhereInput
    none?: CustomerVisaWhereInput
  }

  export type CustomerJobDetailListRelationFilter = {
    every?: CustomerJobDetailWhereInput
    some?: CustomerJobDetailWhereInput
    none?: CustomerJobDetailWhereInput
  }

  export type CustomerEducationListRelationFilter = {
    every?: CustomerEducationWhereInput
    some?: CustomerEducationWhereInput
    none?: CustomerEducationWhereInput
  }

  export type CustomerLanguageListRelationFilter = {
    every?: CustomerLanguageWhereInput
    some?: CustomerLanguageWhereInput
    none?: CustomerLanguageWhereInput
  }

  export type CustomerQualificationListRelationFilter = {
    every?: CustomerQualificationWhereInput
    some?: CustomerQualificationWhereInput
    none?: CustomerQualificationWhereInput
  }

  export type CustomerWorkHistoryListRelationFilter = {
    every?: CustomerWorkHistoryWhereInput
    some?: CustomerWorkHistoryWhereInput
    none?: CustomerWorkHistoryWhereInput
  }

  export type JobCandidateListRelationFilter = {
    every?: JobCandidateWhereInput
    some?: JobCandidateWhereInput
    none?: JobCandidateWhereInput
  }

  export type CustomerDesiredListRelationFilter = {
    every?: CustomerDesiredWhereInput
    some?: CustomerDesiredWhereInput
    none?: CustomerDesiredWhereInput
  }

  export type CustomerVisaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CustomerJobDetailOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CustomerEducationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CustomerLanguageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CustomerQualificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CustomerWorkHistoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type JobCandidateOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CustomerDesiredOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CustomerCountOrderByAggregateInput = {
    customer_id?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    first_name_kana?: SortOrder
    last_name_kana?: SortOrder
    gender?: SortOrder
    birth_date?: SortOrder
    spouse?: SortOrder
    family_size?: SortOrder
    email?: SortOrder
    mobile?: SortOrder
    phone?: SortOrder
    profile_image?: SortOrder
    cv_file?: SortOrder
    resume_file?: SortOrder
    prefecture?: SortOrder
    post_code?: SortOrder
    city?: SortOrder
    district?: SortOrder
    address?: SortOrder
    address1?: SortOrder
    nearest_station?: SortOrder
    socials?: SortOrder
    country?: SortOrder
    experienced_year?: SortOrder
    from_data?: SortOrder
    status_customer?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
  }

  export type CustomerAvgOrderByAggregateInput = {
    family_size?: SortOrder
    experienced_year?: SortOrder
    from_data?: SortOrder
  }

  export type CustomerMaxOrderByAggregateInput = {
    customer_id?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    first_name_kana?: SortOrder
    last_name_kana?: SortOrder
    gender?: SortOrder
    birth_date?: SortOrder
    family_size?: SortOrder
    email?: SortOrder
    mobile?: SortOrder
    phone?: SortOrder
    profile_image?: SortOrder
    cv_file?: SortOrder
    resume_file?: SortOrder
    post_code?: SortOrder
    city?: SortOrder
    district?: SortOrder
    address?: SortOrder
    address1?: SortOrder
    nearest_station?: SortOrder
    country?: SortOrder
    experienced_year?: SortOrder
    from_data?: SortOrder
    status_customer?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
  }

  export type CustomerMinOrderByAggregateInput = {
    customer_id?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    first_name_kana?: SortOrder
    last_name_kana?: SortOrder
    gender?: SortOrder
    birth_date?: SortOrder
    family_size?: SortOrder
    email?: SortOrder
    mobile?: SortOrder
    phone?: SortOrder
    profile_image?: SortOrder
    cv_file?: SortOrder
    resume_file?: SortOrder
    post_code?: SortOrder
    city?: SortOrder
    district?: SortOrder
    address?: SortOrder
    address1?: SortOrder
    nearest_station?: SortOrder
    country?: SortOrder
    experienced_year?: SortOrder
    from_data?: SortOrder
    status_customer?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
  }

  export type CustomerSumOrderByAggregateInput = {
    family_size?: SortOrder
    experienced_year?: SortOrder
    from_data?: SortOrder
  }

  export type EnumGenderNullableWithAggregatesFilter = {
    equals?: Gender | null
    in?: Enumerable<Gender> | null
    notIn?: Enumerable<Gender> | null
    not?: NestedEnumGenderNullableWithAggregatesFilter | Gender | null
    _count?: NestedIntNullableFilter
    _min?: NestedEnumGenderNullableFilter
    _max?: NestedEnumGenderNullableFilter
  }

  export type DateTimeNullableWithAggregatesFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableWithAggregatesFilter | Date | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedDateTimeNullableFilter
    _max?: NestedDateTimeNullableFilter
  }
  export type JsonNullableWithAggregatesFilter = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase = {
    equals?: InputJsonValue | JsonNullValueFilter
    path?: Array<string>
    string_contains?: string
    string_starts_with?: string
    string_ends_with?: string
    array_contains?: InputJsonValue | null
    array_starts_with?: InputJsonValue | null
    array_ends_with?: InputJsonValue | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonNullValueFilter
    _count?: NestedIntNullableFilter
    _min?: NestedJsonNullableFilter
    _max?: NestedJsonNullableFilter
  }

  export type IntNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedIntNullableFilter
    _min?: NestedIntNullableFilter
    _max?: NestedIntNullableFilter
  }

  export type EnumCustomerStatusNullableWithAggregatesFilter = {
    equals?: CustomerStatus | null
    in?: Enumerable<CustomerStatus> | null
    notIn?: Enumerable<CustomerStatus> | null
    not?: NestedEnumCustomerStatusNullableWithAggregatesFilter | CustomerStatus | null
    _count?: NestedIntNullableFilter
    _min?: NestedEnumCustomerStatusNullableFilter
    _max?: NestedEnumCustomerStatusNullableFilter
  }

  export type CustomerRelationFilter = {
    is?: CustomerWhereInput | null
    isNot?: CustomerWhereInput | null
  }
  export type JsonNullableListFilter = 
    | PatchUndefined<
        Either<Required<JsonNullableListFilterBase>, Exclude<keyof Required<JsonNullableListFilterBase>, 'path'>>,
        Required<JsonNullableListFilterBase>
      >
    | OptionalFlat<Omit<Required<JsonNullableListFilterBase>, 'path'>>

  export type JsonNullableListFilterBase = {
    equals?: Enumerable<InputJsonValue> | null
    has?: InputJsonValue | null
    hasEvery?: Enumerable<InputJsonValue>
    hasSome?: Enumerable<InputJsonValue>
    isEmpty?: boolean
  }

  export type IntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type CustomerDesiredCountOrderByAggregateInput = {
    desired_id?: SortOrder
    customer_id?: SortOrder
    occupation?: SortOrder
    industry?: SortOrder
    location?: SortOrder
    career_level?: SortOrder
    contract_type?: SortOrder
    desired_company?: SortOrder
    time_to?: SortOrder
    annual_income?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
  }

  export type CustomerDesiredAvgOrderByAggregateInput = {
    annual_income?: SortOrder
  }

  export type CustomerDesiredMaxOrderByAggregateInput = {
    desired_id?: SortOrder
    customer_id?: SortOrder
    time_to?: SortOrder
    annual_income?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
  }

  export type CustomerDesiredMinOrderByAggregateInput = {
    desired_id?: SortOrder
    customer_id?: SortOrder
    time_to?: SortOrder
    annual_income?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
  }

  export type CustomerDesiredSumOrderByAggregateInput = {
    annual_income?: SortOrder
  }

  export type IntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type BoolNullableFilter = {
    equals?: boolean | null
    not?: NestedBoolNullableFilter | boolean | null
  }

  export type CustomerEducationCountOrderByAggregateInput = {
    education_id?: SortOrder
    customer_id?: SortOrder
    country?: SortOrder
    degree?: SortOrder
    entrollment_date?: SortOrder
    graduate_date?: SortOrder
    is_current?: SortOrder
    school_id?: SortOrder
    school?: SortOrder
    faculty?: SortOrder
    department?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
  }

  export type CustomerEducationAvgOrderByAggregateInput = {
    school_id?: SortOrder
  }

  export type CustomerEducationMaxOrderByAggregateInput = {
    education_id?: SortOrder
    customer_id?: SortOrder
    country?: SortOrder
    entrollment_date?: SortOrder
    graduate_date?: SortOrder
    is_current?: SortOrder
    school_id?: SortOrder
    faculty?: SortOrder
    department?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
  }

  export type CustomerEducationMinOrderByAggregateInput = {
    education_id?: SortOrder
    customer_id?: SortOrder
    country?: SortOrder
    entrollment_date?: SortOrder
    graduate_date?: SortOrder
    is_current?: SortOrder
    school_id?: SortOrder
    faculty?: SortOrder
    department?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
  }

  export type CustomerEducationSumOrderByAggregateInput = {
    school_id?: SortOrder
  }

  export type BoolNullableWithAggregatesFilter = {
    equals?: boolean | null
    not?: NestedBoolNullableWithAggregatesFilter | boolean | null
    _count?: NestedIntNullableFilter
    _min?: NestedBoolNullableFilter
    _max?: NestedBoolNullableFilter
  }

  export type CustomerJobDetailRelationFilter = {
    is?: CustomerJobDetailWhereInput
    isNot?: CustomerJobDetailWhereInput
  }

  export type ReferenceListItemsRelationFilter = {
    is?: ReferenceListItemsWhereInput
    isNot?: ReferenceListItemsWhereInput
  }

  export type CustomerExperienceCountOrderByAggregateInput = {
    experience_id?: SortOrder
    jobdetail_id?: SortOrder
    skill_id?: SortOrder
    over_year?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
  }

  export type CustomerExperienceAvgOrderByAggregateInput = {
    skill_id?: SortOrder
    over_year?: SortOrder
  }

  export type CustomerExperienceMaxOrderByAggregateInput = {
    experience_id?: SortOrder
    jobdetail_id?: SortOrder
    skill_id?: SortOrder
    over_year?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
  }

  export type CustomerExperienceMinOrderByAggregateInput = {
    experience_id?: SortOrder
    jobdetail_id?: SortOrder
    skill_id?: SortOrder
    over_year?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
  }

  export type CustomerExperienceSumOrderByAggregateInput = {
    skill_id?: SortOrder
    over_year?: SortOrder
  }

  export type CustomerExperienceListRelationFilter = {
    every?: CustomerExperienceWhereInput
    some?: CustomerExperienceWhereInput
    none?: CustomerExperienceWhereInput
  }

  export type CustomerExperienceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CustomerJobDetailCountOrderByAggregateInput = {
    jobdetail_id?: SortOrder
    customer_id?: SortOrder
    experienced_company?: SortOrder
    annual_income?: SortOrder
    has_management_exp?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
  }

  export type CustomerJobDetailAvgOrderByAggregateInput = {
    experienced_company?: SortOrder
    annual_income?: SortOrder
  }

  export type CustomerJobDetailMaxOrderByAggregateInput = {
    jobdetail_id?: SortOrder
    customer_id?: SortOrder
    experienced_company?: SortOrder
    annual_income?: SortOrder
    has_management_exp?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
  }

  export type CustomerJobDetailMinOrderByAggregateInput = {
    jobdetail_id?: SortOrder
    customer_id?: SortOrder
    experienced_company?: SortOrder
    annual_income?: SortOrder
    has_management_exp?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
  }

  export type CustomerJobDetailSumOrderByAggregateInput = {
    experienced_company?: SortOrder
    annual_income?: SortOrder
  }

  export type EnumLanguageLevelNullableFilter = {
    equals?: LanguageLevel | null
    in?: Enumerable<LanguageLevel> | null
    notIn?: Enumerable<LanguageLevel> | null
    not?: NestedEnumLanguageLevelNullableFilter | LanguageLevel | null
  }

  export type CustomerLanguageCountOrderByAggregateInput = {
    language_id?: SortOrder
    customer_id?: SortOrder
    level?: SortOrder
    language?: SortOrder
    is_motherlanguage?: SortOrder
    certificate?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    created_by?: SortOrder
    updated_b?: SortOrder
  }

  export type CustomerLanguageAvgOrderByAggregateInput = {
    language?: SortOrder
  }

  export type CustomerLanguageMaxOrderByAggregateInput = {
    language_id?: SortOrder
    customer_id?: SortOrder
    level?: SortOrder
    language?: SortOrder
    is_motherlanguage?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    created_by?: SortOrder
    updated_b?: SortOrder
  }

  export type CustomerLanguageMinOrderByAggregateInput = {
    language_id?: SortOrder
    customer_id?: SortOrder
    level?: SortOrder
    language?: SortOrder
    is_motherlanguage?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    created_by?: SortOrder
    updated_b?: SortOrder
  }

  export type CustomerLanguageSumOrderByAggregateInput = {
    language?: SortOrder
  }

  export type EnumLanguageLevelNullableWithAggregatesFilter = {
    equals?: LanguageLevel | null
    in?: Enumerable<LanguageLevel> | null
    notIn?: Enumerable<LanguageLevel> | null
    not?: NestedEnumLanguageLevelNullableWithAggregatesFilter | LanguageLevel | null
    _count?: NestedIntNullableFilter
    _min?: NestedEnumLanguageLevelNullableFilter
    _max?: NestedEnumLanguageLevelNullableFilter
  }

  export type CustomerQualificationCountOrderByAggregateInput = {
    qualification_id?: SortOrder
    customer_id?: SortOrder
    qualification?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
  }

  export type CustomerQualificationMaxOrderByAggregateInput = {
    qualification_id?: SortOrder
    customer_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
  }

  export type CustomerQualificationMinOrderByAggregateInput = {
    qualification_id?: SortOrder
    customer_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
  }

  export type EnumStatusVisaNullableFilter = {
    equals?: StatusVisa | null
    in?: Enumerable<StatusVisa> | null
    notIn?: Enumerable<StatusVisa> | null
    not?: NestedEnumStatusVisaNullableFilter | StatusVisa | null
  }

  export type CustomerVisaCountOrderByAggregateInput = {
    visa_id?: SortOrder
    customer_id?: SortOrder
    status_visa?: SortOrder
    date_expire?: SortOrder
    country_citizenship?: SortOrder
    back_visafile?: SortOrder
    front_visafile?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
  }

  export type CustomerVisaMaxOrderByAggregateInput = {
    visa_id?: SortOrder
    customer_id?: SortOrder
    status_visa?: SortOrder
    date_expire?: SortOrder
    country_citizenship?: SortOrder
    back_visafile?: SortOrder
    front_visafile?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
  }

  export type CustomerVisaMinOrderByAggregateInput = {
    visa_id?: SortOrder
    customer_id?: SortOrder
    status_visa?: SortOrder
    date_expire?: SortOrder
    country_citizenship?: SortOrder
    back_visafile?: SortOrder
    front_visafile?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
  }

  export type EnumStatusVisaNullableWithAggregatesFilter = {
    equals?: StatusVisa | null
    in?: Enumerable<StatusVisa> | null
    notIn?: Enumerable<StatusVisa> | null
    not?: NestedEnumStatusVisaNullableWithAggregatesFilter | StatusVisa | null
    _count?: NestedIntNullableFilter
    _min?: NestedEnumStatusVisaNullableFilter
    _max?: NestedEnumStatusVisaNullableFilter
  }

  export type EnumJobPositionNullableFilter = {
    equals?: JobPosition | null
    in?: Enumerable<JobPosition> | null
    notIn?: Enumerable<JobPosition> | null
    not?: NestedEnumJobPositionNullableFilter | JobPosition | null
  }

  export type CustomerWorkHistoryCountOrderByAggregateInput = {
    workhistory_id?: SortOrder
    customer_id?: SortOrder
    company_id?: SortOrder
    company_info?: SortOrder
    occupation?: SortOrder
    industry?: SortOrder
    position?: SortOrder
    enter_date?: SortOrder
    leave_date?: SortOrder
    working_month?: SortOrder
    is_current?: SortOrder
    duties?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
  }

  export type CustomerWorkHistoryAvgOrderByAggregateInput = {
    working_month?: SortOrder
  }

  export type CustomerWorkHistoryMaxOrderByAggregateInput = {
    workhistory_id?: SortOrder
    customer_id?: SortOrder
    company_id?: SortOrder
    position?: SortOrder
    enter_date?: SortOrder
    leave_date?: SortOrder
    working_month?: SortOrder
    is_current?: SortOrder
    duties?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
  }

  export type CustomerWorkHistoryMinOrderByAggregateInput = {
    workhistory_id?: SortOrder
    customer_id?: SortOrder
    company_id?: SortOrder
    position?: SortOrder
    enter_date?: SortOrder
    leave_date?: SortOrder
    working_month?: SortOrder
    is_current?: SortOrder
    duties?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
  }

  export type CustomerWorkHistorySumOrderByAggregateInput = {
    working_month?: SortOrder
  }

  export type EnumJobPositionNullableWithAggregatesFilter = {
    equals?: JobPosition | null
    in?: Enumerable<JobPosition> | null
    notIn?: Enumerable<JobPosition> | null
    not?: NestedEnumJobPositionNullableWithAggregatesFilter | JobPosition | null
    _count?: NestedIntNullableFilter
    _min?: NestedEnumJobPositionNullableFilter
    _max?: NestedEnumJobPositionNullableFilter
  }

  export type ReferenceListItemsListRelationFilter = {
    every?: ReferenceListItemsWhereInput
    some?: ReferenceListItemsWhereInput
    none?: ReferenceListItemsWhereInput
  }

  export type ReferenceListItemsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DictionaryDictionary_idLanguage_codeCompoundUniqueInput = {
    dictionary_id: number
    language_code: string
  }

  export type DictionaryCountOrderByAggregateInput = {
    dictionaries_id?: SortOrder
    dictionary_id?: SortOrder
    language_code?: SortOrder
    dic_value?: SortOrder
    created_at?: SortOrder
  }

  export type DictionaryAvgOrderByAggregateInput = {
    dictionary_id?: SortOrder
  }

  export type DictionaryMaxOrderByAggregateInput = {
    dictionaries_id?: SortOrder
    dictionary_id?: SortOrder
    language_code?: SortOrder
    dic_value?: SortOrder
    created_at?: SortOrder
  }

  export type DictionaryMinOrderByAggregateInput = {
    dictionaries_id?: SortOrder
    dictionary_id?: SortOrder
    language_code?: SortOrder
    dic_value?: SortOrder
    created_at?: SortOrder
  }

  export type DictionarySumOrderByAggregateInput = {
    dictionary_id?: SortOrder
  }

  export type EntityDetailListRelationFilter = {
    every?: EntityDetailWhereInput
    some?: EntityDetailWhereInput
    none?: EntityDetailWhereInput
  }

  export type EntityBranchListRelationFilter = {
    every?: EntityBranchWhereInput
    some?: EntityBranchWhereInput
    none?: EntityBranchWhereInput
  }

  export type EntityAccountInfoListRelationFilter = {
    every?: EntityAccountInfoWhereInput
    some?: EntityAccountInfoWhereInput
    none?: EntityAccountInfoWhereInput
  }

  export type InquiryListRelationFilter = {
    every?: InquiryWhereInput
    some?: InquiryWhereInput
    none?: InquiryWhereInput
  }

  export type EntityDetailOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EntityBranchOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EntityAccountInfoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InquiryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EntityCountOrderByAggregateInput = {
    entity_id?: SortOrder
    name?: SortOrder
    kana?: SortOrder
    logo?: SortOrder
    socials?: SortOrder
    gps?: SortOrder
    contact_person?: SortOrder
    contact_details?: SortOrder
    is_system?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
  }

  export type EntityAvgOrderByAggregateInput = {
    entity_id?: SortOrder
  }

  export type EntityMaxOrderByAggregateInput = {
    entity_id?: SortOrder
    name?: SortOrder
    kana?: SortOrder
    logo?: SortOrder
    is_system?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
  }

  export type EntityMinOrderByAggregateInput = {
    entity_id?: SortOrder
    name?: SortOrder
    kana?: SortOrder
    logo?: SortOrder
    is_system?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
  }

  export type EntitySumOrderByAggregateInput = {
    entity_id?: SortOrder
  }

  export type EntityRelationFilter = {
    is?: EntityWhereInput | null
    isNot?: EntityWhereInput | null
  }

  export type EntityAccountInfoCountOrderByAggregateInput = {
    entity_accountinfo_id?: SortOrder
    entity_id?: SortOrder
    bank_code?: SortOrder
    branch_code?: SortOrder
    account_id?: SortOrder
    is_default?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    updated_by?: SortOrder
    created_by?: SortOrder
  }

  export type EntityAccountInfoAvgOrderByAggregateInput = {
    entity_id?: SortOrder
  }

  export type EntityAccountInfoMaxOrderByAggregateInput = {
    entity_accountinfo_id?: SortOrder
    entity_id?: SortOrder
    bank_code?: SortOrder
    branch_code?: SortOrder
    account_id?: SortOrder
    is_default?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    updated_by?: SortOrder
    created_by?: SortOrder
  }

  export type EntityAccountInfoMinOrderByAggregateInput = {
    entity_accountinfo_id?: SortOrder
    entity_id?: SortOrder
    bank_code?: SortOrder
    branch_code?: SortOrder
    account_id?: SortOrder
    is_default?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    updated_by?: SortOrder
    created_by?: SortOrder
  }

  export type EntityAccountInfoSumOrderByAggregateInput = {
    entity_id?: SortOrder
  }

  export type JobListRelationFilter = {
    every?: JobWhereInput
    some?: JobWhereInput
    none?: JobWhereInput
  }

  export type JobOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EntityBranchCountOrderByAggregateInput = {
    branch_id?: SortOrder
    branch_name?: SortOrder
    kana?: SortOrder
    is_jeadquarter?: SortOrder
    image?: SortOrder
    prefecture?: SortOrder
    post_code?: SortOrder
    city?: SortOrder
    district?: SortOrder
    address?: SortOrder
    address1?: SortOrder
    nearest_station?: SortOrder
    socials?: SortOrder
    gps?: SortOrder
    contact_person?: SortOrder
    contact_details?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
    entity_id?: SortOrder
  }

  export type EntityBranchAvgOrderByAggregateInput = {
    branch_id?: SortOrder
    entity_id?: SortOrder
  }

  export type EntityBranchMaxOrderByAggregateInput = {
    branch_id?: SortOrder
    branch_name?: SortOrder
    kana?: SortOrder
    is_jeadquarter?: SortOrder
    image?: SortOrder
    post_code?: SortOrder
    city?: SortOrder
    district?: SortOrder
    address?: SortOrder
    address1?: SortOrder
    nearest_station?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
    entity_id?: SortOrder
  }

  export type EntityBranchMinOrderByAggregateInput = {
    branch_id?: SortOrder
    branch_name?: SortOrder
    kana?: SortOrder
    is_jeadquarter?: SortOrder
    image?: SortOrder
    post_code?: SortOrder
    city?: SortOrder
    district?: SortOrder
    address?: SortOrder
    address1?: SortOrder
    nearest_station?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
    entity_id?: SortOrder
  }

  export type EntityBranchSumOrderByAggregateInput = {
    branch_id?: SortOrder
    entity_id?: SortOrder
  }

  export type EntityDetailCountOrderByAggregateInput = {
    entity_detail_id?: SortOrder
    entity_id?: SortOrder
    establishment?: SortOrder
    capital?: SortOrder
    numberof_employees?: SortOrder
    business_performance?: SortOrder
    representative_telephone?: SortOrder
    representative?: SortOrder
    average_age?: SortOrder
    foreign_capitalratio?: SortOrder
    homepage?: SortOrder
    business_summary?: SortOrder
    organizational_structure?: SortOrder
    company_sales?: SortOrder
    workplace_environment?: SortOrder
    shareholder?: SortOrder
    related_company?: SortOrder
    recruitment_personname?: SortOrder
    memo?: SortOrder
    business_status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
  }

  export type EntityDetailAvgOrderByAggregateInput = {
    entity_id?: SortOrder
    capital?: SortOrder
    numberof_employees?: SortOrder
    average_age?: SortOrder
    foreign_capitalratio?: SortOrder
    related_company?: SortOrder
  }

  export type EntityDetailMaxOrderByAggregateInput = {
    entity_detail_id?: SortOrder
    entity_id?: SortOrder
    establishment?: SortOrder
    capital?: SortOrder
    numberof_employees?: SortOrder
    representative_telephone?: SortOrder
    representative?: SortOrder
    average_age?: SortOrder
    foreign_capitalratio?: SortOrder
    homepage?: SortOrder
    business_summary?: SortOrder
    organizational_structure?: SortOrder
    company_sales?: SortOrder
    workplace_environment?: SortOrder
    related_company?: SortOrder
    recruitment_personname?: SortOrder
    memo?: SortOrder
    business_status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
  }

  export type EntityDetailMinOrderByAggregateInput = {
    entity_detail_id?: SortOrder
    entity_id?: SortOrder
    establishment?: SortOrder
    capital?: SortOrder
    numberof_employees?: SortOrder
    representative_telephone?: SortOrder
    representative?: SortOrder
    average_age?: SortOrder
    foreign_capitalratio?: SortOrder
    homepage?: SortOrder
    business_summary?: SortOrder
    organizational_structure?: SortOrder
    company_sales?: SortOrder
    workplace_environment?: SortOrder
    related_company?: SortOrder
    recruitment_personname?: SortOrder
    memo?: SortOrder
    business_status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
  }

  export type EntityDetailSumOrderByAggregateInput = {
    entity_id?: SortOrder
    capital?: SortOrder
    numberof_employees?: SortOrder
    average_age?: SortOrder
    foreign_capitalratio?: SortOrder
    related_company?: SortOrder
  }

  export type EnumFileTypeFilter = {
    equals?: FileType
    in?: Enumerable<FileType>
    notIn?: Enumerable<FileType>
    not?: NestedEnumFileTypeFilter | FileType
  }

  export type EnumFileSourceFilter = {
    equals?: FileSource
    in?: Enumerable<FileSource>
    notIn?: Enumerable<FileSource>
    not?: NestedEnumFileSourceFilter | FileSource
  }

  export type FilesCountOrderByAggregateInput = {
    file_id?: SortOrder
    file_name?: SortOrder
    target_id?: SortOrder
    file_path?: SortOrder
    file_type?: SortOrder
    fiel_source?: SortOrder
    created_at?: SortOrder
    created_by?: SortOrder
  }

  export type FilesMaxOrderByAggregateInput = {
    file_id?: SortOrder
    file_name?: SortOrder
    target_id?: SortOrder
    file_path?: SortOrder
    file_type?: SortOrder
    fiel_source?: SortOrder
    created_at?: SortOrder
    created_by?: SortOrder
  }

  export type FilesMinOrderByAggregateInput = {
    file_id?: SortOrder
    file_name?: SortOrder
    target_id?: SortOrder
    file_path?: SortOrder
    file_type?: SortOrder
    fiel_source?: SortOrder
    created_at?: SortOrder
    created_by?: SortOrder
  }

  export type EnumFileTypeWithAggregatesFilter = {
    equals?: FileType
    in?: Enumerable<FileType>
    notIn?: Enumerable<FileType>
    not?: NestedEnumFileTypeWithAggregatesFilter | FileType
    _count?: NestedIntFilter
    _min?: NestedEnumFileTypeFilter
    _max?: NestedEnumFileTypeFilter
  }

  export type EnumFileSourceWithAggregatesFilter = {
    equals?: FileSource
    in?: Enumerable<FileSource>
    notIn?: Enumerable<FileSource>
    not?: NestedEnumFileSourceWithAggregatesFilter | FileSource
    _count?: NestedIntFilter
    _min?: NestedEnumFileSourceFilter
    _max?: NestedEnumFileSourceFilter
  }

  export type EnumInquiryStatusNullableFilter = {
    equals?: InquiryStatus | null
    in?: Enumerable<InquiryStatus> | null
    notIn?: Enumerable<InquiryStatus> | null
    not?: NestedEnumInquiryStatusNullableFilter | InquiryStatus | null
  }

  export type InquiryCountOrderByAggregateInput = {
    inquire_id?: SortOrder
    parent_id?: SortOrder
    fromuser_id?: SortOrder
    entity_id?: SortOrder
    assigned_user_id?: SortOrder
    subject?: SortOrder
    body?: SortOrder
    inquiry_status?: SortOrder
    is_read?: SortOrder
    is_answer?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    created_by?: SortOrder
  }

  export type InquiryAvgOrderByAggregateInput = {
    entity_id?: SortOrder
  }

  export type InquiryMaxOrderByAggregateInput = {
    inquire_id?: SortOrder
    parent_id?: SortOrder
    fromuser_id?: SortOrder
    entity_id?: SortOrder
    assigned_user_id?: SortOrder
    subject?: SortOrder
    body?: SortOrder
    inquiry_status?: SortOrder
    is_read?: SortOrder
    is_answer?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    created_by?: SortOrder
  }

  export type InquiryMinOrderByAggregateInput = {
    inquire_id?: SortOrder
    parent_id?: SortOrder
    fromuser_id?: SortOrder
    entity_id?: SortOrder
    assigned_user_id?: SortOrder
    subject?: SortOrder
    body?: SortOrder
    inquiry_status?: SortOrder
    is_read?: SortOrder
    is_answer?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    created_by?: SortOrder
  }

  export type InquirySumOrderByAggregateInput = {
    entity_id?: SortOrder
  }

  export type EnumInquiryStatusNullableWithAggregatesFilter = {
    equals?: InquiryStatus | null
    in?: Enumerable<InquiryStatus> | null
    notIn?: Enumerable<InquiryStatus> | null
    not?: NestedEnumInquiryStatusNullableWithAggregatesFilter | InquiryStatus | null
    _count?: NestedIntNullableFilter
    _min?: NestedEnumInquiryStatusNullableFilter
    _max?: NestedEnumInquiryStatusNullableFilter
  }

  export type EnumJobPublishFilter = {
    equals?: JobPublish
    in?: Enumerable<JobPublish>
    notIn?: Enumerable<JobPublish>
    not?: NestedEnumJobPublishFilter | JobPublish
  }

  export type JobReferenceListListRelationFilter = {
    every?: JobReferenceListWhereInput
    some?: JobReferenceListWhereInput
    none?: JobReferenceListWhereInput
  }

  export type EnumJobPositionNullableListFilter = {
    equals?: Enumerable<JobPosition> | null
    has?: JobPosition | null
    hasEvery?: Enumerable<JobPosition>
    hasSome?: Enumerable<JobPosition>
    isEmpty?: boolean
  }

  export type EnumSmokeNullableListFilter = {
    equals?: Enumerable<Smoke> | null
    has?: Smoke | null
    hasEvery?: Enumerable<Smoke>
    hasSome?: Enumerable<Smoke>
    isEmpty?: boolean
  }

  export type EnumEmploymentStatusFilter = {
    equals?: EmploymentStatus
    in?: Enumerable<EmploymentStatus>
    notIn?: Enumerable<EmploymentStatus>
    not?: NestedEnumEmploymentStatusFilter | EmploymentStatus
  }

  export type EnumLanguageLevelFilter = {
    equals?: LanguageLevel
    in?: Enumerable<LanguageLevel>
    notIn?: Enumerable<LanguageLevel>
    not?: NestedEnumLanguageLevelFilter | LanguageLevel
  }

  export type JobOtherLanguageListRelationFilter = {
    every?: JobOtherLanguageWhereInput
    some?: JobOtherLanguageWhereInput
    none?: JobOtherLanguageWhereInput
  }

  export type EnumReqriutmentTypeNullableFilter = {
    equals?: ReqriutmentType | null
    in?: Enumerable<ReqriutmentType> | null
    notIn?: Enumerable<ReqriutmentType> | null
    not?: NestedEnumReqriutmentTypeNullableFilter | ReqriutmentType | null
  }

  export type EnumSalaryTypeFilter = {
    equals?: SalaryType
    in?: Enumerable<SalaryType>
    notIn?: Enumerable<SalaryType>
    not?: NestedEnumSalaryTypeFilter | SalaryType
  }

  export type EntityBranchRelationFilter = {
    is?: EntityBranchWhereInput | null
    isNot?: EntityBranchWhereInput | null
  }

  export type JobRequirementListRelationFilter = {
    every?: JobRequirementWhereInput
    some?: JobRequirementWhereInput
    none?: JobRequirementWhereInput
  }

  export type JobReferenceListOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type JobOtherLanguageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type JobRequirementOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type JobCountOrderByAggregateInput = {
    job_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
    job_publish?: SortOrder
    location_details?: SortOrder
    career_level?: SortOrder
    benefit_other?: SortOrder
    smoke?: SortOrder
    employment_status?: SortOrder
    japanese_level?: SortOrder
    english_level?: SortOrder
    experienced_count?: SortOrder
    age_min?: SortOrder
    age_max?: SortOrder
    set_age_reason?: SortOrder
    recruitment_type?: SortOrder
    job_title?: SortOrder
    job_description?: SortOrder
    japanese_percentage?: SortOrder
    must_condition?: SortOrder
    want_condition?: SortOrder
    position_name?: SortOrder
    working_hour?: SortOrder
    salary_type?: SortOrder
    salary_min?: SortOrder
    salary_max?: SortOrder
    salary_detail?: SortOrder
    day_off?: SortOrder
    progress_detail?: SortOrder
    entity_branch_id?: SortOrder
    expire_date?: SortOrder
  }

  export type JobAvgOrderByAggregateInput = {
    experienced_count?: SortOrder
    age_min?: SortOrder
    age_max?: SortOrder
    japanese_percentage?: SortOrder
    salary_min?: SortOrder
    salary_max?: SortOrder
    entity_branch_id?: SortOrder
  }

  export type JobMaxOrderByAggregateInput = {
    job_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
    job_publish?: SortOrder
    location_details?: SortOrder
    benefit_other?: SortOrder
    employment_status?: SortOrder
    japanese_level?: SortOrder
    english_level?: SortOrder
    experienced_count?: SortOrder
    age_min?: SortOrder
    age_max?: SortOrder
    set_age_reason?: SortOrder
    recruitment_type?: SortOrder
    job_title?: SortOrder
    job_description?: SortOrder
    japanese_percentage?: SortOrder
    must_condition?: SortOrder
    want_condition?: SortOrder
    position_name?: SortOrder
    working_hour?: SortOrder
    salary_type?: SortOrder
    salary_min?: SortOrder
    salary_max?: SortOrder
    salary_detail?: SortOrder
    day_off?: SortOrder
    progress_detail?: SortOrder
    entity_branch_id?: SortOrder
    expire_date?: SortOrder
  }

  export type JobMinOrderByAggregateInput = {
    job_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
    job_publish?: SortOrder
    location_details?: SortOrder
    benefit_other?: SortOrder
    employment_status?: SortOrder
    japanese_level?: SortOrder
    english_level?: SortOrder
    experienced_count?: SortOrder
    age_min?: SortOrder
    age_max?: SortOrder
    set_age_reason?: SortOrder
    recruitment_type?: SortOrder
    job_title?: SortOrder
    job_description?: SortOrder
    japanese_percentage?: SortOrder
    must_condition?: SortOrder
    want_condition?: SortOrder
    position_name?: SortOrder
    working_hour?: SortOrder
    salary_type?: SortOrder
    salary_min?: SortOrder
    salary_max?: SortOrder
    salary_detail?: SortOrder
    day_off?: SortOrder
    progress_detail?: SortOrder
    entity_branch_id?: SortOrder
    expire_date?: SortOrder
  }

  export type JobSumOrderByAggregateInput = {
    experienced_count?: SortOrder
    age_min?: SortOrder
    age_max?: SortOrder
    japanese_percentage?: SortOrder
    salary_min?: SortOrder
    salary_max?: SortOrder
    entity_branch_id?: SortOrder
  }

  export type EnumJobPublishWithAggregatesFilter = {
    equals?: JobPublish
    in?: Enumerable<JobPublish>
    notIn?: Enumerable<JobPublish>
    not?: NestedEnumJobPublishWithAggregatesFilter | JobPublish
    _count?: NestedIntFilter
    _min?: NestedEnumJobPublishFilter
    _max?: NestedEnumJobPublishFilter
  }

  export type EnumEmploymentStatusWithAggregatesFilter = {
    equals?: EmploymentStatus
    in?: Enumerable<EmploymentStatus>
    notIn?: Enumerable<EmploymentStatus>
    not?: NestedEnumEmploymentStatusWithAggregatesFilter | EmploymentStatus
    _count?: NestedIntFilter
    _min?: NestedEnumEmploymentStatusFilter
    _max?: NestedEnumEmploymentStatusFilter
  }

  export type EnumLanguageLevelWithAggregatesFilter = {
    equals?: LanguageLevel
    in?: Enumerable<LanguageLevel>
    notIn?: Enumerable<LanguageLevel>
    not?: NestedEnumLanguageLevelWithAggregatesFilter | LanguageLevel
    _count?: NestedIntFilter
    _min?: NestedEnumLanguageLevelFilter
    _max?: NestedEnumLanguageLevelFilter
  }

  export type EnumReqriutmentTypeNullableWithAggregatesFilter = {
    equals?: ReqriutmentType | null
    in?: Enumerable<ReqriutmentType> | null
    notIn?: Enumerable<ReqriutmentType> | null
    not?: NestedEnumReqriutmentTypeNullableWithAggregatesFilter | ReqriutmentType | null
    _count?: NestedIntNullableFilter
    _min?: NestedEnumReqriutmentTypeNullableFilter
    _max?: NestedEnumReqriutmentTypeNullableFilter
  }

  export type EnumSalaryTypeWithAggregatesFilter = {
    equals?: SalaryType
    in?: Enumerable<SalaryType>
    notIn?: Enumerable<SalaryType>
    not?: NestedEnumSalaryTypeWithAggregatesFilter | SalaryType
    _count?: NestedIntFilter
    _min?: NestedEnumSalaryTypeFilter
    _max?: NestedEnumSalaryTypeFilter
  }

  export type JobRelationFilter = {
    is?: JobWhereInput
    isNot?: JobWhereInput
  }

  export type JobOtherLanguageCountOrderByAggregateInput = {
    job_other_language_id?: SortOrder
    language_id?: SortOrder
    language_level?: SortOrder
    job_id?: SortOrder
  }

  export type JobOtherLanguageAvgOrderByAggregateInput = {
    language_id?: SortOrder
  }

  export type JobOtherLanguageMaxOrderByAggregateInput = {
    job_other_language_id?: SortOrder
    language_id?: SortOrder
    language_level?: SortOrder
    job_id?: SortOrder
  }

  export type JobOtherLanguageMinOrderByAggregateInput = {
    job_other_language_id?: SortOrder
    language_id?: SortOrder
    language_level?: SortOrder
    job_id?: SortOrder
  }

  export type JobOtherLanguageSumOrderByAggregateInput = {
    language_id?: SortOrder
  }

  export type ReferenceListRelationFilter = {
    is?: ReferenceListWhereInput
    isNot?: ReferenceListWhereInput
  }

  export type JobReferenceListCountOrderByAggregateInput = {
    job_reference_id?: SortOrder
    job_id?: SortOrder
    reference_list_id?: SortOrder
    reference_list_item_id?: SortOrder
  }

  export type JobReferenceListAvgOrderByAggregateInput = {
    reference_list_id?: SortOrder
    reference_list_item_id?: SortOrder
  }

  export type JobReferenceListMaxOrderByAggregateInput = {
    job_reference_id?: SortOrder
    job_id?: SortOrder
    reference_list_id?: SortOrder
    reference_list_item_id?: SortOrder
  }

  export type JobReferenceListMinOrderByAggregateInput = {
    job_reference_id?: SortOrder
    job_id?: SortOrder
    reference_list_id?: SortOrder
    reference_list_item_id?: SortOrder
  }

  export type JobReferenceListSumOrderByAggregateInput = {
    reference_list_id?: SortOrder
    reference_list_item_id?: SortOrder
  }

  export type JobCandidateCountOrderByAggregateInput = {
    job_candidate_id?: SortOrder
    job_id?: SortOrder
    customer_id?: SortOrder
    candidate_status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
  }

  export type JobCandidateAvgOrderByAggregateInput = {
    candidate_status?: SortOrder
  }

  export type JobCandidateMaxOrderByAggregateInput = {
    job_candidate_id?: SortOrder
    job_id?: SortOrder
    customer_id?: SortOrder
    candidate_status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
  }

  export type JobCandidateMinOrderByAggregateInput = {
    job_candidate_id?: SortOrder
    job_id?: SortOrder
    customer_id?: SortOrder
    candidate_status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
  }

  export type JobCandidateSumOrderByAggregateInput = {
    candidate_status?: SortOrder
  }

  export type JobRequirementCountOrderByAggregateInput = {
    job_require_id?: SortOrder
    job_id?: SortOrder
    require_id?: SortOrder
    require_detial?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
  }

  export type JobRequirementAvgOrderByAggregateInput = {
    require_id?: SortOrder
  }

  export type JobRequirementMaxOrderByAggregateInput = {
    job_require_id?: SortOrder
    job_id?: SortOrder
    require_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
  }

  export type JobRequirementMinOrderByAggregateInput = {
    job_require_id?: SortOrder
    job_id?: SortOrder
    require_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
  }

  export type JobRequirementSumOrderByAggregateInput = {
    require_id?: SortOrder
  }

  export type SystemLangaugeCountOrderByAggregateInput = {
    language_id?: SortOrder
    language_code?: SortOrder
    is_default?: SortOrder
  }

  export type SystemLangaugeAvgOrderByAggregateInput = {
    language_id?: SortOrder
  }

  export type SystemLangaugeMaxOrderByAggregateInput = {
    language_id?: SortOrder
    language_code?: SortOrder
    is_default?: SortOrder
  }

  export type SystemLangaugeMinOrderByAggregateInput = {
    language_id?: SortOrder
    language_code?: SortOrder
    is_default?: SortOrder
  }

  export type SystemLangaugeSumOrderByAggregateInput = {
    language_id?: SortOrder
  }

  export type LoggerCountOrderByAggregateInput = {
    log_id?: SortOrder
    action_user?: SortOrder
    user_id?: SortOrder
    new_value?: SortOrder
    old_value?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
  }

  export type LoggerMaxOrderByAggregateInput = {
    log_id?: SortOrder
    action_user?: SortOrder
    user_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
  }

  export type LoggerMinOrderByAggregateInput = {
    log_id?: SortOrder
    action_user?: SortOrder
    user_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
  }

  export type PagesRelationFilter = {
    is?: PagesWhereInput
    isNot?: PagesWhereInput
  }

  export type NewsCountOrderByAggregateInput = {
    news_id?: SortOrder
    page_id?: SortOrder
    title?: SortOrder
    brief?: SortOrder
    image_id?: SortOrder
    content?: SortOrder
    is_top?: SortOrder
    is_publish?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    created_by?: SortOrder
    update_by?: SortOrder
  }

  export type NewsAvgOrderByAggregateInput = {
    page_id?: SortOrder
  }

  export type NewsMaxOrderByAggregateInput = {
    news_id?: SortOrder
    page_id?: SortOrder
    title?: SortOrder
    brief?: SortOrder
    image_id?: SortOrder
    content?: SortOrder
    is_top?: SortOrder
    is_publish?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    created_by?: SortOrder
    update_by?: SortOrder
  }

  export type NewsMinOrderByAggregateInput = {
    news_id?: SortOrder
    page_id?: SortOrder
    title?: SortOrder
    brief?: SortOrder
    image_id?: SortOrder
    content?: SortOrder
    is_top?: SortOrder
    is_publish?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    created_by?: SortOrder
    update_by?: SortOrder
  }

  export type NewsSumOrderByAggregateInput = {
    page_id?: SortOrder
  }

  export type NotificationCountOrderByAggregateInput = {
    notifiation_id?: SortOrder
    user_id?: SortOrder
    link?: SortOrder
    message?: SortOrder
    is_new?: SortOrder
    is_badge?: SortOrder
    created_at?: SortOrder
    created_by?: SortOrder
  }

  export type NotificationMaxOrderByAggregateInput = {
    notifiation_id?: SortOrder
    user_id?: SortOrder
    link?: SortOrder
    message?: SortOrder
    is_new?: SortOrder
    is_badge?: SortOrder
    created_at?: SortOrder
    created_by?: SortOrder
  }

  export type NotificationMinOrderByAggregateInput = {
    notifiation_id?: SortOrder
    user_id?: SortOrder
    link?: SortOrder
    message?: SortOrder
    is_new?: SortOrder
    is_badge?: SortOrder
    created_at?: SortOrder
    created_by?: SortOrder
  }

  export type NewsListRelationFilter = {
    every?: NewsWhereInput
    some?: NewsWhereInput
    none?: NewsWhereInput
  }

  export type NewsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PagesCountOrderByAggregateInput = {
    page_id?: SortOrder
    page_name?: SortOrder
    page_type?: SortOrder
    created_at?: SortOrder
    created_by?: SortOrder
  }

  export type PagesAvgOrderByAggregateInput = {
    page_id?: SortOrder
    page_type?: SortOrder
  }

  export type PagesMaxOrderByAggregateInput = {
    page_id?: SortOrder
    page_name?: SortOrder
    page_type?: SortOrder
    created_at?: SortOrder
    created_by?: SortOrder
  }

  export type PagesMinOrderByAggregateInput = {
    page_id?: SortOrder
    page_name?: SortOrder
    page_type?: SortOrder
    created_at?: SortOrder
    created_by?: SortOrder
  }

  export type PagesSumOrderByAggregateInput = {
    page_id?: SortOrder
    page_type?: SortOrder
  }

  export type ReferenceListCountOrderByAggregateInput = {
    list_id?: SortOrder
    list_name?: SortOrder
    created_at?: SortOrder
  }

  export type ReferenceListAvgOrderByAggregateInput = {
    list_id?: SortOrder
  }

  export type ReferenceListMaxOrderByAggregateInput = {
    list_id?: SortOrder
    list_name?: SortOrder
    created_at?: SortOrder
  }

  export type ReferenceListMinOrderByAggregateInput = {
    list_id?: SortOrder
    list_name?: SortOrder
    created_at?: SortOrder
  }

  export type ReferenceListSumOrderByAggregateInput = {
    list_id?: SortOrder
  }

  export type DictionaryRelationFilter = {
    is?: DictionaryWhereInput | null
    isNot?: DictionaryWhereInput | null
  }

  export type ReferenceListItemsCountOrderByAggregateInput = {
    listitem_id?: SortOrder
    list_id?: SortOrder
    dictionary_id?: SortOrder
    code?: SortOrder
    listitem_value?: SortOrder
    parent_id?: SortOrder
    value?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    dictionaryDictionaries_id?: SortOrder
  }

  export type ReferenceListItemsAvgOrderByAggregateInput = {
    listitem_id?: SortOrder
    list_id?: SortOrder
    dictionary_id?: SortOrder
    parent_id?: SortOrder
  }

  export type ReferenceListItemsMaxOrderByAggregateInput = {
    listitem_id?: SortOrder
    list_id?: SortOrder
    dictionary_id?: SortOrder
    code?: SortOrder
    listitem_value?: SortOrder
    parent_id?: SortOrder
    value?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    dictionaryDictionaries_id?: SortOrder
  }

  export type ReferenceListItemsMinOrderByAggregateInput = {
    listitem_id?: SortOrder
    list_id?: SortOrder
    dictionary_id?: SortOrder
    code?: SortOrder
    listitem_value?: SortOrder
    parent_id?: SortOrder
    value?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    dictionaryDictionaries_id?: SortOrder
  }

  export type ReferenceListItemsSumOrderByAggregateInput = {
    listitem_id?: SortOrder
    list_id?: SortOrder
    dictionary_id?: SortOrder
    parent_id?: SortOrder
  }

  export type ScoutFavCountOrderByAggregateInput = {
    scout_id?: SortOrder
    entity_id?: SortOrder
    branch_id?: SortOrder
    user_id?: SortOrder
    job_id?: SortOrder
    note?: SortOrder
    created_at?: SortOrder
    created_by?: SortOrder
  }

  export type ScoutFavAvgOrderByAggregateInput = {
    entity_id?: SortOrder
    branch_id?: SortOrder
  }

  export type ScoutFavMaxOrderByAggregateInput = {
    scout_id?: SortOrder
    entity_id?: SortOrder
    branch_id?: SortOrder
    user_id?: SortOrder
    job_id?: SortOrder
    note?: SortOrder
    created_at?: SortOrder
    created_by?: SortOrder
  }

  export type ScoutFavMinOrderByAggregateInput = {
    scout_id?: SortOrder
    entity_id?: SortOrder
    branch_id?: SortOrder
    user_id?: SortOrder
    job_id?: SortOrder
    note?: SortOrder
    created_at?: SortOrder
    created_by?: SortOrder
  }

  export type ScoutFavSumOrderByAggregateInput = {
    entity_id?: SortOrder
    branch_id?: SortOrder
  }

  export type EnumUserStatusFilter = {
    equals?: UserStatus
    in?: Enumerable<UserStatus>
    notIn?: Enumerable<UserStatus>
    not?: NestedEnumUserStatusFilter | UserStatus
  }
  export type JsonFilter = 
    | PatchUndefined<
        Either<Required<JsonFilterBase>, Exclude<keyof Required<JsonFilterBase>, 'path'>>,
        Required<JsonFilterBase>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase>, 'path'>>

  export type JsonFilterBase = {
    equals?: InputJsonValue | JsonNullValueFilter
    path?: Array<string>
    string_contains?: string
    string_starts_with?: string
    string_ends_with?: string
    array_contains?: InputJsonValue | null
    array_starts_with?: InputJsonValue | null
    array_ends_with?: InputJsonValue | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonNullValueFilter
  }

  export type LoggerListRelationFilter = {
    every?: LoggerWhereInput
    some?: LoggerWhereInput
    none?: LoggerWhereInput
  }

  export type NotificationListRelationFilter = {
    every?: NotificationWhereInput
    some?: NotificationWhereInput
    none?: NotificationWhereInput
  }

  export type ScoutFavListRelationFilter = {
    every?: ScoutFavWhereInput
    some?: ScoutFavWhereInput
    none?: ScoutFavWhereInput
  }

  export type LoggerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ScoutFavOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserEmailMobileCompoundUniqueInput = {
    email: string
    mobile: string
  }

  export type UserCountOrderByAggregateInput = {
    user_id?: SortOrder
    email?: SortOrder
    mobile?: SortOrder
    name?: SortOrder
    password_hash?: SortOrder
    role?: SortOrder
    company_id?: SortOrder
    customer_id?: SortOrder
    attemptpass_count?: SortOrder
    reset_code?: SortOrder
    is_emailverified?: SortOrder
    is_mobileverified?: SortOrder
    user_status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
    favs?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    company_id?: SortOrder
    attemptpass_count?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    user_id?: SortOrder
    email?: SortOrder
    mobile?: SortOrder
    name?: SortOrder
    password_hash?: SortOrder
    role?: SortOrder
    company_id?: SortOrder
    customer_id?: SortOrder
    attemptpass_count?: SortOrder
    reset_code?: SortOrder
    is_emailverified?: SortOrder
    is_mobileverified?: SortOrder
    user_status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    user_id?: SortOrder
    email?: SortOrder
    mobile?: SortOrder
    name?: SortOrder
    password_hash?: SortOrder
    role?: SortOrder
    company_id?: SortOrder
    customer_id?: SortOrder
    attemptpass_count?: SortOrder
    reset_code?: SortOrder
    is_emailverified?: SortOrder
    is_mobileverified?: SortOrder
    user_status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    company_id?: SortOrder
    attemptpass_count?: SortOrder
  }

  export type EnumUserStatusWithAggregatesFilter = {
    equals?: UserStatus
    in?: Enumerable<UserStatus>
    notIn?: Enumerable<UserStatus>
    not?: NestedEnumUserStatusWithAggregatesFilter | UserStatus
    _count?: NestedIntFilter
    _min?: NestedEnumUserStatusFilter
    _max?: NestedEnumUserStatusFilter
  }
  export type JsonWithAggregatesFilter = 
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase>, Exclude<keyof Required<JsonWithAggregatesFilterBase>, 'path'>>,
        Required<JsonWithAggregatesFilterBase>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase>, 'path'>>

  export type JsonWithAggregatesFilterBase = {
    equals?: InputJsonValue | JsonNullValueFilter
    path?: Array<string>
    string_contains?: string
    string_starts_with?: string
    string_ends_with?: string
    array_contains?: InputJsonValue | null
    array_starts_with?: InputJsonValue | null
    array_ends_with?: InputJsonValue | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonNullValueFilter
    _count?: NestedIntFilter
    _min?: NestedJsonFilter
    _max?: NestedJsonFilter
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type EnumUserActionFieldUpdateOperationsInput = {
    set?: UserAction
  }

  export type EnumUserRoleFieldUpdateOperationsInput = {
    set?: UserRole
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type UserCreateNestedOneWithoutCustomerInput = {
    create?: XOR<UserCreateWithoutCustomerInput, UserUncheckedCreateWithoutCustomerInput>
    connectOrCreate?: UserCreateOrConnectWithoutCustomerInput
    connect?: UserWhereUniqueInput
  }

  export type CustomerVisaCreateNestedManyWithoutCustomerInput = {
    create?: XOR<Enumerable<CustomerVisaCreateWithoutCustomerInput>, Enumerable<CustomerVisaUncheckedCreateWithoutCustomerInput>>
    connectOrCreate?: Enumerable<CustomerVisaCreateOrConnectWithoutCustomerInput>
    createMany?: CustomerVisaCreateManyCustomerInputEnvelope
    connect?: Enumerable<CustomerVisaWhereUniqueInput>
  }

  export type CustomerJobDetailCreateNestedManyWithoutCustomerInput = {
    create?: XOR<Enumerable<CustomerJobDetailCreateWithoutCustomerInput>, Enumerable<CustomerJobDetailUncheckedCreateWithoutCustomerInput>>
    connectOrCreate?: Enumerable<CustomerJobDetailCreateOrConnectWithoutCustomerInput>
    createMany?: CustomerJobDetailCreateManyCustomerInputEnvelope
    connect?: Enumerable<CustomerJobDetailWhereUniqueInput>
  }

  export type CustomerEducationCreateNestedManyWithoutCustomerInput = {
    create?: XOR<Enumerable<CustomerEducationCreateWithoutCustomerInput>, Enumerable<CustomerEducationUncheckedCreateWithoutCustomerInput>>
    connectOrCreate?: Enumerable<CustomerEducationCreateOrConnectWithoutCustomerInput>
    createMany?: CustomerEducationCreateManyCustomerInputEnvelope
    connect?: Enumerable<CustomerEducationWhereUniqueInput>
  }

  export type CustomerLanguageCreateNestedManyWithoutCustomerInput = {
    create?: XOR<Enumerable<CustomerLanguageCreateWithoutCustomerInput>, Enumerable<CustomerLanguageUncheckedCreateWithoutCustomerInput>>
    connectOrCreate?: Enumerable<CustomerLanguageCreateOrConnectWithoutCustomerInput>
    createMany?: CustomerLanguageCreateManyCustomerInputEnvelope
    connect?: Enumerable<CustomerLanguageWhereUniqueInput>
  }

  export type CustomerQualificationCreateNestedManyWithoutCustomersInput = {
    create?: XOR<Enumerable<CustomerQualificationCreateWithoutCustomersInput>, Enumerable<CustomerQualificationUncheckedCreateWithoutCustomersInput>>
    connectOrCreate?: Enumerable<CustomerQualificationCreateOrConnectWithoutCustomersInput>
    createMany?: CustomerQualificationCreateManyCustomersInputEnvelope
    connect?: Enumerable<CustomerQualificationWhereUniqueInput>
  }

  export type CustomerWorkHistoryCreateNestedManyWithoutCustomerInput = {
    create?: XOR<Enumerable<CustomerWorkHistoryCreateWithoutCustomerInput>, Enumerable<CustomerWorkHistoryUncheckedCreateWithoutCustomerInput>>
    connectOrCreate?: Enumerable<CustomerWorkHistoryCreateOrConnectWithoutCustomerInput>
    createMany?: CustomerWorkHistoryCreateManyCustomerInputEnvelope
    connect?: Enumerable<CustomerWorkHistoryWhereUniqueInput>
  }

  export type JobCandidateCreateNestedManyWithoutCustomerInput = {
    create?: XOR<Enumerable<JobCandidateCreateWithoutCustomerInput>, Enumerable<JobCandidateUncheckedCreateWithoutCustomerInput>>
    connectOrCreate?: Enumerable<JobCandidateCreateOrConnectWithoutCustomerInput>
    createMany?: JobCandidateCreateManyCustomerInputEnvelope
    connect?: Enumerable<JobCandidateWhereUniqueInput>
  }

  export type CustomerDesiredCreateNestedManyWithoutCustomerInput = {
    create?: XOR<Enumerable<CustomerDesiredCreateWithoutCustomerInput>, Enumerable<CustomerDesiredUncheckedCreateWithoutCustomerInput>>
    connectOrCreate?: Enumerable<CustomerDesiredCreateOrConnectWithoutCustomerInput>
    createMany?: CustomerDesiredCreateManyCustomerInputEnvelope
    connect?: Enumerable<CustomerDesiredWhereUniqueInput>
  }

  export type UserUncheckedCreateNestedOneWithoutCustomerInput = {
    create?: XOR<UserCreateWithoutCustomerInput, UserUncheckedCreateWithoutCustomerInput>
    connectOrCreate?: UserCreateOrConnectWithoutCustomerInput
    connect?: UserWhereUniqueInput
  }

  export type CustomerVisaUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<Enumerable<CustomerVisaCreateWithoutCustomerInput>, Enumerable<CustomerVisaUncheckedCreateWithoutCustomerInput>>
    connectOrCreate?: Enumerable<CustomerVisaCreateOrConnectWithoutCustomerInput>
    createMany?: CustomerVisaCreateManyCustomerInputEnvelope
    connect?: Enumerable<CustomerVisaWhereUniqueInput>
  }

  export type CustomerJobDetailUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<Enumerable<CustomerJobDetailCreateWithoutCustomerInput>, Enumerable<CustomerJobDetailUncheckedCreateWithoutCustomerInput>>
    connectOrCreate?: Enumerable<CustomerJobDetailCreateOrConnectWithoutCustomerInput>
    createMany?: CustomerJobDetailCreateManyCustomerInputEnvelope
    connect?: Enumerable<CustomerJobDetailWhereUniqueInput>
  }

  export type CustomerEducationUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<Enumerable<CustomerEducationCreateWithoutCustomerInput>, Enumerable<CustomerEducationUncheckedCreateWithoutCustomerInput>>
    connectOrCreate?: Enumerable<CustomerEducationCreateOrConnectWithoutCustomerInput>
    createMany?: CustomerEducationCreateManyCustomerInputEnvelope
    connect?: Enumerable<CustomerEducationWhereUniqueInput>
  }

  export type CustomerLanguageUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<Enumerable<CustomerLanguageCreateWithoutCustomerInput>, Enumerable<CustomerLanguageUncheckedCreateWithoutCustomerInput>>
    connectOrCreate?: Enumerable<CustomerLanguageCreateOrConnectWithoutCustomerInput>
    createMany?: CustomerLanguageCreateManyCustomerInputEnvelope
    connect?: Enumerable<CustomerLanguageWhereUniqueInput>
  }

  export type CustomerQualificationUncheckedCreateNestedManyWithoutCustomersInput = {
    create?: XOR<Enumerable<CustomerQualificationCreateWithoutCustomersInput>, Enumerable<CustomerQualificationUncheckedCreateWithoutCustomersInput>>
    connectOrCreate?: Enumerable<CustomerQualificationCreateOrConnectWithoutCustomersInput>
    createMany?: CustomerQualificationCreateManyCustomersInputEnvelope
    connect?: Enumerable<CustomerQualificationWhereUniqueInput>
  }

  export type CustomerWorkHistoryUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<Enumerable<CustomerWorkHistoryCreateWithoutCustomerInput>, Enumerable<CustomerWorkHistoryUncheckedCreateWithoutCustomerInput>>
    connectOrCreate?: Enumerable<CustomerWorkHistoryCreateOrConnectWithoutCustomerInput>
    createMany?: CustomerWorkHistoryCreateManyCustomerInputEnvelope
    connect?: Enumerable<CustomerWorkHistoryWhereUniqueInput>
  }

  export type JobCandidateUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<Enumerable<JobCandidateCreateWithoutCustomerInput>, Enumerable<JobCandidateUncheckedCreateWithoutCustomerInput>>
    connectOrCreate?: Enumerable<JobCandidateCreateOrConnectWithoutCustomerInput>
    createMany?: JobCandidateCreateManyCustomerInputEnvelope
    connect?: Enumerable<JobCandidateWhereUniqueInput>
  }

  export type CustomerDesiredUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<Enumerable<CustomerDesiredCreateWithoutCustomerInput>, Enumerable<CustomerDesiredUncheckedCreateWithoutCustomerInput>>
    connectOrCreate?: Enumerable<CustomerDesiredCreateOrConnectWithoutCustomerInput>
    createMany?: CustomerDesiredCreateManyCustomerInputEnvelope
    connect?: Enumerable<CustomerDesiredWhereUniqueInput>
  }

  export type NullableEnumGenderFieldUpdateOperationsInput = {
    set?: Gender | null
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableEnumCustomerStatusFieldUpdateOperationsInput = {
    set?: CustomerStatus | null
  }

  export type UserUpdateOneWithoutCustomerNestedInput = {
    create?: XOR<UserCreateWithoutCustomerInput, UserUncheckedCreateWithoutCustomerInput>
    connectOrCreate?: UserCreateOrConnectWithoutCustomerInput
    upsert?: UserUpsertWithoutCustomerInput
    disconnect?: boolean
    delete?: boolean
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutCustomerInput, UserUncheckedUpdateWithoutCustomerInput>
  }

  export type CustomerVisaUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<Enumerable<CustomerVisaCreateWithoutCustomerInput>, Enumerable<CustomerVisaUncheckedCreateWithoutCustomerInput>>
    connectOrCreate?: Enumerable<CustomerVisaCreateOrConnectWithoutCustomerInput>
    upsert?: Enumerable<CustomerVisaUpsertWithWhereUniqueWithoutCustomerInput>
    createMany?: CustomerVisaCreateManyCustomerInputEnvelope
    set?: Enumerable<CustomerVisaWhereUniqueInput>
    disconnect?: Enumerable<CustomerVisaWhereUniqueInput>
    delete?: Enumerable<CustomerVisaWhereUniqueInput>
    connect?: Enumerable<CustomerVisaWhereUniqueInput>
    update?: Enumerable<CustomerVisaUpdateWithWhereUniqueWithoutCustomerInput>
    updateMany?: Enumerable<CustomerVisaUpdateManyWithWhereWithoutCustomerInput>
    deleteMany?: Enumerable<CustomerVisaScalarWhereInput>
  }

  export type CustomerJobDetailUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<Enumerable<CustomerJobDetailCreateWithoutCustomerInput>, Enumerable<CustomerJobDetailUncheckedCreateWithoutCustomerInput>>
    connectOrCreate?: Enumerable<CustomerJobDetailCreateOrConnectWithoutCustomerInput>
    upsert?: Enumerable<CustomerJobDetailUpsertWithWhereUniqueWithoutCustomerInput>
    createMany?: CustomerJobDetailCreateManyCustomerInputEnvelope
    set?: Enumerable<CustomerJobDetailWhereUniqueInput>
    disconnect?: Enumerable<CustomerJobDetailWhereUniqueInput>
    delete?: Enumerable<CustomerJobDetailWhereUniqueInput>
    connect?: Enumerable<CustomerJobDetailWhereUniqueInput>
    update?: Enumerable<CustomerJobDetailUpdateWithWhereUniqueWithoutCustomerInput>
    updateMany?: Enumerable<CustomerJobDetailUpdateManyWithWhereWithoutCustomerInput>
    deleteMany?: Enumerable<CustomerJobDetailScalarWhereInput>
  }

  export type CustomerEducationUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<Enumerable<CustomerEducationCreateWithoutCustomerInput>, Enumerable<CustomerEducationUncheckedCreateWithoutCustomerInput>>
    connectOrCreate?: Enumerable<CustomerEducationCreateOrConnectWithoutCustomerInput>
    upsert?: Enumerable<CustomerEducationUpsertWithWhereUniqueWithoutCustomerInput>
    createMany?: CustomerEducationCreateManyCustomerInputEnvelope
    set?: Enumerable<CustomerEducationWhereUniqueInput>
    disconnect?: Enumerable<CustomerEducationWhereUniqueInput>
    delete?: Enumerable<CustomerEducationWhereUniqueInput>
    connect?: Enumerable<CustomerEducationWhereUniqueInput>
    update?: Enumerable<CustomerEducationUpdateWithWhereUniqueWithoutCustomerInput>
    updateMany?: Enumerable<CustomerEducationUpdateManyWithWhereWithoutCustomerInput>
    deleteMany?: Enumerable<CustomerEducationScalarWhereInput>
  }

  export type CustomerLanguageUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<Enumerable<CustomerLanguageCreateWithoutCustomerInput>, Enumerable<CustomerLanguageUncheckedCreateWithoutCustomerInput>>
    connectOrCreate?: Enumerable<CustomerLanguageCreateOrConnectWithoutCustomerInput>
    upsert?: Enumerable<CustomerLanguageUpsertWithWhereUniqueWithoutCustomerInput>
    createMany?: CustomerLanguageCreateManyCustomerInputEnvelope
    set?: Enumerable<CustomerLanguageWhereUniqueInput>
    disconnect?: Enumerable<CustomerLanguageWhereUniqueInput>
    delete?: Enumerable<CustomerLanguageWhereUniqueInput>
    connect?: Enumerable<CustomerLanguageWhereUniqueInput>
    update?: Enumerable<CustomerLanguageUpdateWithWhereUniqueWithoutCustomerInput>
    updateMany?: Enumerable<CustomerLanguageUpdateManyWithWhereWithoutCustomerInput>
    deleteMany?: Enumerable<CustomerLanguageScalarWhereInput>
  }

  export type CustomerQualificationUpdateManyWithoutCustomersNestedInput = {
    create?: XOR<Enumerable<CustomerQualificationCreateWithoutCustomersInput>, Enumerable<CustomerQualificationUncheckedCreateWithoutCustomersInput>>
    connectOrCreate?: Enumerable<CustomerQualificationCreateOrConnectWithoutCustomersInput>
    upsert?: Enumerable<CustomerQualificationUpsertWithWhereUniqueWithoutCustomersInput>
    createMany?: CustomerQualificationCreateManyCustomersInputEnvelope
    set?: Enumerable<CustomerQualificationWhereUniqueInput>
    disconnect?: Enumerable<CustomerQualificationWhereUniqueInput>
    delete?: Enumerable<CustomerQualificationWhereUniqueInput>
    connect?: Enumerable<CustomerQualificationWhereUniqueInput>
    update?: Enumerable<CustomerQualificationUpdateWithWhereUniqueWithoutCustomersInput>
    updateMany?: Enumerable<CustomerQualificationUpdateManyWithWhereWithoutCustomersInput>
    deleteMany?: Enumerable<CustomerQualificationScalarWhereInput>
  }

  export type CustomerWorkHistoryUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<Enumerable<CustomerWorkHistoryCreateWithoutCustomerInput>, Enumerable<CustomerWorkHistoryUncheckedCreateWithoutCustomerInput>>
    connectOrCreate?: Enumerable<CustomerWorkHistoryCreateOrConnectWithoutCustomerInput>
    upsert?: Enumerable<CustomerWorkHistoryUpsertWithWhereUniqueWithoutCustomerInput>
    createMany?: CustomerWorkHistoryCreateManyCustomerInputEnvelope
    set?: Enumerable<CustomerWorkHistoryWhereUniqueInput>
    disconnect?: Enumerable<CustomerWorkHistoryWhereUniqueInput>
    delete?: Enumerable<CustomerWorkHistoryWhereUniqueInput>
    connect?: Enumerable<CustomerWorkHistoryWhereUniqueInput>
    update?: Enumerable<CustomerWorkHistoryUpdateWithWhereUniqueWithoutCustomerInput>
    updateMany?: Enumerable<CustomerWorkHistoryUpdateManyWithWhereWithoutCustomerInput>
    deleteMany?: Enumerable<CustomerWorkHistoryScalarWhereInput>
  }

  export type JobCandidateUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<Enumerable<JobCandidateCreateWithoutCustomerInput>, Enumerable<JobCandidateUncheckedCreateWithoutCustomerInput>>
    connectOrCreate?: Enumerable<JobCandidateCreateOrConnectWithoutCustomerInput>
    upsert?: Enumerable<JobCandidateUpsertWithWhereUniqueWithoutCustomerInput>
    createMany?: JobCandidateCreateManyCustomerInputEnvelope
    set?: Enumerable<JobCandidateWhereUniqueInput>
    disconnect?: Enumerable<JobCandidateWhereUniqueInput>
    delete?: Enumerable<JobCandidateWhereUniqueInput>
    connect?: Enumerable<JobCandidateWhereUniqueInput>
    update?: Enumerable<JobCandidateUpdateWithWhereUniqueWithoutCustomerInput>
    updateMany?: Enumerable<JobCandidateUpdateManyWithWhereWithoutCustomerInput>
    deleteMany?: Enumerable<JobCandidateScalarWhereInput>
  }

  export type CustomerDesiredUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<Enumerable<CustomerDesiredCreateWithoutCustomerInput>, Enumerable<CustomerDesiredUncheckedCreateWithoutCustomerInput>>
    connectOrCreate?: Enumerable<CustomerDesiredCreateOrConnectWithoutCustomerInput>
    upsert?: Enumerable<CustomerDesiredUpsertWithWhereUniqueWithoutCustomerInput>
    createMany?: CustomerDesiredCreateManyCustomerInputEnvelope
    set?: Enumerable<CustomerDesiredWhereUniqueInput>
    disconnect?: Enumerable<CustomerDesiredWhereUniqueInput>
    delete?: Enumerable<CustomerDesiredWhereUniqueInput>
    connect?: Enumerable<CustomerDesiredWhereUniqueInput>
    update?: Enumerable<CustomerDesiredUpdateWithWhereUniqueWithoutCustomerInput>
    updateMany?: Enumerable<CustomerDesiredUpdateManyWithWhereWithoutCustomerInput>
    deleteMany?: Enumerable<CustomerDesiredScalarWhereInput>
  }

  export type UserUncheckedUpdateOneWithoutCustomerNestedInput = {
    create?: XOR<UserCreateWithoutCustomerInput, UserUncheckedCreateWithoutCustomerInput>
    connectOrCreate?: UserCreateOrConnectWithoutCustomerInput
    upsert?: UserUpsertWithoutCustomerInput
    disconnect?: boolean
    delete?: boolean
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutCustomerInput, UserUncheckedUpdateWithoutCustomerInput>
  }

  export type CustomerVisaUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<Enumerable<CustomerVisaCreateWithoutCustomerInput>, Enumerable<CustomerVisaUncheckedCreateWithoutCustomerInput>>
    connectOrCreate?: Enumerable<CustomerVisaCreateOrConnectWithoutCustomerInput>
    upsert?: Enumerable<CustomerVisaUpsertWithWhereUniqueWithoutCustomerInput>
    createMany?: CustomerVisaCreateManyCustomerInputEnvelope
    set?: Enumerable<CustomerVisaWhereUniqueInput>
    disconnect?: Enumerable<CustomerVisaWhereUniqueInput>
    delete?: Enumerable<CustomerVisaWhereUniqueInput>
    connect?: Enumerable<CustomerVisaWhereUniqueInput>
    update?: Enumerable<CustomerVisaUpdateWithWhereUniqueWithoutCustomerInput>
    updateMany?: Enumerable<CustomerVisaUpdateManyWithWhereWithoutCustomerInput>
    deleteMany?: Enumerable<CustomerVisaScalarWhereInput>
  }

  export type CustomerJobDetailUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<Enumerable<CustomerJobDetailCreateWithoutCustomerInput>, Enumerable<CustomerJobDetailUncheckedCreateWithoutCustomerInput>>
    connectOrCreate?: Enumerable<CustomerJobDetailCreateOrConnectWithoutCustomerInput>
    upsert?: Enumerable<CustomerJobDetailUpsertWithWhereUniqueWithoutCustomerInput>
    createMany?: CustomerJobDetailCreateManyCustomerInputEnvelope
    set?: Enumerable<CustomerJobDetailWhereUniqueInput>
    disconnect?: Enumerable<CustomerJobDetailWhereUniqueInput>
    delete?: Enumerable<CustomerJobDetailWhereUniqueInput>
    connect?: Enumerable<CustomerJobDetailWhereUniqueInput>
    update?: Enumerable<CustomerJobDetailUpdateWithWhereUniqueWithoutCustomerInput>
    updateMany?: Enumerable<CustomerJobDetailUpdateManyWithWhereWithoutCustomerInput>
    deleteMany?: Enumerable<CustomerJobDetailScalarWhereInput>
  }

  export type CustomerEducationUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<Enumerable<CustomerEducationCreateWithoutCustomerInput>, Enumerable<CustomerEducationUncheckedCreateWithoutCustomerInput>>
    connectOrCreate?: Enumerable<CustomerEducationCreateOrConnectWithoutCustomerInput>
    upsert?: Enumerable<CustomerEducationUpsertWithWhereUniqueWithoutCustomerInput>
    createMany?: CustomerEducationCreateManyCustomerInputEnvelope
    set?: Enumerable<CustomerEducationWhereUniqueInput>
    disconnect?: Enumerable<CustomerEducationWhereUniqueInput>
    delete?: Enumerable<CustomerEducationWhereUniqueInput>
    connect?: Enumerable<CustomerEducationWhereUniqueInput>
    update?: Enumerable<CustomerEducationUpdateWithWhereUniqueWithoutCustomerInput>
    updateMany?: Enumerable<CustomerEducationUpdateManyWithWhereWithoutCustomerInput>
    deleteMany?: Enumerable<CustomerEducationScalarWhereInput>
  }

  export type CustomerLanguageUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<Enumerable<CustomerLanguageCreateWithoutCustomerInput>, Enumerable<CustomerLanguageUncheckedCreateWithoutCustomerInput>>
    connectOrCreate?: Enumerable<CustomerLanguageCreateOrConnectWithoutCustomerInput>
    upsert?: Enumerable<CustomerLanguageUpsertWithWhereUniqueWithoutCustomerInput>
    createMany?: CustomerLanguageCreateManyCustomerInputEnvelope
    set?: Enumerable<CustomerLanguageWhereUniqueInput>
    disconnect?: Enumerable<CustomerLanguageWhereUniqueInput>
    delete?: Enumerable<CustomerLanguageWhereUniqueInput>
    connect?: Enumerable<CustomerLanguageWhereUniqueInput>
    update?: Enumerable<CustomerLanguageUpdateWithWhereUniqueWithoutCustomerInput>
    updateMany?: Enumerable<CustomerLanguageUpdateManyWithWhereWithoutCustomerInput>
    deleteMany?: Enumerable<CustomerLanguageScalarWhereInput>
  }

  export type CustomerQualificationUncheckedUpdateManyWithoutCustomersNestedInput = {
    create?: XOR<Enumerable<CustomerQualificationCreateWithoutCustomersInput>, Enumerable<CustomerQualificationUncheckedCreateWithoutCustomersInput>>
    connectOrCreate?: Enumerable<CustomerQualificationCreateOrConnectWithoutCustomersInput>
    upsert?: Enumerable<CustomerQualificationUpsertWithWhereUniqueWithoutCustomersInput>
    createMany?: CustomerQualificationCreateManyCustomersInputEnvelope
    set?: Enumerable<CustomerQualificationWhereUniqueInput>
    disconnect?: Enumerable<CustomerQualificationWhereUniqueInput>
    delete?: Enumerable<CustomerQualificationWhereUniqueInput>
    connect?: Enumerable<CustomerQualificationWhereUniqueInput>
    update?: Enumerable<CustomerQualificationUpdateWithWhereUniqueWithoutCustomersInput>
    updateMany?: Enumerable<CustomerQualificationUpdateManyWithWhereWithoutCustomersInput>
    deleteMany?: Enumerable<CustomerQualificationScalarWhereInput>
  }

  export type CustomerWorkHistoryUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<Enumerable<CustomerWorkHistoryCreateWithoutCustomerInput>, Enumerable<CustomerWorkHistoryUncheckedCreateWithoutCustomerInput>>
    connectOrCreate?: Enumerable<CustomerWorkHistoryCreateOrConnectWithoutCustomerInput>
    upsert?: Enumerable<CustomerWorkHistoryUpsertWithWhereUniqueWithoutCustomerInput>
    createMany?: CustomerWorkHistoryCreateManyCustomerInputEnvelope
    set?: Enumerable<CustomerWorkHistoryWhereUniqueInput>
    disconnect?: Enumerable<CustomerWorkHistoryWhereUniqueInput>
    delete?: Enumerable<CustomerWorkHistoryWhereUniqueInput>
    connect?: Enumerable<CustomerWorkHistoryWhereUniqueInput>
    update?: Enumerable<CustomerWorkHistoryUpdateWithWhereUniqueWithoutCustomerInput>
    updateMany?: Enumerable<CustomerWorkHistoryUpdateManyWithWhereWithoutCustomerInput>
    deleteMany?: Enumerable<CustomerWorkHistoryScalarWhereInput>
  }

  export type JobCandidateUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<Enumerable<JobCandidateCreateWithoutCustomerInput>, Enumerable<JobCandidateUncheckedCreateWithoutCustomerInput>>
    connectOrCreate?: Enumerable<JobCandidateCreateOrConnectWithoutCustomerInput>
    upsert?: Enumerable<JobCandidateUpsertWithWhereUniqueWithoutCustomerInput>
    createMany?: JobCandidateCreateManyCustomerInputEnvelope
    set?: Enumerable<JobCandidateWhereUniqueInput>
    disconnect?: Enumerable<JobCandidateWhereUniqueInput>
    delete?: Enumerable<JobCandidateWhereUniqueInput>
    connect?: Enumerable<JobCandidateWhereUniqueInput>
    update?: Enumerable<JobCandidateUpdateWithWhereUniqueWithoutCustomerInput>
    updateMany?: Enumerable<JobCandidateUpdateManyWithWhereWithoutCustomerInput>
    deleteMany?: Enumerable<JobCandidateScalarWhereInput>
  }

  export type CustomerDesiredUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<Enumerable<CustomerDesiredCreateWithoutCustomerInput>, Enumerable<CustomerDesiredUncheckedCreateWithoutCustomerInput>>
    connectOrCreate?: Enumerable<CustomerDesiredCreateOrConnectWithoutCustomerInput>
    upsert?: Enumerable<CustomerDesiredUpsertWithWhereUniqueWithoutCustomerInput>
    createMany?: CustomerDesiredCreateManyCustomerInputEnvelope
    set?: Enumerable<CustomerDesiredWhereUniqueInput>
    disconnect?: Enumerable<CustomerDesiredWhereUniqueInput>
    delete?: Enumerable<CustomerDesiredWhereUniqueInput>
    connect?: Enumerable<CustomerDesiredWhereUniqueInput>
    update?: Enumerable<CustomerDesiredUpdateWithWhereUniqueWithoutCustomerInput>
    updateMany?: Enumerable<CustomerDesiredUpdateManyWithWhereWithoutCustomerInput>
    deleteMany?: Enumerable<CustomerDesiredScalarWhereInput>
  }

  export type CustomerCreateNestedOneWithoutCustomer_desiredInput = {
    create?: XOR<CustomerCreateWithoutCustomer_desiredInput, CustomerUncheckedCreateWithoutCustomer_desiredInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutCustomer_desiredInput
    connect?: CustomerWhereUniqueInput
  }

  export type CustomerDesiredCreateoccupationInput = {
    set: Enumerable<InputJsonValue>
  }

  export type CustomerDesiredCreateindustryInput = {
    set: Enumerable<InputJsonValue>
  }

  export type CustomerDesiredCreatelocationInput = {
    set: Enumerable<InputJsonValue>
  }

  export type CustomerDesiredCreatecareer_levelInput = {
    set: Enumerable<InputJsonValue>
  }

  export type CustomerDesiredCreatecontract_typeInput = {
    set: Enumerable<InputJsonValue>
  }

  export type CustomerDesiredCreatedesired_companyInput = {
    set: Enumerable<InputJsonValue>
  }

  export type CustomerUpdateOneWithoutCustomer_desiredNestedInput = {
    create?: XOR<CustomerCreateWithoutCustomer_desiredInput, CustomerUncheckedCreateWithoutCustomer_desiredInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutCustomer_desiredInput
    upsert?: CustomerUpsertWithoutCustomer_desiredInput
    disconnect?: boolean
    delete?: boolean
    connect?: CustomerWhereUniqueInput
    update?: XOR<CustomerUpdateWithoutCustomer_desiredInput, CustomerUncheckedUpdateWithoutCustomer_desiredInput>
  }

  export type CustomerDesiredUpdateoccupationInput = {
    set?: Enumerable<InputJsonValue>
    push?: InputJsonValue | Enumerable<InputJsonValue>
  }

  export type CustomerDesiredUpdateindustryInput = {
    set?: Enumerable<InputJsonValue>
    push?: InputJsonValue | Enumerable<InputJsonValue>
  }

  export type CustomerDesiredUpdatelocationInput = {
    set?: Enumerable<InputJsonValue>
    push?: InputJsonValue | Enumerable<InputJsonValue>
  }

  export type CustomerDesiredUpdatecareer_levelInput = {
    set?: Enumerable<InputJsonValue>
    push?: InputJsonValue | Enumerable<InputJsonValue>
  }

  export type CustomerDesiredUpdatecontract_typeInput = {
    set?: Enumerable<InputJsonValue>
    push?: InputJsonValue | Enumerable<InputJsonValue>
  }

  export type CustomerDesiredUpdatedesired_companyInput = {
    set?: Enumerable<InputJsonValue>
    push?: InputJsonValue | Enumerable<InputJsonValue>
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type CustomerCreateNestedOneWithoutCustomer_educationsInput = {
    create?: XOR<CustomerCreateWithoutCustomer_educationsInput, CustomerUncheckedCreateWithoutCustomer_educationsInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutCustomer_educationsInput
    connect?: CustomerWhereUniqueInput
  }

  export type CustomerUpdateOneWithoutCustomer_educationsNestedInput = {
    create?: XOR<CustomerCreateWithoutCustomer_educationsInput, CustomerUncheckedCreateWithoutCustomer_educationsInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutCustomer_educationsInput
    upsert?: CustomerUpsertWithoutCustomer_educationsInput
    disconnect?: boolean
    delete?: boolean
    connect?: CustomerWhereUniqueInput
    update?: XOR<CustomerUpdateWithoutCustomer_educationsInput, CustomerUncheckedUpdateWithoutCustomer_educationsInput>
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type CustomerJobDetailCreateNestedOneWithoutCustomer_experiencesInput = {
    create?: XOR<CustomerJobDetailCreateWithoutCustomer_experiencesInput, CustomerJobDetailUncheckedCreateWithoutCustomer_experiencesInput>
    connectOrCreate?: CustomerJobDetailCreateOrConnectWithoutCustomer_experiencesInput
    connect?: CustomerJobDetailWhereUniqueInput
  }

  export type ReferenceListItemsCreateNestedOneWithoutCustomer_experiencesInput = {
    create?: XOR<ReferenceListItemsCreateWithoutCustomer_experiencesInput, ReferenceListItemsUncheckedCreateWithoutCustomer_experiencesInput>
    connectOrCreate?: ReferenceListItemsCreateOrConnectWithoutCustomer_experiencesInput
    connect?: ReferenceListItemsWhereUniqueInput
  }

  export type CustomerJobDetailUpdateOneRequiredWithoutCustomer_experiencesNestedInput = {
    create?: XOR<CustomerJobDetailCreateWithoutCustomer_experiencesInput, CustomerJobDetailUncheckedCreateWithoutCustomer_experiencesInput>
    connectOrCreate?: CustomerJobDetailCreateOrConnectWithoutCustomer_experiencesInput
    upsert?: CustomerJobDetailUpsertWithoutCustomer_experiencesInput
    connect?: CustomerJobDetailWhereUniqueInput
    update?: XOR<CustomerJobDetailUpdateWithoutCustomer_experiencesInput, CustomerJobDetailUncheckedUpdateWithoutCustomer_experiencesInput>
  }

  export type ReferenceListItemsUpdateOneRequiredWithoutCustomer_experiencesNestedInput = {
    create?: XOR<ReferenceListItemsCreateWithoutCustomer_experiencesInput, ReferenceListItemsUncheckedCreateWithoutCustomer_experiencesInput>
    connectOrCreate?: ReferenceListItemsCreateOrConnectWithoutCustomer_experiencesInput
    upsert?: ReferenceListItemsUpsertWithoutCustomer_experiencesInput
    connect?: ReferenceListItemsWhereUniqueInput
    update?: XOR<ReferenceListItemsUpdateWithoutCustomer_experiencesInput, ReferenceListItemsUncheckedUpdateWithoutCustomer_experiencesInput>
  }

  export type CustomerCreateNestedOneWithoutCustomer_jobdetailsInput = {
    create?: XOR<CustomerCreateWithoutCustomer_jobdetailsInput, CustomerUncheckedCreateWithoutCustomer_jobdetailsInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutCustomer_jobdetailsInput
    connect?: CustomerWhereUniqueInput
  }

  export type CustomerExperienceCreateNestedManyWithoutJobdetailsInput = {
    create?: XOR<Enumerable<CustomerExperienceCreateWithoutJobdetailsInput>, Enumerable<CustomerExperienceUncheckedCreateWithoutJobdetailsInput>>
    connectOrCreate?: Enumerable<CustomerExperienceCreateOrConnectWithoutJobdetailsInput>
    createMany?: CustomerExperienceCreateManyJobdetailsInputEnvelope
    connect?: Enumerable<CustomerExperienceWhereUniqueInput>
  }

  export type CustomerExperienceUncheckedCreateNestedManyWithoutJobdetailsInput = {
    create?: XOR<Enumerable<CustomerExperienceCreateWithoutJobdetailsInput>, Enumerable<CustomerExperienceUncheckedCreateWithoutJobdetailsInput>>
    connectOrCreate?: Enumerable<CustomerExperienceCreateOrConnectWithoutJobdetailsInput>
    createMany?: CustomerExperienceCreateManyJobdetailsInputEnvelope
    connect?: Enumerable<CustomerExperienceWhereUniqueInput>
  }

  export type CustomerUpdateOneWithoutCustomer_jobdetailsNestedInput = {
    create?: XOR<CustomerCreateWithoutCustomer_jobdetailsInput, CustomerUncheckedCreateWithoutCustomer_jobdetailsInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutCustomer_jobdetailsInput
    upsert?: CustomerUpsertWithoutCustomer_jobdetailsInput
    disconnect?: boolean
    delete?: boolean
    connect?: CustomerWhereUniqueInput
    update?: XOR<CustomerUpdateWithoutCustomer_jobdetailsInput, CustomerUncheckedUpdateWithoutCustomer_jobdetailsInput>
  }

  export type CustomerExperienceUpdateManyWithoutJobdetailsNestedInput = {
    create?: XOR<Enumerable<CustomerExperienceCreateWithoutJobdetailsInput>, Enumerable<CustomerExperienceUncheckedCreateWithoutJobdetailsInput>>
    connectOrCreate?: Enumerable<CustomerExperienceCreateOrConnectWithoutJobdetailsInput>
    upsert?: Enumerable<CustomerExperienceUpsertWithWhereUniqueWithoutJobdetailsInput>
    createMany?: CustomerExperienceCreateManyJobdetailsInputEnvelope
    set?: Enumerable<CustomerExperienceWhereUniqueInput>
    disconnect?: Enumerable<CustomerExperienceWhereUniqueInput>
    delete?: Enumerable<CustomerExperienceWhereUniqueInput>
    connect?: Enumerable<CustomerExperienceWhereUniqueInput>
    update?: Enumerable<CustomerExperienceUpdateWithWhereUniqueWithoutJobdetailsInput>
    updateMany?: Enumerable<CustomerExperienceUpdateManyWithWhereWithoutJobdetailsInput>
    deleteMany?: Enumerable<CustomerExperienceScalarWhereInput>
  }

  export type CustomerExperienceUncheckedUpdateManyWithoutJobdetailsNestedInput = {
    create?: XOR<Enumerable<CustomerExperienceCreateWithoutJobdetailsInput>, Enumerable<CustomerExperienceUncheckedCreateWithoutJobdetailsInput>>
    connectOrCreate?: Enumerable<CustomerExperienceCreateOrConnectWithoutJobdetailsInput>
    upsert?: Enumerable<CustomerExperienceUpsertWithWhereUniqueWithoutJobdetailsInput>
    createMany?: CustomerExperienceCreateManyJobdetailsInputEnvelope
    set?: Enumerable<CustomerExperienceWhereUniqueInput>
    disconnect?: Enumerable<CustomerExperienceWhereUniqueInput>
    delete?: Enumerable<CustomerExperienceWhereUniqueInput>
    connect?: Enumerable<CustomerExperienceWhereUniqueInput>
    update?: Enumerable<CustomerExperienceUpdateWithWhereUniqueWithoutJobdetailsInput>
    updateMany?: Enumerable<CustomerExperienceUpdateManyWithWhereWithoutJobdetailsInput>
    deleteMany?: Enumerable<CustomerExperienceScalarWhereInput>
  }

  export type CustomerCreateNestedOneWithoutCustomer_languagesInput = {
    create?: XOR<CustomerCreateWithoutCustomer_languagesInput, CustomerUncheckedCreateWithoutCustomer_languagesInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutCustomer_languagesInput
    connect?: CustomerWhereUniqueInput
  }

  export type CustomerUpdateOneRequiredWithoutCustomer_languagesNestedInput = {
    create?: XOR<CustomerCreateWithoutCustomer_languagesInput, CustomerUncheckedCreateWithoutCustomer_languagesInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutCustomer_languagesInput
    upsert?: CustomerUpsertWithoutCustomer_languagesInput
    connect?: CustomerWhereUniqueInput
    update?: XOR<CustomerUpdateWithoutCustomer_languagesInput, CustomerUncheckedUpdateWithoutCustomer_languagesInput>
  }

  export type NullableEnumLanguageLevelFieldUpdateOperationsInput = {
    set?: LanguageLevel | null
  }

  export type CustomerCreateNestedOneWithoutCustomer_qualificationsInput = {
    create?: XOR<CustomerCreateWithoutCustomer_qualificationsInput, CustomerUncheckedCreateWithoutCustomer_qualificationsInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutCustomer_qualificationsInput
    connect?: CustomerWhereUniqueInput
  }

  export type CustomerUpdateOneRequiredWithoutCustomer_qualificationsNestedInput = {
    create?: XOR<CustomerCreateWithoutCustomer_qualificationsInput, CustomerUncheckedCreateWithoutCustomer_qualificationsInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutCustomer_qualificationsInput
    upsert?: CustomerUpsertWithoutCustomer_qualificationsInput
    connect?: CustomerWhereUniqueInput
    update?: XOR<CustomerUpdateWithoutCustomer_qualificationsInput, CustomerUncheckedUpdateWithoutCustomer_qualificationsInput>
  }

  export type CustomerCreateNestedOneWithoutCustomer_visasInput = {
    create?: XOR<CustomerCreateWithoutCustomer_visasInput, CustomerUncheckedCreateWithoutCustomer_visasInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutCustomer_visasInput
    connect?: CustomerWhereUniqueInput
  }

  export type CustomerUpdateOneRequiredWithoutCustomer_visasNestedInput = {
    create?: XOR<CustomerCreateWithoutCustomer_visasInput, CustomerUncheckedCreateWithoutCustomer_visasInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutCustomer_visasInput
    upsert?: CustomerUpsertWithoutCustomer_visasInput
    connect?: CustomerWhereUniqueInput
    update?: XOR<CustomerUpdateWithoutCustomer_visasInput, CustomerUncheckedUpdateWithoutCustomer_visasInput>
  }

  export type NullableEnumStatusVisaFieldUpdateOperationsInput = {
    set?: StatusVisa | null
  }

  export type CustomerCreateNestedOneWithoutCustomer_workhistoriesInput = {
    create?: XOR<CustomerCreateWithoutCustomer_workhistoriesInput, CustomerUncheckedCreateWithoutCustomer_workhistoriesInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutCustomer_workhistoriesInput
    connect?: CustomerWhereUniqueInput
  }

  export type CustomerUpdateOneRequiredWithoutCustomer_workhistoriesNestedInput = {
    create?: XOR<CustomerCreateWithoutCustomer_workhistoriesInput, CustomerUncheckedCreateWithoutCustomer_workhistoriesInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutCustomer_workhistoriesInput
    upsert?: CustomerUpsertWithoutCustomer_workhistoriesInput
    connect?: CustomerWhereUniqueInput
    update?: XOR<CustomerUpdateWithoutCustomer_workhistoriesInput, CustomerUncheckedUpdateWithoutCustomer_workhistoriesInput>
  }

  export type NullableEnumJobPositionFieldUpdateOperationsInput = {
    set?: JobPosition | null
  }

  export type ReferenceListItemsCreateNestedManyWithoutDictionaryInput = {
    create?: XOR<Enumerable<ReferenceListItemsCreateWithoutDictionaryInput>, Enumerable<ReferenceListItemsUncheckedCreateWithoutDictionaryInput>>
    connectOrCreate?: Enumerable<ReferenceListItemsCreateOrConnectWithoutDictionaryInput>
    createMany?: ReferenceListItemsCreateManyDictionaryInputEnvelope
    connect?: Enumerable<ReferenceListItemsWhereUniqueInput>
  }

  export type ReferenceListItemsUncheckedCreateNestedManyWithoutDictionaryInput = {
    create?: XOR<Enumerable<ReferenceListItemsCreateWithoutDictionaryInput>, Enumerable<ReferenceListItemsUncheckedCreateWithoutDictionaryInput>>
    connectOrCreate?: Enumerable<ReferenceListItemsCreateOrConnectWithoutDictionaryInput>
    createMany?: ReferenceListItemsCreateManyDictionaryInputEnvelope
    connect?: Enumerable<ReferenceListItemsWhereUniqueInput>
  }

  export type ReferenceListItemsUpdateManyWithoutDictionaryNestedInput = {
    create?: XOR<Enumerable<ReferenceListItemsCreateWithoutDictionaryInput>, Enumerable<ReferenceListItemsUncheckedCreateWithoutDictionaryInput>>
    connectOrCreate?: Enumerable<ReferenceListItemsCreateOrConnectWithoutDictionaryInput>
    upsert?: Enumerable<ReferenceListItemsUpsertWithWhereUniqueWithoutDictionaryInput>
    createMany?: ReferenceListItemsCreateManyDictionaryInputEnvelope
    set?: Enumerable<ReferenceListItemsWhereUniqueInput>
    disconnect?: Enumerable<ReferenceListItemsWhereUniqueInput>
    delete?: Enumerable<ReferenceListItemsWhereUniqueInput>
    connect?: Enumerable<ReferenceListItemsWhereUniqueInput>
    update?: Enumerable<ReferenceListItemsUpdateWithWhereUniqueWithoutDictionaryInput>
    updateMany?: Enumerable<ReferenceListItemsUpdateManyWithWhereWithoutDictionaryInput>
    deleteMany?: Enumerable<ReferenceListItemsScalarWhereInput>
  }

  export type ReferenceListItemsUncheckedUpdateManyWithoutDictionaryNestedInput = {
    create?: XOR<Enumerable<ReferenceListItemsCreateWithoutDictionaryInput>, Enumerable<ReferenceListItemsUncheckedCreateWithoutDictionaryInput>>
    connectOrCreate?: Enumerable<ReferenceListItemsCreateOrConnectWithoutDictionaryInput>
    upsert?: Enumerable<ReferenceListItemsUpsertWithWhereUniqueWithoutDictionaryInput>
    createMany?: ReferenceListItemsCreateManyDictionaryInputEnvelope
    set?: Enumerable<ReferenceListItemsWhereUniqueInput>
    disconnect?: Enumerable<ReferenceListItemsWhereUniqueInput>
    delete?: Enumerable<ReferenceListItemsWhereUniqueInput>
    connect?: Enumerable<ReferenceListItemsWhereUniqueInput>
    update?: Enumerable<ReferenceListItemsUpdateWithWhereUniqueWithoutDictionaryInput>
    updateMany?: Enumerable<ReferenceListItemsUpdateManyWithWhereWithoutDictionaryInput>
    deleteMany?: Enumerable<ReferenceListItemsScalarWhereInput>
  }

  export type EntityDetailCreateNestedManyWithoutEntityInput = {
    create?: XOR<Enumerable<EntityDetailCreateWithoutEntityInput>, Enumerable<EntityDetailUncheckedCreateWithoutEntityInput>>
    connectOrCreate?: Enumerable<EntityDetailCreateOrConnectWithoutEntityInput>
    createMany?: EntityDetailCreateManyEntityInputEnvelope
    connect?: Enumerable<EntityDetailWhereUniqueInput>
  }

  export type EntityBranchCreateNestedManyWithoutEntityInput = {
    create?: XOR<Enumerable<EntityBranchCreateWithoutEntityInput>, Enumerable<EntityBranchUncheckedCreateWithoutEntityInput>>
    connectOrCreate?: Enumerable<EntityBranchCreateOrConnectWithoutEntityInput>
    createMany?: EntityBranchCreateManyEntityInputEnvelope
    connect?: Enumerable<EntityBranchWhereUniqueInput>
  }

  export type EntityAccountInfoCreateNestedManyWithoutEntityInput = {
    create?: XOR<Enumerable<EntityAccountInfoCreateWithoutEntityInput>, Enumerable<EntityAccountInfoUncheckedCreateWithoutEntityInput>>
    connectOrCreate?: Enumerable<EntityAccountInfoCreateOrConnectWithoutEntityInput>
    createMany?: EntityAccountInfoCreateManyEntityInputEnvelope
    connect?: Enumerable<EntityAccountInfoWhereUniqueInput>
  }

  export type InquiryCreateNestedManyWithoutEntityInput = {
    create?: XOR<Enumerable<InquiryCreateWithoutEntityInput>, Enumerable<InquiryUncheckedCreateWithoutEntityInput>>
    connectOrCreate?: Enumerable<InquiryCreateOrConnectWithoutEntityInput>
    createMany?: InquiryCreateManyEntityInputEnvelope
    connect?: Enumerable<InquiryWhereUniqueInput>
  }

  export type EntityDetailUncheckedCreateNestedManyWithoutEntityInput = {
    create?: XOR<Enumerable<EntityDetailCreateWithoutEntityInput>, Enumerable<EntityDetailUncheckedCreateWithoutEntityInput>>
    connectOrCreate?: Enumerable<EntityDetailCreateOrConnectWithoutEntityInput>
    createMany?: EntityDetailCreateManyEntityInputEnvelope
    connect?: Enumerable<EntityDetailWhereUniqueInput>
  }

  export type EntityBranchUncheckedCreateNestedManyWithoutEntityInput = {
    create?: XOR<Enumerable<EntityBranchCreateWithoutEntityInput>, Enumerable<EntityBranchUncheckedCreateWithoutEntityInput>>
    connectOrCreate?: Enumerable<EntityBranchCreateOrConnectWithoutEntityInput>
    createMany?: EntityBranchCreateManyEntityInputEnvelope
    connect?: Enumerable<EntityBranchWhereUniqueInput>
  }

  export type EntityAccountInfoUncheckedCreateNestedManyWithoutEntityInput = {
    create?: XOR<Enumerable<EntityAccountInfoCreateWithoutEntityInput>, Enumerable<EntityAccountInfoUncheckedCreateWithoutEntityInput>>
    connectOrCreate?: Enumerable<EntityAccountInfoCreateOrConnectWithoutEntityInput>
    createMany?: EntityAccountInfoCreateManyEntityInputEnvelope
    connect?: Enumerable<EntityAccountInfoWhereUniqueInput>
  }

  export type InquiryUncheckedCreateNestedManyWithoutEntityInput = {
    create?: XOR<Enumerable<InquiryCreateWithoutEntityInput>, Enumerable<InquiryUncheckedCreateWithoutEntityInput>>
    connectOrCreate?: Enumerable<InquiryCreateOrConnectWithoutEntityInput>
    createMany?: InquiryCreateManyEntityInputEnvelope
    connect?: Enumerable<InquiryWhereUniqueInput>
  }

  export type EntityDetailUpdateManyWithoutEntityNestedInput = {
    create?: XOR<Enumerable<EntityDetailCreateWithoutEntityInput>, Enumerable<EntityDetailUncheckedCreateWithoutEntityInput>>
    connectOrCreate?: Enumerable<EntityDetailCreateOrConnectWithoutEntityInput>
    upsert?: Enumerable<EntityDetailUpsertWithWhereUniqueWithoutEntityInput>
    createMany?: EntityDetailCreateManyEntityInputEnvelope
    set?: Enumerable<EntityDetailWhereUniqueInput>
    disconnect?: Enumerable<EntityDetailWhereUniqueInput>
    delete?: Enumerable<EntityDetailWhereUniqueInput>
    connect?: Enumerable<EntityDetailWhereUniqueInput>
    update?: Enumerable<EntityDetailUpdateWithWhereUniqueWithoutEntityInput>
    updateMany?: Enumerable<EntityDetailUpdateManyWithWhereWithoutEntityInput>
    deleteMany?: Enumerable<EntityDetailScalarWhereInput>
  }

  export type EntityBranchUpdateManyWithoutEntityNestedInput = {
    create?: XOR<Enumerable<EntityBranchCreateWithoutEntityInput>, Enumerable<EntityBranchUncheckedCreateWithoutEntityInput>>
    connectOrCreate?: Enumerable<EntityBranchCreateOrConnectWithoutEntityInput>
    upsert?: Enumerable<EntityBranchUpsertWithWhereUniqueWithoutEntityInput>
    createMany?: EntityBranchCreateManyEntityInputEnvelope
    set?: Enumerable<EntityBranchWhereUniqueInput>
    disconnect?: Enumerable<EntityBranchWhereUniqueInput>
    delete?: Enumerable<EntityBranchWhereUniqueInput>
    connect?: Enumerable<EntityBranchWhereUniqueInput>
    update?: Enumerable<EntityBranchUpdateWithWhereUniqueWithoutEntityInput>
    updateMany?: Enumerable<EntityBranchUpdateManyWithWhereWithoutEntityInput>
    deleteMany?: Enumerable<EntityBranchScalarWhereInput>
  }

  export type EntityAccountInfoUpdateManyWithoutEntityNestedInput = {
    create?: XOR<Enumerable<EntityAccountInfoCreateWithoutEntityInput>, Enumerable<EntityAccountInfoUncheckedCreateWithoutEntityInput>>
    connectOrCreate?: Enumerable<EntityAccountInfoCreateOrConnectWithoutEntityInput>
    upsert?: Enumerable<EntityAccountInfoUpsertWithWhereUniqueWithoutEntityInput>
    createMany?: EntityAccountInfoCreateManyEntityInputEnvelope
    set?: Enumerable<EntityAccountInfoWhereUniqueInput>
    disconnect?: Enumerable<EntityAccountInfoWhereUniqueInput>
    delete?: Enumerable<EntityAccountInfoWhereUniqueInput>
    connect?: Enumerable<EntityAccountInfoWhereUniqueInput>
    update?: Enumerable<EntityAccountInfoUpdateWithWhereUniqueWithoutEntityInput>
    updateMany?: Enumerable<EntityAccountInfoUpdateManyWithWhereWithoutEntityInput>
    deleteMany?: Enumerable<EntityAccountInfoScalarWhereInput>
  }

  export type InquiryUpdateManyWithoutEntityNestedInput = {
    create?: XOR<Enumerable<InquiryCreateWithoutEntityInput>, Enumerable<InquiryUncheckedCreateWithoutEntityInput>>
    connectOrCreate?: Enumerable<InquiryCreateOrConnectWithoutEntityInput>
    upsert?: Enumerable<InquiryUpsertWithWhereUniqueWithoutEntityInput>
    createMany?: InquiryCreateManyEntityInputEnvelope
    set?: Enumerable<InquiryWhereUniqueInput>
    disconnect?: Enumerable<InquiryWhereUniqueInput>
    delete?: Enumerable<InquiryWhereUniqueInput>
    connect?: Enumerable<InquiryWhereUniqueInput>
    update?: Enumerable<InquiryUpdateWithWhereUniqueWithoutEntityInput>
    updateMany?: Enumerable<InquiryUpdateManyWithWhereWithoutEntityInput>
    deleteMany?: Enumerable<InquiryScalarWhereInput>
  }

  export type EntityDetailUncheckedUpdateManyWithoutEntityNestedInput = {
    create?: XOR<Enumerable<EntityDetailCreateWithoutEntityInput>, Enumerable<EntityDetailUncheckedCreateWithoutEntityInput>>
    connectOrCreate?: Enumerable<EntityDetailCreateOrConnectWithoutEntityInput>
    upsert?: Enumerable<EntityDetailUpsertWithWhereUniqueWithoutEntityInput>
    createMany?: EntityDetailCreateManyEntityInputEnvelope
    set?: Enumerable<EntityDetailWhereUniqueInput>
    disconnect?: Enumerable<EntityDetailWhereUniqueInput>
    delete?: Enumerable<EntityDetailWhereUniqueInput>
    connect?: Enumerable<EntityDetailWhereUniqueInput>
    update?: Enumerable<EntityDetailUpdateWithWhereUniqueWithoutEntityInput>
    updateMany?: Enumerable<EntityDetailUpdateManyWithWhereWithoutEntityInput>
    deleteMany?: Enumerable<EntityDetailScalarWhereInput>
  }

  export type EntityBranchUncheckedUpdateManyWithoutEntityNestedInput = {
    create?: XOR<Enumerable<EntityBranchCreateWithoutEntityInput>, Enumerable<EntityBranchUncheckedCreateWithoutEntityInput>>
    connectOrCreate?: Enumerable<EntityBranchCreateOrConnectWithoutEntityInput>
    upsert?: Enumerable<EntityBranchUpsertWithWhereUniqueWithoutEntityInput>
    createMany?: EntityBranchCreateManyEntityInputEnvelope
    set?: Enumerable<EntityBranchWhereUniqueInput>
    disconnect?: Enumerable<EntityBranchWhereUniqueInput>
    delete?: Enumerable<EntityBranchWhereUniqueInput>
    connect?: Enumerable<EntityBranchWhereUniqueInput>
    update?: Enumerable<EntityBranchUpdateWithWhereUniqueWithoutEntityInput>
    updateMany?: Enumerable<EntityBranchUpdateManyWithWhereWithoutEntityInput>
    deleteMany?: Enumerable<EntityBranchScalarWhereInput>
  }

  export type EntityAccountInfoUncheckedUpdateManyWithoutEntityNestedInput = {
    create?: XOR<Enumerable<EntityAccountInfoCreateWithoutEntityInput>, Enumerable<EntityAccountInfoUncheckedCreateWithoutEntityInput>>
    connectOrCreate?: Enumerable<EntityAccountInfoCreateOrConnectWithoutEntityInput>
    upsert?: Enumerable<EntityAccountInfoUpsertWithWhereUniqueWithoutEntityInput>
    createMany?: EntityAccountInfoCreateManyEntityInputEnvelope
    set?: Enumerable<EntityAccountInfoWhereUniqueInput>
    disconnect?: Enumerable<EntityAccountInfoWhereUniqueInput>
    delete?: Enumerable<EntityAccountInfoWhereUniqueInput>
    connect?: Enumerable<EntityAccountInfoWhereUniqueInput>
    update?: Enumerable<EntityAccountInfoUpdateWithWhereUniqueWithoutEntityInput>
    updateMany?: Enumerable<EntityAccountInfoUpdateManyWithWhereWithoutEntityInput>
    deleteMany?: Enumerable<EntityAccountInfoScalarWhereInput>
  }

  export type InquiryUncheckedUpdateManyWithoutEntityNestedInput = {
    create?: XOR<Enumerable<InquiryCreateWithoutEntityInput>, Enumerable<InquiryUncheckedCreateWithoutEntityInput>>
    connectOrCreate?: Enumerable<InquiryCreateOrConnectWithoutEntityInput>
    upsert?: Enumerable<InquiryUpsertWithWhereUniqueWithoutEntityInput>
    createMany?: InquiryCreateManyEntityInputEnvelope
    set?: Enumerable<InquiryWhereUniqueInput>
    disconnect?: Enumerable<InquiryWhereUniqueInput>
    delete?: Enumerable<InquiryWhereUniqueInput>
    connect?: Enumerable<InquiryWhereUniqueInput>
    update?: Enumerable<InquiryUpdateWithWhereUniqueWithoutEntityInput>
    updateMany?: Enumerable<InquiryUpdateManyWithWhereWithoutEntityInput>
    deleteMany?: Enumerable<InquiryScalarWhereInput>
  }

  export type EntityCreateNestedOneWithoutEntity_accountinfosInput = {
    create?: XOR<EntityCreateWithoutEntity_accountinfosInput, EntityUncheckedCreateWithoutEntity_accountinfosInput>
    connectOrCreate?: EntityCreateOrConnectWithoutEntity_accountinfosInput
    connect?: EntityWhereUniqueInput
  }

  export type EntityUpdateOneWithoutEntity_accountinfosNestedInput = {
    create?: XOR<EntityCreateWithoutEntity_accountinfosInput, EntityUncheckedCreateWithoutEntity_accountinfosInput>
    connectOrCreate?: EntityCreateOrConnectWithoutEntity_accountinfosInput
    upsert?: EntityUpsertWithoutEntity_accountinfosInput
    disconnect?: boolean
    delete?: boolean
    connect?: EntityWhereUniqueInput
    update?: XOR<EntityUpdateWithoutEntity_accountinfosInput, EntityUncheckedUpdateWithoutEntity_accountinfosInput>
  }

  export type EntityCreateNestedOneWithoutEntity_branchesInput = {
    create?: XOR<EntityCreateWithoutEntity_branchesInput, EntityUncheckedCreateWithoutEntity_branchesInput>
    connectOrCreate?: EntityCreateOrConnectWithoutEntity_branchesInput
    connect?: EntityWhereUniqueInput
  }

  export type JobCreateNestedManyWithoutEntity_branchInput = {
    create?: XOR<Enumerable<JobCreateWithoutEntity_branchInput>, Enumerable<JobUncheckedCreateWithoutEntity_branchInput>>
    connectOrCreate?: Enumerable<JobCreateOrConnectWithoutEntity_branchInput>
    createMany?: JobCreateManyEntity_branchInputEnvelope
    connect?: Enumerable<JobWhereUniqueInput>
  }

  export type JobUncheckedCreateNestedManyWithoutEntity_branchInput = {
    create?: XOR<Enumerable<JobCreateWithoutEntity_branchInput>, Enumerable<JobUncheckedCreateWithoutEntity_branchInput>>
    connectOrCreate?: Enumerable<JobCreateOrConnectWithoutEntity_branchInput>
    createMany?: JobCreateManyEntity_branchInputEnvelope
    connect?: Enumerable<JobWhereUniqueInput>
  }

  export type EntityUpdateOneRequiredWithoutEntity_branchesNestedInput = {
    create?: XOR<EntityCreateWithoutEntity_branchesInput, EntityUncheckedCreateWithoutEntity_branchesInput>
    connectOrCreate?: EntityCreateOrConnectWithoutEntity_branchesInput
    upsert?: EntityUpsertWithoutEntity_branchesInput
    connect?: EntityWhereUniqueInput
    update?: XOR<EntityUpdateWithoutEntity_branchesInput, EntityUncheckedUpdateWithoutEntity_branchesInput>
  }

  export type JobUpdateManyWithoutEntity_branchNestedInput = {
    create?: XOR<Enumerable<JobCreateWithoutEntity_branchInput>, Enumerable<JobUncheckedCreateWithoutEntity_branchInput>>
    connectOrCreate?: Enumerable<JobCreateOrConnectWithoutEntity_branchInput>
    upsert?: Enumerable<JobUpsertWithWhereUniqueWithoutEntity_branchInput>
    createMany?: JobCreateManyEntity_branchInputEnvelope
    set?: Enumerable<JobWhereUniqueInput>
    disconnect?: Enumerable<JobWhereUniqueInput>
    delete?: Enumerable<JobWhereUniqueInput>
    connect?: Enumerable<JobWhereUniqueInput>
    update?: Enumerable<JobUpdateWithWhereUniqueWithoutEntity_branchInput>
    updateMany?: Enumerable<JobUpdateManyWithWhereWithoutEntity_branchInput>
    deleteMany?: Enumerable<JobScalarWhereInput>
  }

  export type JobUncheckedUpdateManyWithoutEntity_branchNestedInput = {
    create?: XOR<Enumerable<JobCreateWithoutEntity_branchInput>, Enumerable<JobUncheckedCreateWithoutEntity_branchInput>>
    connectOrCreate?: Enumerable<JobCreateOrConnectWithoutEntity_branchInput>
    upsert?: Enumerable<JobUpsertWithWhereUniqueWithoutEntity_branchInput>
    createMany?: JobCreateManyEntity_branchInputEnvelope
    set?: Enumerable<JobWhereUniqueInput>
    disconnect?: Enumerable<JobWhereUniqueInput>
    delete?: Enumerable<JobWhereUniqueInput>
    connect?: Enumerable<JobWhereUniqueInput>
    update?: Enumerable<JobUpdateWithWhereUniqueWithoutEntity_branchInput>
    updateMany?: Enumerable<JobUpdateManyWithWhereWithoutEntity_branchInput>
    deleteMany?: Enumerable<JobScalarWhereInput>
  }

  export type EntityCreateNestedOneWithoutEntity_detailsInput = {
    create?: XOR<EntityCreateWithoutEntity_detailsInput, EntityUncheckedCreateWithoutEntity_detailsInput>
    connectOrCreate?: EntityCreateOrConnectWithoutEntity_detailsInput
    connect?: EntityWhereUniqueInput
  }

  export type EntityUpdateOneWithoutEntity_detailsNestedInput = {
    create?: XOR<EntityCreateWithoutEntity_detailsInput, EntityUncheckedCreateWithoutEntity_detailsInput>
    connectOrCreate?: EntityCreateOrConnectWithoutEntity_detailsInput
    upsert?: EntityUpsertWithoutEntity_detailsInput
    disconnect?: boolean
    delete?: boolean
    connect?: EntityWhereUniqueInput
    update?: XOR<EntityUpdateWithoutEntity_detailsInput, EntityUncheckedUpdateWithoutEntity_detailsInput>
  }

  export type EnumFileTypeFieldUpdateOperationsInput = {
    set?: FileType
  }

  export type EnumFileSourceFieldUpdateOperationsInput = {
    set?: FileSource
  }

  export type UserCreateNestedOneWithoutFrom_inquiriesInput = {
    create?: XOR<UserCreateWithoutFrom_inquiriesInput, UserUncheckedCreateWithoutFrom_inquiriesInput>
    connectOrCreate?: UserCreateOrConnectWithoutFrom_inquiriesInput
    connect?: UserWhereUniqueInput
  }

  export type EntityCreateNestedOneWithoutInquiriesInput = {
    create?: XOR<EntityCreateWithoutInquiriesInput, EntityUncheckedCreateWithoutInquiriesInput>
    connectOrCreate?: EntityCreateOrConnectWithoutInquiriesInput
    connect?: EntityWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutAssign_inquiriesInput = {
    create?: XOR<UserCreateWithoutAssign_inquiriesInput, UserUncheckedCreateWithoutAssign_inquiriesInput>
    connectOrCreate?: UserCreateOrConnectWithoutAssign_inquiriesInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneWithoutFrom_inquiriesNestedInput = {
    create?: XOR<UserCreateWithoutFrom_inquiriesInput, UserUncheckedCreateWithoutFrom_inquiriesInput>
    connectOrCreate?: UserCreateOrConnectWithoutFrom_inquiriesInput
    upsert?: UserUpsertWithoutFrom_inquiriesInput
    disconnect?: boolean
    delete?: boolean
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutFrom_inquiriesInput, UserUncheckedUpdateWithoutFrom_inquiriesInput>
  }

  export type EntityUpdateOneWithoutInquiriesNestedInput = {
    create?: XOR<EntityCreateWithoutInquiriesInput, EntityUncheckedCreateWithoutInquiriesInput>
    connectOrCreate?: EntityCreateOrConnectWithoutInquiriesInput
    upsert?: EntityUpsertWithoutInquiriesInput
    disconnect?: boolean
    delete?: boolean
    connect?: EntityWhereUniqueInput
    update?: XOR<EntityUpdateWithoutInquiriesInput, EntityUncheckedUpdateWithoutInquiriesInput>
  }

  export type UserUpdateOneWithoutAssign_inquiriesNestedInput = {
    create?: XOR<UserCreateWithoutAssign_inquiriesInput, UserUncheckedCreateWithoutAssign_inquiriesInput>
    connectOrCreate?: UserCreateOrConnectWithoutAssign_inquiriesInput
    upsert?: UserUpsertWithoutAssign_inquiriesInput
    disconnect?: boolean
    delete?: boolean
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutAssign_inquiriesInput, UserUncheckedUpdateWithoutAssign_inquiriesInput>
  }

  export type NullableEnumInquiryStatusFieldUpdateOperationsInput = {
    set?: InquiryStatus | null
  }

  export type JobReferenceListCreateNestedManyWithoutJobInput = {
    create?: XOR<Enumerable<JobReferenceListCreateWithoutJobInput>, Enumerable<JobReferenceListUncheckedCreateWithoutJobInput>>
    connectOrCreate?: Enumerable<JobReferenceListCreateOrConnectWithoutJobInput>
    createMany?: JobReferenceListCreateManyJobInputEnvelope
    connect?: Enumerable<JobReferenceListWhereUniqueInput>
  }

  export type JobCreatecareer_levelInput = {
    set: Enumerable<JobPosition>
  }

  export type JobCreatesmokeInput = {
    set: Enumerable<Smoke>
  }

  export type JobOtherLanguageCreateNestedManyWithoutJobInput = {
    create?: XOR<Enumerable<JobOtherLanguageCreateWithoutJobInput>, Enumerable<JobOtherLanguageUncheckedCreateWithoutJobInput>>
    connectOrCreate?: Enumerable<JobOtherLanguageCreateOrConnectWithoutJobInput>
    createMany?: JobOtherLanguageCreateManyJobInputEnvelope
    connect?: Enumerable<JobOtherLanguageWhereUniqueInput>
  }

  export type EntityBranchCreateNestedOneWithoutJobsInput = {
    create?: XOR<EntityBranchCreateWithoutJobsInput, EntityBranchUncheckedCreateWithoutJobsInput>
    connectOrCreate?: EntityBranchCreateOrConnectWithoutJobsInput
    connect?: EntityBranchWhereUniqueInput
  }

  export type JobCandidateCreateNestedManyWithoutJobInput = {
    create?: XOR<Enumerable<JobCandidateCreateWithoutJobInput>, Enumerable<JobCandidateUncheckedCreateWithoutJobInput>>
    connectOrCreate?: Enumerable<JobCandidateCreateOrConnectWithoutJobInput>
    createMany?: JobCandidateCreateManyJobInputEnvelope
    connect?: Enumerable<JobCandidateWhereUniqueInput>
  }

  export type JobRequirementCreateNestedManyWithoutJobsInput = {
    create?: XOR<Enumerable<JobRequirementCreateWithoutJobsInput>, Enumerable<JobRequirementUncheckedCreateWithoutJobsInput>>
    connectOrCreate?: Enumerable<JobRequirementCreateOrConnectWithoutJobsInput>
    createMany?: JobRequirementCreateManyJobsInputEnvelope
    connect?: Enumerable<JobRequirementWhereUniqueInput>
  }

  export type JobReferenceListUncheckedCreateNestedManyWithoutJobInput = {
    create?: XOR<Enumerable<JobReferenceListCreateWithoutJobInput>, Enumerable<JobReferenceListUncheckedCreateWithoutJobInput>>
    connectOrCreate?: Enumerable<JobReferenceListCreateOrConnectWithoutJobInput>
    createMany?: JobReferenceListCreateManyJobInputEnvelope
    connect?: Enumerable<JobReferenceListWhereUniqueInput>
  }

  export type JobOtherLanguageUncheckedCreateNestedManyWithoutJobInput = {
    create?: XOR<Enumerable<JobOtherLanguageCreateWithoutJobInput>, Enumerable<JobOtherLanguageUncheckedCreateWithoutJobInput>>
    connectOrCreate?: Enumerable<JobOtherLanguageCreateOrConnectWithoutJobInput>
    createMany?: JobOtherLanguageCreateManyJobInputEnvelope
    connect?: Enumerable<JobOtherLanguageWhereUniqueInput>
  }

  export type JobCandidateUncheckedCreateNestedManyWithoutJobInput = {
    create?: XOR<Enumerable<JobCandidateCreateWithoutJobInput>, Enumerable<JobCandidateUncheckedCreateWithoutJobInput>>
    connectOrCreate?: Enumerable<JobCandidateCreateOrConnectWithoutJobInput>
    createMany?: JobCandidateCreateManyJobInputEnvelope
    connect?: Enumerable<JobCandidateWhereUniqueInput>
  }

  export type JobRequirementUncheckedCreateNestedManyWithoutJobsInput = {
    create?: XOR<Enumerable<JobRequirementCreateWithoutJobsInput>, Enumerable<JobRequirementUncheckedCreateWithoutJobsInput>>
    connectOrCreate?: Enumerable<JobRequirementCreateOrConnectWithoutJobsInput>
    createMany?: JobRequirementCreateManyJobsInputEnvelope
    connect?: Enumerable<JobRequirementWhereUniqueInput>
  }

  export type EnumJobPublishFieldUpdateOperationsInput = {
    set?: JobPublish
  }

  export type JobReferenceListUpdateManyWithoutJobNestedInput = {
    create?: XOR<Enumerable<JobReferenceListCreateWithoutJobInput>, Enumerable<JobReferenceListUncheckedCreateWithoutJobInput>>
    connectOrCreate?: Enumerable<JobReferenceListCreateOrConnectWithoutJobInput>
    upsert?: Enumerable<JobReferenceListUpsertWithWhereUniqueWithoutJobInput>
    createMany?: JobReferenceListCreateManyJobInputEnvelope
    set?: Enumerable<JobReferenceListWhereUniqueInput>
    disconnect?: Enumerable<JobReferenceListWhereUniqueInput>
    delete?: Enumerable<JobReferenceListWhereUniqueInput>
    connect?: Enumerable<JobReferenceListWhereUniqueInput>
    update?: Enumerable<JobReferenceListUpdateWithWhereUniqueWithoutJobInput>
    updateMany?: Enumerable<JobReferenceListUpdateManyWithWhereWithoutJobInput>
    deleteMany?: Enumerable<JobReferenceListScalarWhereInput>
  }

  export type JobUpdatecareer_levelInput = {
    set?: Enumerable<JobPosition>
    push?: Enumerable<JobPosition>
  }

  export type JobUpdatesmokeInput = {
    set?: Enumerable<Smoke>
    push?: Enumerable<Smoke>
  }

  export type EnumEmploymentStatusFieldUpdateOperationsInput = {
    set?: EmploymentStatus
  }

  export type EnumLanguageLevelFieldUpdateOperationsInput = {
    set?: LanguageLevel
  }

  export type JobOtherLanguageUpdateManyWithoutJobNestedInput = {
    create?: XOR<Enumerable<JobOtherLanguageCreateWithoutJobInput>, Enumerable<JobOtherLanguageUncheckedCreateWithoutJobInput>>
    connectOrCreate?: Enumerable<JobOtherLanguageCreateOrConnectWithoutJobInput>
    upsert?: Enumerable<JobOtherLanguageUpsertWithWhereUniqueWithoutJobInput>
    createMany?: JobOtherLanguageCreateManyJobInputEnvelope
    set?: Enumerable<JobOtherLanguageWhereUniqueInput>
    disconnect?: Enumerable<JobOtherLanguageWhereUniqueInput>
    delete?: Enumerable<JobOtherLanguageWhereUniqueInput>
    connect?: Enumerable<JobOtherLanguageWhereUniqueInput>
    update?: Enumerable<JobOtherLanguageUpdateWithWhereUniqueWithoutJobInput>
    updateMany?: Enumerable<JobOtherLanguageUpdateManyWithWhereWithoutJobInput>
    deleteMany?: Enumerable<JobOtherLanguageScalarWhereInput>
  }

  export type NullableEnumReqriutmentTypeFieldUpdateOperationsInput = {
    set?: ReqriutmentType | null
  }

  export type EnumSalaryTypeFieldUpdateOperationsInput = {
    set?: SalaryType
  }

  export type EntityBranchUpdateOneWithoutJobsNestedInput = {
    create?: XOR<EntityBranchCreateWithoutJobsInput, EntityBranchUncheckedCreateWithoutJobsInput>
    connectOrCreate?: EntityBranchCreateOrConnectWithoutJobsInput
    upsert?: EntityBranchUpsertWithoutJobsInput
    disconnect?: boolean
    delete?: boolean
    connect?: EntityBranchWhereUniqueInput
    update?: XOR<EntityBranchUpdateWithoutJobsInput, EntityBranchUncheckedUpdateWithoutJobsInput>
  }

  export type JobCandidateUpdateManyWithoutJobNestedInput = {
    create?: XOR<Enumerable<JobCandidateCreateWithoutJobInput>, Enumerable<JobCandidateUncheckedCreateWithoutJobInput>>
    connectOrCreate?: Enumerable<JobCandidateCreateOrConnectWithoutJobInput>
    upsert?: Enumerable<JobCandidateUpsertWithWhereUniqueWithoutJobInput>
    createMany?: JobCandidateCreateManyJobInputEnvelope
    set?: Enumerable<JobCandidateWhereUniqueInput>
    disconnect?: Enumerable<JobCandidateWhereUniqueInput>
    delete?: Enumerable<JobCandidateWhereUniqueInput>
    connect?: Enumerable<JobCandidateWhereUniqueInput>
    update?: Enumerable<JobCandidateUpdateWithWhereUniqueWithoutJobInput>
    updateMany?: Enumerable<JobCandidateUpdateManyWithWhereWithoutJobInput>
    deleteMany?: Enumerable<JobCandidateScalarWhereInput>
  }

  export type JobRequirementUpdateManyWithoutJobsNestedInput = {
    create?: XOR<Enumerable<JobRequirementCreateWithoutJobsInput>, Enumerable<JobRequirementUncheckedCreateWithoutJobsInput>>
    connectOrCreate?: Enumerable<JobRequirementCreateOrConnectWithoutJobsInput>
    upsert?: Enumerable<JobRequirementUpsertWithWhereUniqueWithoutJobsInput>
    createMany?: JobRequirementCreateManyJobsInputEnvelope
    set?: Enumerable<JobRequirementWhereUniqueInput>
    disconnect?: Enumerable<JobRequirementWhereUniqueInput>
    delete?: Enumerable<JobRequirementWhereUniqueInput>
    connect?: Enumerable<JobRequirementWhereUniqueInput>
    update?: Enumerable<JobRequirementUpdateWithWhereUniqueWithoutJobsInput>
    updateMany?: Enumerable<JobRequirementUpdateManyWithWhereWithoutJobsInput>
    deleteMany?: Enumerable<JobRequirementScalarWhereInput>
  }

  export type JobReferenceListUncheckedUpdateManyWithoutJobNestedInput = {
    create?: XOR<Enumerable<JobReferenceListCreateWithoutJobInput>, Enumerable<JobReferenceListUncheckedCreateWithoutJobInput>>
    connectOrCreate?: Enumerable<JobReferenceListCreateOrConnectWithoutJobInput>
    upsert?: Enumerable<JobReferenceListUpsertWithWhereUniqueWithoutJobInput>
    createMany?: JobReferenceListCreateManyJobInputEnvelope
    set?: Enumerable<JobReferenceListWhereUniqueInput>
    disconnect?: Enumerable<JobReferenceListWhereUniqueInput>
    delete?: Enumerable<JobReferenceListWhereUniqueInput>
    connect?: Enumerable<JobReferenceListWhereUniqueInput>
    update?: Enumerable<JobReferenceListUpdateWithWhereUniqueWithoutJobInput>
    updateMany?: Enumerable<JobReferenceListUpdateManyWithWhereWithoutJobInput>
    deleteMany?: Enumerable<JobReferenceListScalarWhereInput>
  }

  export type JobOtherLanguageUncheckedUpdateManyWithoutJobNestedInput = {
    create?: XOR<Enumerable<JobOtherLanguageCreateWithoutJobInput>, Enumerable<JobOtherLanguageUncheckedCreateWithoutJobInput>>
    connectOrCreate?: Enumerable<JobOtherLanguageCreateOrConnectWithoutJobInput>
    upsert?: Enumerable<JobOtherLanguageUpsertWithWhereUniqueWithoutJobInput>
    createMany?: JobOtherLanguageCreateManyJobInputEnvelope
    set?: Enumerable<JobOtherLanguageWhereUniqueInput>
    disconnect?: Enumerable<JobOtherLanguageWhereUniqueInput>
    delete?: Enumerable<JobOtherLanguageWhereUniqueInput>
    connect?: Enumerable<JobOtherLanguageWhereUniqueInput>
    update?: Enumerable<JobOtherLanguageUpdateWithWhereUniqueWithoutJobInput>
    updateMany?: Enumerable<JobOtherLanguageUpdateManyWithWhereWithoutJobInput>
    deleteMany?: Enumerable<JobOtherLanguageScalarWhereInput>
  }

  export type JobCandidateUncheckedUpdateManyWithoutJobNestedInput = {
    create?: XOR<Enumerable<JobCandidateCreateWithoutJobInput>, Enumerable<JobCandidateUncheckedCreateWithoutJobInput>>
    connectOrCreate?: Enumerable<JobCandidateCreateOrConnectWithoutJobInput>
    upsert?: Enumerable<JobCandidateUpsertWithWhereUniqueWithoutJobInput>
    createMany?: JobCandidateCreateManyJobInputEnvelope
    set?: Enumerable<JobCandidateWhereUniqueInput>
    disconnect?: Enumerable<JobCandidateWhereUniqueInput>
    delete?: Enumerable<JobCandidateWhereUniqueInput>
    connect?: Enumerable<JobCandidateWhereUniqueInput>
    update?: Enumerable<JobCandidateUpdateWithWhereUniqueWithoutJobInput>
    updateMany?: Enumerable<JobCandidateUpdateManyWithWhereWithoutJobInput>
    deleteMany?: Enumerable<JobCandidateScalarWhereInput>
  }

  export type JobRequirementUncheckedUpdateManyWithoutJobsNestedInput = {
    create?: XOR<Enumerable<JobRequirementCreateWithoutJobsInput>, Enumerable<JobRequirementUncheckedCreateWithoutJobsInput>>
    connectOrCreate?: Enumerable<JobRequirementCreateOrConnectWithoutJobsInput>
    upsert?: Enumerable<JobRequirementUpsertWithWhereUniqueWithoutJobsInput>
    createMany?: JobRequirementCreateManyJobsInputEnvelope
    set?: Enumerable<JobRequirementWhereUniqueInput>
    disconnect?: Enumerable<JobRequirementWhereUniqueInput>
    delete?: Enumerable<JobRequirementWhereUniqueInput>
    connect?: Enumerable<JobRequirementWhereUniqueInput>
    update?: Enumerable<JobRequirementUpdateWithWhereUniqueWithoutJobsInput>
    updateMany?: Enumerable<JobRequirementUpdateManyWithWhereWithoutJobsInput>
    deleteMany?: Enumerable<JobRequirementScalarWhereInput>
  }

  export type JobCreateNestedOneWithoutJob_other_languagesInput = {
    create?: XOR<JobCreateWithoutJob_other_languagesInput, JobUncheckedCreateWithoutJob_other_languagesInput>
    connectOrCreate?: JobCreateOrConnectWithoutJob_other_languagesInput
    connect?: JobWhereUniqueInput
  }

  export type JobUpdateOneRequiredWithoutJob_other_languagesNestedInput = {
    create?: XOR<JobCreateWithoutJob_other_languagesInput, JobUncheckedCreateWithoutJob_other_languagesInput>
    connectOrCreate?: JobCreateOrConnectWithoutJob_other_languagesInput
    upsert?: JobUpsertWithoutJob_other_languagesInput
    connect?: JobWhereUniqueInput
    update?: XOR<JobUpdateWithoutJob_other_languagesInput, JobUncheckedUpdateWithoutJob_other_languagesInput>
  }

  export type JobCreateNestedOneWithoutJob_referencesInput = {
    create?: XOR<JobCreateWithoutJob_referencesInput, JobUncheckedCreateWithoutJob_referencesInput>
    connectOrCreate?: JobCreateOrConnectWithoutJob_referencesInput
    connect?: JobWhereUniqueInput
  }

  export type ReferenceListCreateNestedOneWithoutJobReferenceListInput = {
    create?: XOR<ReferenceListCreateWithoutJobReferenceListInput, ReferenceListUncheckedCreateWithoutJobReferenceListInput>
    connectOrCreate?: ReferenceListCreateOrConnectWithoutJobReferenceListInput
    connect?: ReferenceListWhereUniqueInput
  }

  export type ReferenceListItemsCreateNestedOneWithoutJobReferenceListInput = {
    create?: XOR<ReferenceListItemsCreateWithoutJobReferenceListInput, ReferenceListItemsUncheckedCreateWithoutJobReferenceListInput>
    connectOrCreate?: ReferenceListItemsCreateOrConnectWithoutJobReferenceListInput
    connect?: ReferenceListItemsWhereUniqueInput
  }

  export type JobUpdateOneRequiredWithoutJob_referencesNestedInput = {
    create?: XOR<JobCreateWithoutJob_referencesInput, JobUncheckedCreateWithoutJob_referencesInput>
    connectOrCreate?: JobCreateOrConnectWithoutJob_referencesInput
    upsert?: JobUpsertWithoutJob_referencesInput
    connect?: JobWhereUniqueInput
    update?: XOR<JobUpdateWithoutJob_referencesInput, JobUncheckedUpdateWithoutJob_referencesInput>
  }

  export type ReferenceListUpdateOneRequiredWithoutJobReferenceListNestedInput = {
    create?: XOR<ReferenceListCreateWithoutJobReferenceListInput, ReferenceListUncheckedCreateWithoutJobReferenceListInput>
    connectOrCreate?: ReferenceListCreateOrConnectWithoutJobReferenceListInput
    upsert?: ReferenceListUpsertWithoutJobReferenceListInput
    connect?: ReferenceListWhereUniqueInput
    update?: XOR<ReferenceListUpdateWithoutJobReferenceListInput, ReferenceListUncheckedUpdateWithoutJobReferenceListInput>
  }

  export type ReferenceListItemsUpdateOneRequiredWithoutJobReferenceListNestedInput = {
    create?: XOR<ReferenceListItemsCreateWithoutJobReferenceListInput, ReferenceListItemsUncheckedCreateWithoutJobReferenceListInput>
    connectOrCreate?: ReferenceListItemsCreateOrConnectWithoutJobReferenceListInput
    upsert?: ReferenceListItemsUpsertWithoutJobReferenceListInput
    connect?: ReferenceListItemsWhereUniqueInput
    update?: XOR<ReferenceListItemsUpdateWithoutJobReferenceListInput, ReferenceListItemsUncheckedUpdateWithoutJobReferenceListInput>
  }

  export type JobCreateNestedOneWithoutJob_candidatesInput = {
    create?: XOR<JobCreateWithoutJob_candidatesInput, JobUncheckedCreateWithoutJob_candidatesInput>
    connectOrCreate?: JobCreateOrConnectWithoutJob_candidatesInput
    connect?: JobWhereUniqueInput
  }

  export type CustomerCreateNestedOneWithoutJob_candidatesInput = {
    create?: XOR<CustomerCreateWithoutJob_candidatesInput, CustomerUncheckedCreateWithoutJob_candidatesInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutJob_candidatesInput
    connect?: CustomerWhereUniqueInput
  }

  export type JobUpdateOneRequiredWithoutJob_candidatesNestedInput = {
    create?: XOR<JobCreateWithoutJob_candidatesInput, JobUncheckedCreateWithoutJob_candidatesInput>
    connectOrCreate?: JobCreateOrConnectWithoutJob_candidatesInput
    upsert?: JobUpsertWithoutJob_candidatesInput
    connect?: JobWhereUniqueInput
    update?: XOR<JobUpdateWithoutJob_candidatesInput, JobUncheckedUpdateWithoutJob_candidatesInput>
  }

  export type CustomerUpdateOneRequiredWithoutJob_candidatesNestedInput = {
    create?: XOR<CustomerCreateWithoutJob_candidatesInput, CustomerUncheckedCreateWithoutJob_candidatesInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutJob_candidatesInput
    upsert?: CustomerUpsertWithoutJob_candidatesInput
    connect?: CustomerWhereUniqueInput
    update?: XOR<CustomerUpdateWithoutJob_candidatesInput, CustomerUncheckedUpdateWithoutJob_candidatesInput>
  }

  export type JobCreateNestedOneWithoutJobRequirementInput = {
    create?: XOR<JobCreateWithoutJobRequirementInput, JobUncheckedCreateWithoutJobRequirementInput>
    connectOrCreate?: JobCreateOrConnectWithoutJobRequirementInput
    connect?: JobWhereUniqueInput
  }

  export type JobUpdateOneRequiredWithoutJobRequirementNestedInput = {
    create?: XOR<JobCreateWithoutJobRequirementInput, JobUncheckedCreateWithoutJobRequirementInput>
    connectOrCreate?: JobCreateOrConnectWithoutJobRequirementInput
    upsert?: JobUpsertWithoutJobRequirementInput
    connect?: JobWhereUniqueInput
    update?: XOR<JobUpdateWithoutJobRequirementInput, JobUncheckedUpdateWithoutJobRequirementInput>
  }

  export type UserCreateNestedOneWithoutLoggersInput = {
    create?: XOR<UserCreateWithoutLoggersInput, UserUncheckedCreateWithoutLoggersInput>
    connectOrCreate?: UserCreateOrConnectWithoutLoggersInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneWithoutLoggersNestedInput = {
    create?: XOR<UserCreateWithoutLoggersInput, UserUncheckedCreateWithoutLoggersInput>
    connectOrCreate?: UserCreateOrConnectWithoutLoggersInput
    upsert?: UserUpsertWithoutLoggersInput
    disconnect?: boolean
    delete?: boolean
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutLoggersInput, UserUncheckedUpdateWithoutLoggersInput>
  }

  export type PagesCreateNestedOneWithoutNewsInput = {
    create?: XOR<PagesCreateWithoutNewsInput, PagesUncheckedCreateWithoutNewsInput>
    connectOrCreate?: PagesCreateOrConnectWithoutNewsInput
    connect?: PagesWhereUniqueInput
  }

  export type PagesUpdateOneRequiredWithoutNewsNestedInput = {
    create?: XOR<PagesCreateWithoutNewsInput, PagesUncheckedCreateWithoutNewsInput>
    connectOrCreate?: PagesCreateOrConnectWithoutNewsInput
    upsert?: PagesUpsertWithoutNewsInput
    connect?: PagesWhereUniqueInput
    update?: XOR<PagesUpdateWithoutNewsInput, PagesUncheckedUpdateWithoutNewsInput>
  }

  export type UserCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutNotificationsNestedInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    upsert?: UserUpsertWithoutNotificationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type NewsCreateNestedManyWithoutPagesInput = {
    create?: XOR<Enumerable<NewsCreateWithoutPagesInput>, Enumerable<NewsUncheckedCreateWithoutPagesInput>>
    connectOrCreate?: Enumerable<NewsCreateOrConnectWithoutPagesInput>
    createMany?: NewsCreateManyPagesInputEnvelope
    connect?: Enumerable<NewsWhereUniqueInput>
  }

  export type NewsUncheckedCreateNestedManyWithoutPagesInput = {
    create?: XOR<Enumerable<NewsCreateWithoutPagesInput>, Enumerable<NewsUncheckedCreateWithoutPagesInput>>
    connectOrCreate?: Enumerable<NewsCreateOrConnectWithoutPagesInput>
    createMany?: NewsCreateManyPagesInputEnvelope
    connect?: Enumerable<NewsWhereUniqueInput>
  }

  export type NewsUpdateManyWithoutPagesNestedInput = {
    create?: XOR<Enumerable<NewsCreateWithoutPagesInput>, Enumerable<NewsUncheckedCreateWithoutPagesInput>>
    connectOrCreate?: Enumerable<NewsCreateOrConnectWithoutPagesInput>
    upsert?: Enumerable<NewsUpsertWithWhereUniqueWithoutPagesInput>
    createMany?: NewsCreateManyPagesInputEnvelope
    set?: Enumerable<NewsWhereUniqueInput>
    disconnect?: Enumerable<NewsWhereUniqueInput>
    delete?: Enumerable<NewsWhereUniqueInput>
    connect?: Enumerable<NewsWhereUniqueInput>
    update?: Enumerable<NewsUpdateWithWhereUniqueWithoutPagesInput>
    updateMany?: Enumerable<NewsUpdateManyWithWhereWithoutPagesInput>
    deleteMany?: Enumerable<NewsScalarWhereInput>
  }

  export type NewsUncheckedUpdateManyWithoutPagesNestedInput = {
    create?: XOR<Enumerable<NewsCreateWithoutPagesInput>, Enumerable<NewsUncheckedCreateWithoutPagesInput>>
    connectOrCreate?: Enumerable<NewsCreateOrConnectWithoutPagesInput>
    upsert?: Enumerable<NewsUpsertWithWhereUniqueWithoutPagesInput>
    createMany?: NewsCreateManyPagesInputEnvelope
    set?: Enumerable<NewsWhereUniqueInput>
    disconnect?: Enumerable<NewsWhereUniqueInput>
    delete?: Enumerable<NewsWhereUniqueInput>
    connect?: Enumerable<NewsWhereUniqueInput>
    update?: Enumerable<NewsUpdateWithWhereUniqueWithoutPagesInput>
    updateMany?: Enumerable<NewsUpdateManyWithWhereWithoutPagesInput>
    deleteMany?: Enumerable<NewsScalarWhereInput>
  }

  export type ReferenceListItemsCreateNestedManyWithoutListInput = {
    create?: XOR<Enumerable<ReferenceListItemsCreateWithoutListInput>, Enumerable<ReferenceListItemsUncheckedCreateWithoutListInput>>
    connectOrCreate?: Enumerable<ReferenceListItemsCreateOrConnectWithoutListInput>
    createMany?: ReferenceListItemsCreateManyListInputEnvelope
    connect?: Enumerable<ReferenceListItemsWhereUniqueInput>
  }

  export type JobReferenceListCreateNestedManyWithoutReference_listInput = {
    create?: XOR<Enumerable<JobReferenceListCreateWithoutReference_listInput>, Enumerable<JobReferenceListUncheckedCreateWithoutReference_listInput>>
    connectOrCreate?: Enumerable<JobReferenceListCreateOrConnectWithoutReference_listInput>
    createMany?: JobReferenceListCreateManyReference_listInputEnvelope
    connect?: Enumerable<JobReferenceListWhereUniqueInput>
  }

  export type ReferenceListItemsUncheckedCreateNestedManyWithoutListInput = {
    create?: XOR<Enumerable<ReferenceListItemsCreateWithoutListInput>, Enumerable<ReferenceListItemsUncheckedCreateWithoutListInput>>
    connectOrCreate?: Enumerable<ReferenceListItemsCreateOrConnectWithoutListInput>
    createMany?: ReferenceListItemsCreateManyListInputEnvelope
    connect?: Enumerable<ReferenceListItemsWhereUniqueInput>
  }

  export type JobReferenceListUncheckedCreateNestedManyWithoutReference_listInput = {
    create?: XOR<Enumerable<JobReferenceListCreateWithoutReference_listInput>, Enumerable<JobReferenceListUncheckedCreateWithoutReference_listInput>>
    connectOrCreate?: Enumerable<JobReferenceListCreateOrConnectWithoutReference_listInput>
    createMany?: JobReferenceListCreateManyReference_listInputEnvelope
    connect?: Enumerable<JobReferenceListWhereUniqueInput>
  }

  export type ReferenceListItemsUpdateManyWithoutListNestedInput = {
    create?: XOR<Enumerable<ReferenceListItemsCreateWithoutListInput>, Enumerable<ReferenceListItemsUncheckedCreateWithoutListInput>>
    connectOrCreate?: Enumerable<ReferenceListItemsCreateOrConnectWithoutListInput>
    upsert?: Enumerable<ReferenceListItemsUpsertWithWhereUniqueWithoutListInput>
    createMany?: ReferenceListItemsCreateManyListInputEnvelope
    set?: Enumerable<ReferenceListItemsWhereUniqueInput>
    disconnect?: Enumerable<ReferenceListItemsWhereUniqueInput>
    delete?: Enumerable<ReferenceListItemsWhereUniqueInput>
    connect?: Enumerable<ReferenceListItemsWhereUniqueInput>
    update?: Enumerable<ReferenceListItemsUpdateWithWhereUniqueWithoutListInput>
    updateMany?: Enumerable<ReferenceListItemsUpdateManyWithWhereWithoutListInput>
    deleteMany?: Enumerable<ReferenceListItemsScalarWhereInput>
  }

  export type JobReferenceListUpdateManyWithoutReference_listNestedInput = {
    create?: XOR<Enumerable<JobReferenceListCreateWithoutReference_listInput>, Enumerable<JobReferenceListUncheckedCreateWithoutReference_listInput>>
    connectOrCreate?: Enumerable<JobReferenceListCreateOrConnectWithoutReference_listInput>
    upsert?: Enumerable<JobReferenceListUpsertWithWhereUniqueWithoutReference_listInput>
    createMany?: JobReferenceListCreateManyReference_listInputEnvelope
    set?: Enumerable<JobReferenceListWhereUniqueInput>
    disconnect?: Enumerable<JobReferenceListWhereUniqueInput>
    delete?: Enumerable<JobReferenceListWhereUniqueInput>
    connect?: Enumerable<JobReferenceListWhereUniqueInput>
    update?: Enumerable<JobReferenceListUpdateWithWhereUniqueWithoutReference_listInput>
    updateMany?: Enumerable<JobReferenceListUpdateManyWithWhereWithoutReference_listInput>
    deleteMany?: Enumerable<JobReferenceListScalarWhereInput>
  }

  export type ReferenceListItemsUncheckedUpdateManyWithoutListNestedInput = {
    create?: XOR<Enumerable<ReferenceListItemsCreateWithoutListInput>, Enumerable<ReferenceListItemsUncheckedCreateWithoutListInput>>
    connectOrCreate?: Enumerable<ReferenceListItemsCreateOrConnectWithoutListInput>
    upsert?: Enumerable<ReferenceListItemsUpsertWithWhereUniqueWithoutListInput>
    createMany?: ReferenceListItemsCreateManyListInputEnvelope
    set?: Enumerable<ReferenceListItemsWhereUniqueInput>
    disconnect?: Enumerable<ReferenceListItemsWhereUniqueInput>
    delete?: Enumerable<ReferenceListItemsWhereUniqueInput>
    connect?: Enumerable<ReferenceListItemsWhereUniqueInput>
    update?: Enumerable<ReferenceListItemsUpdateWithWhereUniqueWithoutListInput>
    updateMany?: Enumerable<ReferenceListItemsUpdateManyWithWhereWithoutListInput>
    deleteMany?: Enumerable<ReferenceListItemsScalarWhereInput>
  }

  export type JobReferenceListUncheckedUpdateManyWithoutReference_listNestedInput = {
    create?: XOR<Enumerable<JobReferenceListCreateWithoutReference_listInput>, Enumerable<JobReferenceListUncheckedCreateWithoutReference_listInput>>
    connectOrCreate?: Enumerable<JobReferenceListCreateOrConnectWithoutReference_listInput>
    upsert?: Enumerable<JobReferenceListUpsertWithWhereUniqueWithoutReference_listInput>
    createMany?: JobReferenceListCreateManyReference_listInputEnvelope
    set?: Enumerable<JobReferenceListWhereUniqueInput>
    disconnect?: Enumerable<JobReferenceListWhereUniqueInput>
    delete?: Enumerable<JobReferenceListWhereUniqueInput>
    connect?: Enumerable<JobReferenceListWhereUniqueInput>
    update?: Enumerable<JobReferenceListUpdateWithWhereUniqueWithoutReference_listInput>
    updateMany?: Enumerable<JobReferenceListUpdateManyWithWhereWithoutReference_listInput>
    deleteMany?: Enumerable<JobReferenceListScalarWhereInput>
  }

  export type ReferenceListCreateNestedOneWithoutListitemsInput = {
    create?: XOR<ReferenceListCreateWithoutListitemsInput, ReferenceListUncheckedCreateWithoutListitemsInput>
    connectOrCreate?: ReferenceListCreateOrConnectWithoutListitemsInput
    connect?: ReferenceListWhereUniqueInput
  }

  export type CustomerExperienceCreateNestedManyWithoutListitemsInput = {
    create?: XOR<Enumerable<CustomerExperienceCreateWithoutListitemsInput>, Enumerable<CustomerExperienceUncheckedCreateWithoutListitemsInput>>
    connectOrCreate?: Enumerable<CustomerExperienceCreateOrConnectWithoutListitemsInput>
    createMany?: CustomerExperienceCreateManyListitemsInputEnvelope
    connect?: Enumerable<CustomerExperienceWhereUniqueInput>
  }

  export type DictionaryCreateNestedOneWithoutReference_listitemsInput = {
    create?: XOR<DictionaryCreateWithoutReference_listitemsInput, DictionaryUncheckedCreateWithoutReference_listitemsInput>
    connectOrCreate?: DictionaryCreateOrConnectWithoutReference_listitemsInput
    connect?: DictionaryWhereUniqueInput
  }

  export type JobReferenceListCreateNestedManyWithoutReference_list_itemInput = {
    create?: XOR<Enumerable<JobReferenceListCreateWithoutReference_list_itemInput>, Enumerable<JobReferenceListUncheckedCreateWithoutReference_list_itemInput>>
    connectOrCreate?: Enumerable<JobReferenceListCreateOrConnectWithoutReference_list_itemInput>
    createMany?: JobReferenceListCreateManyReference_list_itemInputEnvelope
    connect?: Enumerable<JobReferenceListWhereUniqueInput>
  }

  export type CustomerExperienceUncheckedCreateNestedManyWithoutListitemsInput = {
    create?: XOR<Enumerable<CustomerExperienceCreateWithoutListitemsInput>, Enumerable<CustomerExperienceUncheckedCreateWithoutListitemsInput>>
    connectOrCreate?: Enumerable<CustomerExperienceCreateOrConnectWithoutListitemsInput>
    createMany?: CustomerExperienceCreateManyListitemsInputEnvelope
    connect?: Enumerable<CustomerExperienceWhereUniqueInput>
  }

  export type JobReferenceListUncheckedCreateNestedManyWithoutReference_list_itemInput = {
    create?: XOR<Enumerable<JobReferenceListCreateWithoutReference_list_itemInput>, Enumerable<JobReferenceListUncheckedCreateWithoutReference_list_itemInput>>
    connectOrCreate?: Enumerable<JobReferenceListCreateOrConnectWithoutReference_list_itemInput>
    createMany?: JobReferenceListCreateManyReference_list_itemInputEnvelope
    connect?: Enumerable<JobReferenceListWhereUniqueInput>
  }

  export type ReferenceListUpdateOneRequiredWithoutListitemsNestedInput = {
    create?: XOR<ReferenceListCreateWithoutListitemsInput, ReferenceListUncheckedCreateWithoutListitemsInput>
    connectOrCreate?: ReferenceListCreateOrConnectWithoutListitemsInput
    upsert?: ReferenceListUpsertWithoutListitemsInput
    connect?: ReferenceListWhereUniqueInput
    update?: XOR<ReferenceListUpdateWithoutListitemsInput, ReferenceListUncheckedUpdateWithoutListitemsInput>
  }

  export type CustomerExperienceUpdateManyWithoutListitemsNestedInput = {
    create?: XOR<Enumerable<CustomerExperienceCreateWithoutListitemsInput>, Enumerable<CustomerExperienceUncheckedCreateWithoutListitemsInput>>
    connectOrCreate?: Enumerable<CustomerExperienceCreateOrConnectWithoutListitemsInput>
    upsert?: Enumerable<CustomerExperienceUpsertWithWhereUniqueWithoutListitemsInput>
    createMany?: CustomerExperienceCreateManyListitemsInputEnvelope
    set?: Enumerable<CustomerExperienceWhereUniqueInput>
    disconnect?: Enumerable<CustomerExperienceWhereUniqueInput>
    delete?: Enumerable<CustomerExperienceWhereUniqueInput>
    connect?: Enumerable<CustomerExperienceWhereUniqueInput>
    update?: Enumerable<CustomerExperienceUpdateWithWhereUniqueWithoutListitemsInput>
    updateMany?: Enumerable<CustomerExperienceUpdateManyWithWhereWithoutListitemsInput>
    deleteMany?: Enumerable<CustomerExperienceScalarWhereInput>
  }

  export type DictionaryUpdateOneWithoutReference_listitemsNestedInput = {
    create?: XOR<DictionaryCreateWithoutReference_listitemsInput, DictionaryUncheckedCreateWithoutReference_listitemsInput>
    connectOrCreate?: DictionaryCreateOrConnectWithoutReference_listitemsInput
    upsert?: DictionaryUpsertWithoutReference_listitemsInput
    disconnect?: boolean
    delete?: boolean
    connect?: DictionaryWhereUniqueInput
    update?: XOR<DictionaryUpdateWithoutReference_listitemsInput, DictionaryUncheckedUpdateWithoutReference_listitemsInput>
  }

  export type JobReferenceListUpdateManyWithoutReference_list_itemNestedInput = {
    create?: XOR<Enumerable<JobReferenceListCreateWithoutReference_list_itemInput>, Enumerable<JobReferenceListUncheckedCreateWithoutReference_list_itemInput>>
    connectOrCreate?: Enumerable<JobReferenceListCreateOrConnectWithoutReference_list_itemInput>
    upsert?: Enumerable<JobReferenceListUpsertWithWhereUniqueWithoutReference_list_itemInput>
    createMany?: JobReferenceListCreateManyReference_list_itemInputEnvelope
    set?: Enumerable<JobReferenceListWhereUniqueInput>
    disconnect?: Enumerable<JobReferenceListWhereUniqueInput>
    delete?: Enumerable<JobReferenceListWhereUniqueInput>
    connect?: Enumerable<JobReferenceListWhereUniqueInput>
    update?: Enumerable<JobReferenceListUpdateWithWhereUniqueWithoutReference_list_itemInput>
    updateMany?: Enumerable<JobReferenceListUpdateManyWithWhereWithoutReference_list_itemInput>
    deleteMany?: Enumerable<JobReferenceListScalarWhereInput>
  }

  export type CustomerExperienceUncheckedUpdateManyWithoutListitemsNestedInput = {
    create?: XOR<Enumerable<CustomerExperienceCreateWithoutListitemsInput>, Enumerable<CustomerExperienceUncheckedCreateWithoutListitemsInput>>
    connectOrCreate?: Enumerable<CustomerExperienceCreateOrConnectWithoutListitemsInput>
    upsert?: Enumerable<CustomerExperienceUpsertWithWhereUniqueWithoutListitemsInput>
    createMany?: CustomerExperienceCreateManyListitemsInputEnvelope
    set?: Enumerable<CustomerExperienceWhereUniqueInput>
    disconnect?: Enumerable<CustomerExperienceWhereUniqueInput>
    delete?: Enumerable<CustomerExperienceWhereUniqueInput>
    connect?: Enumerable<CustomerExperienceWhereUniqueInput>
    update?: Enumerable<CustomerExperienceUpdateWithWhereUniqueWithoutListitemsInput>
    updateMany?: Enumerable<CustomerExperienceUpdateManyWithWhereWithoutListitemsInput>
    deleteMany?: Enumerable<CustomerExperienceScalarWhereInput>
  }

  export type JobReferenceListUncheckedUpdateManyWithoutReference_list_itemNestedInput = {
    create?: XOR<Enumerable<JobReferenceListCreateWithoutReference_list_itemInput>, Enumerable<JobReferenceListUncheckedCreateWithoutReference_list_itemInput>>
    connectOrCreate?: Enumerable<JobReferenceListCreateOrConnectWithoutReference_list_itemInput>
    upsert?: Enumerable<JobReferenceListUpsertWithWhereUniqueWithoutReference_list_itemInput>
    createMany?: JobReferenceListCreateManyReference_list_itemInputEnvelope
    set?: Enumerable<JobReferenceListWhereUniqueInput>
    disconnect?: Enumerable<JobReferenceListWhereUniqueInput>
    delete?: Enumerable<JobReferenceListWhereUniqueInput>
    connect?: Enumerable<JobReferenceListWhereUniqueInput>
    update?: Enumerable<JobReferenceListUpdateWithWhereUniqueWithoutReference_list_itemInput>
    updateMany?: Enumerable<JobReferenceListUpdateManyWithWhereWithoutReference_list_itemInput>
    deleteMany?: Enumerable<JobReferenceListScalarWhereInput>
  }

  export type UserCreateNestedOneWithoutScoutFavInput = {
    create?: XOR<UserCreateWithoutScoutFavInput, UserUncheckedCreateWithoutScoutFavInput>
    connectOrCreate?: UserCreateOrConnectWithoutScoutFavInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutScoutFavNestedInput = {
    create?: XOR<UserCreateWithoutScoutFavInput, UserUncheckedCreateWithoutScoutFavInput>
    connectOrCreate?: UserCreateOrConnectWithoutScoutFavInput
    upsert?: UserUpsertWithoutScoutFavInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutScoutFavInput, UserUncheckedUpdateWithoutScoutFavInput>
  }

  export type CustomerCreateNestedOneWithoutUserInput = {
    create?: XOR<CustomerCreateWithoutUserInput, CustomerUncheckedCreateWithoutUserInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutUserInput
    connect?: CustomerWhereUniqueInput
  }

  export type LoggerCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<LoggerCreateWithoutUserInput>, Enumerable<LoggerUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<LoggerCreateOrConnectWithoutUserInput>
    createMany?: LoggerCreateManyUserInputEnvelope
    connect?: Enumerable<LoggerWhereUniqueInput>
  }

  export type InquiryCreateNestedManyWithoutFromuserInput = {
    create?: XOR<Enumerable<InquiryCreateWithoutFromuserInput>, Enumerable<InquiryUncheckedCreateWithoutFromuserInput>>
    connectOrCreate?: Enumerable<InquiryCreateOrConnectWithoutFromuserInput>
    createMany?: InquiryCreateManyFromuserInputEnvelope
    connect?: Enumerable<InquiryWhereUniqueInput>
  }

  export type InquiryCreateNestedManyWithoutAssignUserInput = {
    create?: XOR<Enumerable<InquiryCreateWithoutAssignUserInput>, Enumerable<InquiryUncheckedCreateWithoutAssignUserInput>>
    connectOrCreate?: Enumerable<InquiryCreateOrConnectWithoutAssignUserInput>
    createMany?: InquiryCreateManyAssignUserInputEnvelope
    connect?: Enumerable<InquiryWhereUniqueInput>
  }

  export type NotificationCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<NotificationCreateWithoutUserInput>, Enumerable<NotificationUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<NotificationCreateOrConnectWithoutUserInput>
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: Enumerable<NotificationWhereUniqueInput>
  }

  export type ScoutFavCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<ScoutFavCreateWithoutUserInput>, Enumerable<ScoutFavUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ScoutFavCreateOrConnectWithoutUserInput>
    createMany?: ScoutFavCreateManyUserInputEnvelope
    connect?: Enumerable<ScoutFavWhereUniqueInput>
  }

  export type LoggerUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<LoggerCreateWithoutUserInput>, Enumerable<LoggerUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<LoggerCreateOrConnectWithoutUserInput>
    createMany?: LoggerCreateManyUserInputEnvelope
    connect?: Enumerable<LoggerWhereUniqueInput>
  }

  export type InquiryUncheckedCreateNestedManyWithoutFromuserInput = {
    create?: XOR<Enumerable<InquiryCreateWithoutFromuserInput>, Enumerable<InquiryUncheckedCreateWithoutFromuserInput>>
    connectOrCreate?: Enumerable<InquiryCreateOrConnectWithoutFromuserInput>
    createMany?: InquiryCreateManyFromuserInputEnvelope
    connect?: Enumerable<InquiryWhereUniqueInput>
  }

  export type InquiryUncheckedCreateNestedManyWithoutAssignUserInput = {
    create?: XOR<Enumerable<InquiryCreateWithoutAssignUserInput>, Enumerable<InquiryUncheckedCreateWithoutAssignUserInput>>
    connectOrCreate?: Enumerable<InquiryCreateOrConnectWithoutAssignUserInput>
    createMany?: InquiryCreateManyAssignUserInputEnvelope
    connect?: Enumerable<InquiryWhereUniqueInput>
  }

  export type NotificationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<NotificationCreateWithoutUserInput>, Enumerable<NotificationUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<NotificationCreateOrConnectWithoutUserInput>
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: Enumerable<NotificationWhereUniqueInput>
  }

  export type ScoutFavUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<ScoutFavCreateWithoutUserInput>, Enumerable<ScoutFavUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ScoutFavCreateOrConnectWithoutUserInput>
    createMany?: ScoutFavCreateManyUserInputEnvelope
    connect?: Enumerable<ScoutFavWhereUniqueInput>
  }

  export type EnumUserStatusFieldUpdateOperationsInput = {
    set?: UserStatus
  }

  export type CustomerUpdateOneWithoutUserNestedInput = {
    create?: XOR<CustomerCreateWithoutUserInput, CustomerUncheckedCreateWithoutUserInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutUserInput
    upsert?: CustomerUpsertWithoutUserInput
    disconnect?: boolean
    delete?: boolean
    connect?: CustomerWhereUniqueInput
    update?: XOR<CustomerUpdateWithoutUserInput, CustomerUncheckedUpdateWithoutUserInput>
  }

  export type LoggerUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<LoggerCreateWithoutUserInput>, Enumerable<LoggerUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<LoggerCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<LoggerUpsertWithWhereUniqueWithoutUserInput>
    createMany?: LoggerCreateManyUserInputEnvelope
    set?: Enumerable<LoggerWhereUniqueInput>
    disconnect?: Enumerable<LoggerWhereUniqueInput>
    delete?: Enumerable<LoggerWhereUniqueInput>
    connect?: Enumerable<LoggerWhereUniqueInput>
    update?: Enumerable<LoggerUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<LoggerUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<LoggerScalarWhereInput>
  }

  export type InquiryUpdateManyWithoutFromuserNestedInput = {
    create?: XOR<Enumerable<InquiryCreateWithoutFromuserInput>, Enumerable<InquiryUncheckedCreateWithoutFromuserInput>>
    connectOrCreate?: Enumerable<InquiryCreateOrConnectWithoutFromuserInput>
    upsert?: Enumerable<InquiryUpsertWithWhereUniqueWithoutFromuserInput>
    createMany?: InquiryCreateManyFromuserInputEnvelope
    set?: Enumerable<InquiryWhereUniqueInput>
    disconnect?: Enumerable<InquiryWhereUniqueInput>
    delete?: Enumerable<InquiryWhereUniqueInput>
    connect?: Enumerable<InquiryWhereUniqueInput>
    update?: Enumerable<InquiryUpdateWithWhereUniqueWithoutFromuserInput>
    updateMany?: Enumerable<InquiryUpdateManyWithWhereWithoutFromuserInput>
    deleteMany?: Enumerable<InquiryScalarWhereInput>
  }

  export type InquiryUpdateManyWithoutAssignUserNestedInput = {
    create?: XOR<Enumerable<InquiryCreateWithoutAssignUserInput>, Enumerable<InquiryUncheckedCreateWithoutAssignUserInput>>
    connectOrCreate?: Enumerable<InquiryCreateOrConnectWithoutAssignUserInput>
    upsert?: Enumerable<InquiryUpsertWithWhereUniqueWithoutAssignUserInput>
    createMany?: InquiryCreateManyAssignUserInputEnvelope
    set?: Enumerable<InquiryWhereUniqueInput>
    disconnect?: Enumerable<InquiryWhereUniqueInput>
    delete?: Enumerable<InquiryWhereUniqueInput>
    connect?: Enumerable<InquiryWhereUniqueInput>
    update?: Enumerable<InquiryUpdateWithWhereUniqueWithoutAssignUserInput>
    updateMany?: Enumerable<InquiryUpdateManyWithWhereWithoutAssignUserInput>
    deleteMany?: Enumerable<InquiryScalarWhereInput>
  }

  export type NotificationUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<NotificationCreateWithoutUserInput>, Enumerable<NotificationUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<NotificationCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<NotificationUpsertWithWhereUniqueWithoutUserInput>
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: Enumerable<NotificationWhereUniqueInput>
    disconnect?: Enumerable<NotificationWhereUniqueInput>
    delete?: Enumerable<NotificationWhereUniqueInput>
    connect?: Enumerable<NotificationWhereUniqueInput>
    update?: Enumerable<NotificationUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<NotificationUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<NotificationScalarWhereInput>
  }

  export type ScoutFavUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<ScoutFavCreateWithoutUserInput>, Enumerable<ScoutFavUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ScoutFavCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<ScoutFavUpsertWithWhereUniqueWithoutUserInput>
    createMany?: ScoutFavCreateManyUserInputEnvelope
    set?: Enumerable<ScoutFavWhereUniqueInput>
    disconnect?: Enumerable<ScoutFavWhereUniqueInput>
    delete?: Enumerable<ScoutFavWhereUniqueInput>
    connect?: Enumerable<ScoutFavWhereUniqueInput>
    update?: Enumerable<ScoutFavUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<ScoutFavUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<ScoutFavScalarWhereInput>
  }

  export type LoggerUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<LoggerCreateWithoutUserInput>, Enumerable<LoggerUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<LoggerCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<LoggerUpsertWithWhereUniqueWithoutUserInput>
    createMany?: LoggerCreateManyUserInputEnvelope
    set?: Enumerable<LoggerWhereUniqueInput>
    disconnect?: Enumerable<LoggerWhereUniqueInput>
    delete?: Enumerable<LoggerWhereUniqueInput>
    connect?: Enumerable<LoggerWhereUniqueInput>
    update?: Enumerable<LoggerUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<LoggerUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<LoggerScalarWhereInput>
  }

  export type InquiryUncheckedUpdateManyWithoutFromuserNestedInput = {
    create?: XOR<Enumerable<InquiryCreateWithoutFromuserInput>, Enumerable<InquiryUncheckedCreateWithoutFromuserInput>>
    connectOrCreate?: Enumerable<InquiryCreateOrConnectWithoutFromuserInput>
    upsert?: Enumerable<InquiryUpsertWithWhereUniqueWithoutFromuserInput>
    createMany?: InquiryCreateManyFromuserInputEnvelope
    set?: Enumerable<InquiryWhereUniqueInput>
    disconnect?: Enumerable<InquiryWhereUniqueInput>
    delete?: Enumerable<InquiryWhereUniqueInput>
    connect?: Enumerable<InquiryWhereUniqueInput>
    update?: Enumerable<InquiryUpdateWithWhereUniqueWithoutFromuserInput>
    updateMany?: Enumerable<InquiryUpdateManyWithWhereWithoutFromuserInput>
    deleteMany?: Enumerable<InquiryScalarWhereInput>
  }

  export type InquiryUncheckedUpdateManyWithoutAssignUserNestedInput = {
    create?: XOR<Enumerable<InquiryCreateWithoutAssignUserInput>, Enumerable<InquiryUncheckedCreateWithoutAssignUserInput>>
    connectOrCreate?: Enumerable<InquiryCreateOrConnectWithoutAssignUserInput>
    upsert?: Enumerable<InquiryUpsertWithWhereUniqueWithoutAssignUserInput>
    createMany?: InquiryCreateManyAssignUserInputEnvelope
    set?: Enumerable<InquiryWhereUniqueInput>
    disconnect?: Enumerable<InquiryWhereUniqueInput>
    delete?: Enumerable<InquiryWhereUniqueInput>
    connect?: Enumerable<InquiryWhereUniqueInput>
    update?: Enumerable<InquiryUpdateWithWhereUniqueWithoutAssignUserInput>
    updateMany?: Enumerable<InquiryUpdateManyWithWhereWithoutAssignUserInput>
    deleteMany?: Enumerable<InquiryScalarWhereInput>
  }

  export type NotificationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<NotificationCreateWithoutUserInput>, Enumerable<NotificationUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<NotificationCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<NotificationUpsertWithWhereUniqueWithoutUserInput>
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: Enumerable<NotificationWhereUniqueInput>
    disconnect?: Enumerable<NotificationWhereUniqueInput>
    delete?: Enumerable<NotificationWhereUniqueInput>
    connect?: Enumerable<NotificationWhereUniqueInput>
    update?: Enumerable<NotificationUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<NotificationUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<NotificationScalarWhereInput>
  }

  export type ScoutFavUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<ScoutFavCreateWithoutUserInput>, Enumerable<ScoutFavUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ScoutFavCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<ScoutFavUpsertWithWhereUniqueWithoutUserInput>
    createMany?: ScoutFavCreateManyUserInputEnvelope
    set?: Enumerable<ScoutFavWhereUniqueInput>
    disconnect?: Enumerable<ScoutFavWhereUniqueInput>
    delete?: Enumerable<ScoutFavWhereUniqueInput>
    connect?: Enumerable<ScoutFavWhereUniqueInput>
    update?: Enumerable<ScoutFavUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<ScoutFavUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<ScoutFavScalarWhereInput>
  }

  export type NestedStringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type NestedStringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type NestedEnumUserActionFilter = {
    equals?: UserAction
    in?: Enumerable<UserAction>
    notIn?: Enumerable<UserAction>
    not?: NestedEnumUserActionFilter | UserAction
  }

  export type NestedEnumUserRoleFilter = {
    equals?: UserRole
    in?: Enumerable<UserRole>
    notIn?: Enumerable<UserRole>
    not?: NestedEnumUserRoleFilter | UserRole
  }

  export type NestedBoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type NestedDateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type NestedStringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type NestedIntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type NestedStringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type NestedIntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type NestedEnumUserActionWithAggregatesFilter = {
    equals?: UserAction
    in?: Enumerable<UserAction>
    notIn?: Enumerable<UserAction>
    not?: NestedEnumUserActionWithAggregatesFilter | UserAction
    _count?: NestedIntFilter
    _min?: NestedEnumUserActionFilter
    _max?: NestedEnumUserActionFilter
  }

  export type NestedEnumUserRoleWithAggregatesFilter = {
    equals?: UserRole
    in?: Enumerable<UserRole>
    notIn?: Enumerable<UserRole>
    not?: NestedEnumUserRoleWithAggregatesFilter | UserRole
    _count?: NestedIntFilter
    _min?: NestedEnumUserRoleFilter
    _max?: NestedEnumUserRoleFilter
  }

  export type NestedBoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    _min?: NestedBoolFilter
    _max?: NestedBoolFilter
  }

  export type NestedDateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type NestedEnumGenderNullableFilter = {
    equals?: Gender | null
    in?: Enumerable<Gender> | null
    notIn?: Enumerable<Gender> | null
    not?: NestedEnumGenderNullableFilter | Gender | null
  }

  export type NestedDateTimeNullableFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableFilter | Date | string | null
  }

  export type NestedEnumCustomerStatusNullableFilter = {
    equals?: CustomerStatus | null
    in?: Enumerable<CustomerStatus> | null
    notIn?: Enumerable<CustomerStatus> | null
    not?: NestedEnumCustomerStatusNullableFilter | CustomerStatus | null
  }

  export type NestedEnumGenderNullableWithAggregatesFilter = {
    equals?: Gender | null
    in?: Enumerable<Gender> | null
    notIn?: Enumerable<Gender> | null
    not?: NestedEnumGenderNullableWithAggregatesFilter | Gender | null
    _count?: NestedIntNullableFilter
    _min?: NestedEnumGenderNullableFilter
    _max?: NestedEnumGenderNullableFilter
  }

  export type NestedDateTimeNullableWithAggregatesFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableWithAggregatesFilter | Date | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedDateTimeNullableFilter
    _max?: NestedDateTimeNullableFilter
  }
  export type NestedJsonNullableFilter = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase>, Exclude<keyof Required<NestedJsonNullableFilterBase>, 'path'>>,
        Required<NestedJsonNullableFilterBase>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase>, 'path'>>

  export type NestedJsonNullableFilterBase = {
    equals?: InputJsonValue | JsonNullValueFilter
    path?: Array<string>
    string_contains?: string
    string_starts_with?: string
    string_ends_with?: string
    array_contains?: InputJsonValue | null
    array_starts_with?: InputJsonValue | null
    array_ends_with?: InputJsonValue | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonNullValueFilter
  }

  export type NestedIntNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedIntNullableFilter
    _min?: NestedIntNullableFilter
    _max?: NestedIntNullableFilter
  }

  export type NestedFloatNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableFilter | number | null
  }

  export type NestedEnumCustomerStatusNullableWithAggregatesFilter = {
    equals?: CustomerStatus | null
    in?: Enumerable<CustomerStatus> | null
    notIn?: Enumerable<CustomerStatus> | null
    not?: NestedEnumCustomerStatusNullableWithAggregatesFilter | CustomerStatus | null
    _count?: NestedIntNullableFilter
    _min?: NestedEnumCustomerStatusNullableFilter
    _max?: NestedEnumCustomerStatusNullableFilter
  }

  export type NestedIntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type NestedFloatFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type NestedBoolNullableFilter = {
    equals?: boolean | null
    not?: NestedBoolNullableFilter | boolean | null
  }

  export type NestedBoolNullableWithAggregatesFilter = {
    equals?: boolean | null
    not?: NestedBoolNullableWithAggregatesFilter | boolean | null
    _count?: NestedIntNullableFilter
    _min?: NestedBoolNullableFilter
    _max?: NestedBoolNullableFilter
  }

  export type NestedEnumLanguageLevelNullableFilter = {
    equals?: LanguageLevel | null
    in?: Enumerable<LanguageLevel> | null
    notIn?: Enumerable<LanguageLevel> | null
    not?: NestedEnumLanguageLevelNullableFilter | LanguageLevel | null
  }

  export type NestedEnumLanguageLevelNullableWithAggregatesFilter = {
    equals?: LanguageLevel | null
    in?: Enumerable<LanguageLevel> | null
    notIn?: Enumerable<LanguageLevel> | null
    not?: NestedEnumLanguageLevelNullableWithAggregatesFilter | LanguageLevel | null
    _count?: NestedIntNullableFilter
    _min?: NestedEnumLanguageLevelNullableFilter
    _max?: NestedEnumLanguageLevelNullableFilter
  }

  export type NestedEnumStatusVisaNullableFilter = {
    equals?: StatusVisa | null
    in?: Enumerable<StatusVisa> | null
    notIn?: Enumerable<StatusVisa> | null
    not?: NestedEnumStatusVisaNullableFilter | StatusVisa | null
  }

  export type NestedEnumStatusVisaNullableWithAggregatesFilter = {
    equals?: StatusVisa | null
    in?: Enumerable<StatusVisa> | null
    notIn?: Enumerable<StatusVisa> | null
    not?: NestedEnumStatusVisaNullableWithAggregatesFilter | StatusVisa | null
    _count?: NestedIntNullableFilter
    _min?: NestedEnumStatusVisaNullableFilter
    _max?: NestedEnumStatusVisaNullableFilter
  }

  export type NestedEnumJobPositionNullableFilter = {
    equals?: JobPosition | null
    in?: Enumerable<JobPosition> | null
    notIn?: Enumerable<JobPosition> | null
    not?: NestedEnumJobPositionNullableFilter | JobPosition | null
  }

  export type NestedEnumJobPositionNullableWithAggregatesFilter = {
    equals?: JobPosition | null
    in?: Enumerable<JobPosition> | null
    notIn?: Enumerable<JobPosition> | null
    not?: NestedEnumJobPositionNullableWithAggregatesFilter | JobPosition | null
    _count?: NestedIntNullableFilter
    _min?: NestedEnumJobPositionNullableFilter
    _max?: NestedEnumJobPositionNullableFilter
  }

  export type NestedEnumFileTypeFilter = {
    equals?: FileType
    in?: Enumerable<FileType>
    notIn?: Enumerable<FileType>
    not?: NestedEnumFileTypeFilter | FileType
  }

  export type NestedEnumFileSourceFilter = {
    equals?: FileSource
    in?: Enumerable<FileSource>
    notIn?: Enumerable<FileSource>
    not?: NestedEnumFileSourceFilter | FileSource
  }

  export type NestedEnumFileTypeWithAggregatesFilter = {
    equals?: FileType
    in?: Enumerable<FileType>
    notIn?: Enumerable<FileType>
    not?: NestedEnumFileTypeWithAggregatesFilter | FileType
    _count?: NestedIntFilter
    _min?: NestedEnumFileTypeFilter
    _max?: NestedEnumFileTypeFilter
  }

  export type NestedEnumFileSourceWithAggregatesFilter = {
    equals?: FileSource
    in?: Enumerable<FileSource>
    notIn?: Enumerable<FileSource>
    not?: NestedEnumFileSourceWithAggregatesFilter | FileSource
    _count?: NestedIntFilter
    _min?: NestedEnumFileSourceFilter
    _max?: NestedEnumFileSourceFilter
  }

  export type NestedEnumInquiryStatusNullableFilter = {
    equals?: InquiryStatus | null
    in?: Enumerable<InquiryStatus> | null
    notIn?: Enumerable<InquiryStatus> | null
    not?: NestedEnumInquiryStatusNullableFilter | InquiryStatus | null
  }

  export type NestedEnumInquiryStatusNullableWithAggregatesFilter = {
    equals?: InquiryStatus | null
    in?: Enumerable<InquiryStatus> | null
    notIn?: Enumerable<InquiryStatus> | null
    not?: NestedEnumInquiryStatusNullableWithAggregatesFilter | InquiryStatus | null
    _count?: NestedIntNullableFilter
    _min?: NestedEnumInquiryStatusNullableFilter
    _max?: NestedEnumInquiryStatusNullableFilter
  }

  export type NestedEnumJobPublishFilter = {
    equals?: JobPublish
    in?: Enumerable<JobPublish>
    notIn?: Enumerable<JobPublish>
    not?: NestedEnumJobPublishFilter | JobPublish
  }

  export type NestedEnumEmploymentStatusFilter = {
    equals?: EmploymentStatus
    in?: Enumerable<EmploymentStatus>
    notIn?: Enumerable<EmploymentStatus>
    not?: NestedEnumEmploymentStatusFilter | EmploymentStatus
  }

  export type NestedEnumLanguageLevelFilter = {
    equals?: LanguageLevel
    in?: Enumerable<LanguageLevel>
    notIn?: Enumerable<LanguageLevel>
    not?: NestedEnumLanguageLevelFilter | LanguageLevel
  }

  export type NestedEnumReqriutmentTypeNullableFilter = {
    equals?: ReqriutmentType | null
    in?: Enumerable<ReqriutmentType> | null
    notIn?: Enumerable<ReqriutmentType> | null
    not?: NestedEnumReqriutmentTypeNullableFilter | ReqriutmentType | null
  }

  export type NestedEnumSalaryTypeFilter = {
    equals?: SalaryType
    in?: Enumerable<SalaryType>
    notIn?: Enumerable<SalaryType>
    not?: NestedEnumSalaryTypeFilter | SalaryType
  }

  export type NestedEnumJobPublishWithAggregatesFilter = {
    equals?: JobPublish
    in?: Enumerable<JobPublish>
    notIn?: Enumerable<JobPublish>
    not?: NestedEnumJobPublishWithAggregatesFilter | JobPublish
    _count?: NestedIntFilter
    _min?: NestedEnumJobPublishFilter
    _max?: NestedEnumJobPublishFilter
  }

  export type NestedEnumEmploymentStatusWithAggregatesFilter = {
    equals?: EmploymentStatus
    in?: Enumerable<EmploymentStatus>
    notIn?: Enumerable<EmploymentStatus>
    not?: NestedEnumEmploymentStatusWithAggregatesFilter | EmploymentStatus
    _count?: NestedIntFilter
    _min?: NestedEnumEmploymentStatusFilter
    _max?: NestedEnumEmploymentStatusFilter
  }

  export type NestedEnumLanguageLevelWithAggregatesFilter = {
    equals?: LanguageLevel
    in?: Enumerable<LanguageLevel>
    notIn?: Enumerable<LanguageLevel>
    not?: NestedEnumLanguageLevelWithAggregatesFilter | LanguageLevel
    _count?: NestedIntFilter
    _min?: NestedEnumLanguageLevelFilter
    _max?: NestedEnumLanguageLevelFilter
  }

  export type NestedEnumReqriutmentTypeNullableWithAggregatesFilter = {
    equals?: ReqriutmentType | null
    in?: Enumerable<ReqriutmentType> | null
    notIn?: Enumerable<ReqriutmentType> | null
    not?: NestedEnumReqriutmentTypeNullableWithAggregatesFilter | ReqriutmentType | null
    _count?: NestedIntNullableFilter
    _min?: NestedEnumReqriutmentTypeNullableFilter
    _max?: NestedEnumReqriutmentTypeNullableFilter
  }

  export type NestedEnumSalaryTypeWithAggregatesFilter = {
    equals?: SalaryType
    in?: Enumerable<SalaryType>
    notIn?: Enumerable<SalaryType>
    not?: NestedEnumSalaryTypeWithAggregatesFilter | SalaryType
    _count?: NestedIntFilter
    _min?: NestedEnumSalaryTypeFilter
    _max?: NestedEnumSalaryTypeFilter
  }

  export type NestedEnumUserStatusFilter = {
    equals?: UserStatus
    in?: Enumerable<UserStatus>
    notIn?: Enumerable<UserStatus>
    not?: NestedEnumUserStatusFilter | UserStatus
  }

  export type NestedEnumUserStatusWithAggregatesFilter = {
    equals?: UserStatus
    in?: Enumerable<UserStatus>
    notIn?: Enumerable<UserStatus>
    not?: NestedEnumUserStatusWithAggregatesFilter | UserStatus
    _count?: NestedIntFilter
    _min?: NestedEnumUserStatusFilter
    _max?: NestedEnumUserStatusFilter
  }
  export type NestedJsonFilter = 
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase>, Exclude<keyof Required<NestedJsonFilterBase>, 'path'>>,
        Required<NestedJsonFilterBase>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase>, 'path'>>

  export type NestedJsonFilterBase = {
    equals?: InputJsonValue | JsonNullValueFilter
    path?: Array<string>
    string_contains?: string
    string_starts_with?: string
    string_ends_with?: string
    array_contains?: InputJsonValue | null
    array_starts_with?: InputJsonValue | null
    array_ends_with?: InputJsonValue | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonNullValueFilter
  }

  export type UserCreateWithoutCustomerInput = {
    user_id?: string
    email: string
    mobile?: string | null
    name?: string | null
    password_hash: string
    role?: UserRole
    company_id?: number
    attemptpass_count?: number | null
    reset_code?: string
    is_emailverified?: boolean
    is_mobileverified?: boolean
    user_status?: UserStatus
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    favs: JsonNullValueInput | InputJsonValue
    loggers?: LoggerCreateNestedManyWithoutUserInput
    from_inquiries?: InquiryCreateNestedManyWithoutFromuserInput
    assign_inquiries?: InquiryCreateNestedManyWithoutAssignUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    ScoutFav?: ScoutFavCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCustomerInput = {
    user_id?: string
    email: string
    mobile?: string | null
    name?: string | null
    password_hash: string
    role?: UserRole
    company_id?: number
    attemptpass_count?: number | null
    reset_code?: string
    is_emailverified?: boolean
    is_mobileverified?: boolean
    user_status?: UserStatus
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    favs: JsonNullValueInput | InputJsonValue
    loggers?: LoggerUncheckedCreateNestedManyWithoutUserInput
    from_inquiries?: InquiryUncheckedCreateNestedManyWithoutFromuserInput
    assign_inquiries?: InquiryUncheckedCreateNestedManyWithoutAssignUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    ScoutFav?: ScoutFavUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCustomerInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCustomerInput, UserUncheckedCreateWithoutCustomerInput>
  }

  export type CustomerVisaCreateWithoutCustomerInput = {
    visa_id?: string
    status_visa?: StatusVisa | null
    date_expire?: Date | string | null
    country_citizenship?: string | null
    back_visafile?: string | null
    front_visafile?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: string | null
    updated_by?: string | null
  }

  export type CustomerVisaUncheckedCreateWithoutCustomerInput = {
    visa_id?: string
    status_visa?: StatusVisa | null
    date_expire?: Date | string | null
    country_citizenship?: string | null
    back_visafile?: string | null
    front_visafile?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: string | null
    updated_by?: string | null
  }

  export type CustomerVisaCreateOrConnectWithoutCustomerInput = {
    where: CustomerVisaWhereUniqueInput
    create: XOR<CustomerVisaCreateWithoutCustomerInput, CustomerVisaUncheckedCreateWithoutCustomerInput>
  }

  export type CustomerVisaCreateManyCustomerInputEnvelope = {
    data: Enumerable<CustomerVisaCreateManyCustomerInput>
    skipDuplicates?: boolean
  }

  export type CustomerJobDetailCreateWithoutCustomerInput = {
    jobdetail_id?: string
    customer_experiences?: CustomerExperienceCreateNestedManyWithoutJobdetailsInput
    experienced_company?: number
    annual_income?: number | null
    has_management_exp?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: string | null
    updated_by?: string | null
  }

  export type CustomerJobDetailUncheckedCreateWithoutCustomerInput = {
    jobdetail_id?: string
    customer_experiences?: CustomerExperienceUncheckedCreateNestedManyWithoutJobdetailsInput
    experienced_company?: number
    annual_income?: number | null
    has_management_exp?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: string | null
    updated_by?: string | null
  }

  export type CustomerJobDetailCreateOrConnectWithoutCustomerInput = {
    where: CustomerJobDetailWhereUniqueInput
    create: XOR<CustomerJobDetailCreateWithoutCustomerInput, CustomerJobDetailUncheckedCreateWithoutCustomerInput>
  }

  export type CustomerJobDetailCreateManyCustomerInputEnvelope = {
    data: Enumerable<CustomerJobDetailCreateManyCustomerInput>
    skipDuplicates?: boolean
  }

  export type CustomerEducationCreateWithoutCustomerInput = {
    education_id?: string
    country?: string | null
    degree?: NullableJsonNullValueInput | InputJsonValue
    entrollment_date?: Date | string | null
    graduate_date?: Date | string | null
    is_current?: boolean | null
    school_id?: number | null
    school?: NullableJsonNullValueInput | InputJsonValue
    faculty?: string | null
    department?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: string | null
    updated_by?: string | null
  }

  export type CustomerEducationUncheckedCreateWithoutCustomerInput = {
    education_id?: string
    country?: string | null
    degree?: NullableJsonNullValueInput | InputJsonValue
    entrollment_date?: Date | string | null
    graduate_date?: Date | string | null
    is_current?: boolean | null
    school_id?: number | null
    school?: NullableJsonNullValueInput | InputJsonValue
    faculty?: string | null
    department?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: string | null
    updated_by?: string | null
  }

  export type CustomerEducationCreateOrConnectWithoutCustomerInput = {
    where: CustomerEducationWhereUniqueInput
    create: XOR<CustomerEducationCreateWithoutCustomerInput, CustomerEducationUncheckedCreateWithoutCustomerInput>
  }

  export type CustomerEducationCreateManyCustomerInputEnvelope = {
    data: Enumerable<CustomerEducationCreateManyCustomerInput>
    skipDuplicates?: boolean
  }

  export type CustomerLanguageCreateWithoutCustomerInput = {
    language_id?: string
    level?: LanguageLevel | null
    language?: number | null
    is_motherlanguage?: boolean
    certificate?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string | null
    created_by?: string | null
    updated_b?: string | null
  }

  export type CustomerLanguageUncheckedCreateWithoutCustomerInput = {
    language_id?: string
    level?: LanguageLevel | null
    language?: number | null
    is_motherlanguage?: boolean
    certificate?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string | null
    created_by?: string | null
    updated_b?: string | null
  }

  export type CustomerLanguageCreateOrConnectWithoutCustomerInput = {
    where: CustomerLanguageWhereUniqueInput
    create: XOR<CustomerLanguageCreateWithoutCustomerInput, CustomerLanguageUncheckedCreateWithoutCustomerInput>
  }

  export type CustomerLanguageCreateManyCustomerInputEnvelope = {
    data: Enumerable<CustomerLanguageCreateManyCustomerInput>
    skipDuplicates?: boolean
  }

  export type CustomerQualificationCreateWithoutCustomersInput = {
    qualification_id?: string
    qualification?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: string | null
    updated_by?: string | null
  }

  export type CustomerQualificationUncheckedCreateWithoutCustomersInput = {
    qualification_id?: string
    qualification?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: string | null
    updated_by?: string | null
  }

  export type CustomerQualificationCreateOrConnectWithoutCustomersInput = {
    where: CustomerQualificationWhereUniqueInput
    create: XOR<CustomerQualificationCreateWithoutCustomersInput, CustomerQualificationUncheckedCreateWithoutCustomersInput>
  }

  export type CustomerQualificationCreateManyCustomersInputEnvelope = {
    data: Enumerable<CustomerQualificationCreateManyCustomersInput>
    skipDuplicates?: boolean
  }

  export type CustomerWorkHistoryCreateWithoutCustomerInput = {
    workhistory_id?: string
    company_id?: string | null
    company_info?: NullableJsonNullValueInput | InputJsonValue
    occupation?: NullableJsonNullValueInput | InputJsonValue
    industry?: NullableJsonNullValueInput | InputJsonValue
    position?: JobPosition | null
    enter_date?: Date | string | null
    leave_date?: Date | string | null
    working_month?: number | null
    is_current?: boolean | null
    duties?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: string | null
    updated_by?: string | null
  }

  export type CustomerWorkHistoryUncheckedCreateWithoutCustomerInput = {
    workhistory_id?: string
    company_id?: string | null
    company_info?: NullableJsonNullValueInput | InputJsonValue
    occupation?: NullableJsonNullValueInput | InputJsonValue
    industry?: NullableJsonNullValueInput | InputJsonValue
    position?: JobPosition | null
    enter_date?: Date | string | null
    leave_date?: Date | string | null
    working_month?: number | null
    is_current?: boolean | null
    duties?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: string | null
    updated_by?: string | null
  }

  export type CustomerWorkHistoryCreateOrConnectWithoutCustomerInput = {
    where: CustomerWorkHistoryWhereUniqueInput
    create: XOR<CustomerWorkHistoryCreateWithoutCustomerInput, CustomerWorkHistoryUncheckedCreateWithoutCustomerInput>
  }

  export type CustomerWorkHistoryCreateManyCustomerInputEnvelope = {
    data: Enumerable<CustomerWorkHistoryCreateManyCustomerInput>
    skipDuplicates?: boolean
  }

  export type JobCandidateCreateWithoutCustomerInput = {
    job_candidate_id?: string
    job: JobCreateNestedOneWithoutJob_candidatesInput
    candidate_status: number
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: string | null
    updated_by?: string | null
  }

  export type JobCandidateUncheckedCreateWithoutCustomerInput = {
    job_candidate_id?: string
    job_id: string
    candidate_status: number
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: string | null
    updated_by?: string | null
  }

  export type JobCandidateCreateOrConnectWithoutCustomerInput = {
    where: JobCandidateWhereUniqueInput
    create: XOR<JobCandidateCreateWithoutCustomerInput, JobCandidateUncheckedCreateWithoutCustomerInput>
  }

  export type JobCandidateCreateManyCustomerInputEnvelope = {
    data: Enumerable<JobCandidateCreateManyCustomerInput>
    skipDuplicates?: boolean
  }

  export type CustomerDesiredCreateWithoutCustomerInput = {
    desired_id?: string
    occupation?: CustomerDesiredCreateoccupationInput | Enumerable<InputJsonValue>
    industry?: CustomerDesiredCreateindustryInput | Enumerable<InputJsonValue>
    location?: CustomerDesiredCreatelocationInput | Enumerable<InputJsonValue>
    career_level?: CustomerDesiredCreatecareer_levelInput | Enumerable<InputJsonValue>
    contract_type?: CustomerDesiredCreatecontract_typeInput | Enumerable<InputJsonValue>
    desired_company?: CustomerDesiredCreatedesired_companyInput | Enumerable<InputJsonValue>
    time_to: string
    annual_income: number
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: string | null
    updated_by?: string | null
  }

  export type CustomerDesiredUncheckedCreateWithoutCustomerInput = {
    desired_id?: string
    occupation?: CustomerDesiredCreateoccupationInput | Enumerable<InputJsonValue>
    industry?: CustomerDesiredCreateindustryInput | Enumerable<InputJsonValue>
    location?: CustomerDesiredCreatelocationInput | Enumerable<InputJsonValue>
    career_level?: CustomerDesiredCreatecareer_levelInput | Enumerable<InputJsonValue>
    contract_type?: CustomerDesiredCreatecontract_typeInput | Enumerable<InputJsonValue>
    desired_company?: CustomerDesiredCreatedesired_companyInput | Enumerable<InputJsonValue>
    time_to: string
    annual_income: number
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: string | null
    updated_by?: string | null
  }

  export type CustomerDesiredCreateOrConnectWithoutCustomerInput = {
    where: CustomerDesiredWhereUniqueInput
    create: XOR<CustomerDesiredCreateWithoutCustomerInput, CustomerDesiredUncheckedCreateWithoutCustomerInput>
  }

  export type CustomerDesiredCreateManyCustomerInputEnvelope = {
    data: Enumerable<CustomerDesiredCreateManyCustomerInput>
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutCustomerInput = {
    update: XOR<UserUpdateWithoutCustomerInput, UserUncheckedUpdateWithoutCustomerInput>
    create: XOR<UserCreateWithoutCustomerInput, UserUncheckedCreateWithoutCustomerInput>
  }

  export type UserUpdateWithoutCustomerInput = {
    user_id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | UserRole
    company_id?: IntFieldUpdateOperationsInput | number
    attemptpass_count?: NullableIntFieldUpdateOperationsInput | number | null
    reset_code?: StringFieldUpdateOperationsInput | string
    is_emailverified?: BoolFieldUpdateOperationsInput | boolean
    is_mobileverified?: BoolFieldUpdateOperationsInput | boolean
    user_status?: EnumUserStatusFieldUpdateOperationsInput | UserStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    favs?: JsonNullValueInput | InputJsonValue
    loggers?: LoggerUpdateManyWithoutUserNestedInput
    from_inquiries?: InquiryUpdateManyWithoutFromuserNestedInput
    assign_inquiries?: InquiryUpdateManyWithoutAssignUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    ScoutFav?: ScoutFavUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCustomerInput = {
    user_id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | UserRole
    company_id?: IntFieldUpdateOperationsInput | number
    attemptpass_count?: NullableIntFieldUpdateOperationsInput | number | null
    reset_code?: StringFieldUpdateOperationsInput | string
    is_emailverified?: BoolFieldUpdateOperationsInput | boolean
    is_mobileverified?: BoolFieldUpdateOperationsInput | boolean
    user_status?: EnumUserStatusFieldUpdateOperationsInput | UserStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    favs?: JsonNullValueInput | InputJsonValue
    loggers?: LoggerUncheckedUpdateManyWithoutUserNestedInput
    from_inquiries?: InquiryUncheckedUpdateManyWithoutFromuserNestedInput
    assign_inquiries?: InquiryUncheckedUpdateManyWithoutAssignUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    ScoutFav?: ScoutFavUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CustomerVisaUpsertWithWhereUniqueWithoutCustomerInput = {
    where: CustomerVisaWhereUniqueInput
    update: XOR<CustomerVisaUpdateWithoutCustomerInput, CustomerVisaUncheckedUpdateWithoutCustomerInput>
    create: XOR<CustomerVisaCreateWithoutCustomerInput, CustomerVisaUncheckedCreateWithoutCustomerInput>
  }

  export type CustomerVisaUpdateWithWhereUniqueWithoutCustomerInput = {
    where: CustomerVisaWhereUniqueInput
    data: XOR<CustomerVisaUpdateWithoutCustomerInput, CustomerVisaUncheckedUpdateWithoutCustomerInput>
  }

  export type CustomerVisaUpdateManyWithWhereWithoutCustomerInput = {
    where: CustomerVisaScalarWhereInput
    data: XOR<CustomerVisaUpdateManyMutationInput, CustomerVisaUncheckedUpdateManyWithoutCustomer_visasInput>
  }

  export type CustomerVisaScalarWhereInput = {
    AND?: Enumerable<CustomerVisaScalarWhereInput>
    OR?: Enumerable<CustomerVisaScalarWhereInput>
    NOT?: Enumerable<CustomerVisaScalarWhereInput>
    visa_id?: StringFilter | string
    customer_id?: StringFilter | string
    status_visa?: EnumStatusVisaNullableFilter | StatusVisa | null
    date_expire?: DateTimeNullableFilter | Date | string | null
    country_citizenship?: StringNullableFilter | string | null
    back_visafile?: StringNullableFilter | string | null
    front_visafile?: StringNullableFilter | string | null
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    created_by?: StringNullableFilter | string | null
    updated_by?: StringNullableFilter | string | null
  }

  export type CustomerJobDetailUpsertWithWhereUniqueWithoutCustomerInput = {
    where: CustomerJobDetailWhereUniqueInput
    update: XOR<CustomerJobDetailUpdateWithoutCustomerInput, CustomerJobDetailUncheckedUpdateWithoutCustomerInput>
    create: XOR<CustomerJobDetailCreateWithoutCustomerInput, CustomerJobDetailUncheckedCreateWithoutCustomerInput>
  }

  export type CustomerJobDetailUpdateWithWhereUniqueWithoutCustomerInput = {
    where: CustomerJobDetailWhereUniqueInput
    data: XOR<CustomerJobDetailUpdateWithoutCustomerInput, CustomerJobDetailUncheckedUpdateWithoutCustomerInput>
  }

  export type CustomerJobDetailUpdateManyWithWhereWithoutCustomerInput = {
    where: CustomerJobDetailScalarWhereInput
    data: XOR<CustomerJobDetailUpdateManyMutationInput, CustomerJobDetailUncheckedUpdateManyWithoutCustomer_jobdetailsInput>
  }

  export type CustomerJobDetailScalarWhereInput = {
    AND?: Enumerable<CustomerJobDetailScalarWhereInput>
    OR?: Enumerable<CustomerJobDetailScalarWhereInput>
    NOT?: Enumerable<CustomerJobDetailScalarWhereInput>
    jobdetail_id?: StringFilter | string
    customer_id?: StringNullableFilter | string | null
    experienced_company?: IntFilter | number
    annual_income?: IntNullableFilter | number | null
    has_management_exp?: BoolFilter | boolean
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    created_by?: StringNullableFilter | string | null
    updated_by?: StringNullableFilter | string | null
  }

  export type CustomerEducationUpsertWithWhereUniqueWithoutCustomerInput = {
    where: CustomerEducationWhereUniqueInput
    update: XOR<CustomerEducationUpdateWithoutCustomerInput, CustomerEducationUncheckedUpdateWithoutCustomerInput>
    create: XOR<CustomerEducationCreateWithoutCustomerInput, CustomerEducationUncheckedCreateWithoutCustomerInput>
  }

  export type CustomerEducationUpdateWithWhereUniqueWithoutCustomerInput = {
    where: CustomerEducationWhereUniqueInput
    data: XOR<CustomerEducationUpdateWithoutCustomerInput, CustomerEducationUncheckedUpdateWithoutCustomerInput>
  }

  export type CustomerEducationUpdateManyWithWhereWithoutCustomerInput = {
    where: CustomerEducationScalarWhereInput
    data: XOR<CustomerEducationUpdateManyMutationInput, CustomerEducationUncheckedUpdateManyWithoutCustomer_educationsInput>
  }

  export type CustomerEducationScalarWhereInput = {
    AND?: Enumerable<CustomerEducationScalarWhereInput>
    OR?: Enumerable<CustomerEducationScalarWhereInput>
    NOT?: Enumerable<CustomerEducationScalarWhereInput>
    education_id?: StringFilter | string
    customer_id?: StringNullableFilter | string | null
    country?: StringNullableFilter | string | null
    degree?: JsonNullableFilter
    entrollment_date?: DateTimeNullableFilter | Date | string | null
    graduate_date?: DateTimeNullableFilter | Date | string | null
    is_current?: BoolNullableFilter | boolean | null
    school_id?: IntNullableFilter | number | null
    school?: JsonNullableFilter
    faculty?: StringNullableFilter | string | null
    department?: StringNullableFilter | string | null
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    created_by?: StringNullableFilter | string | null
    updated_by?: StringNullableFilter | string | null
  }

  export type CustomerLanguageUpsertWithWhereUniqueWithoutCustomerInput = {
    where: CustomerLanguageWhereUniqueInput
    update: XOR<CustomerLanguageUpdateWithoutCustomerInput, CustomerLanguageUncheckedUpdateWithoutCustomerInput>
    create: XOR<CustomerLanguageCreateWithoutCustomerInput, CustomerLanguageUncheckedCreateWithoutCustomerInput>
  }

  export type CustomerLanguageUpdateWithWhereUniqueWithoutCustomerInput = {
    where: CustomerLanguageWhereUniqueInput
    data: XOR<CustomerLanguageUpdateWithoutCustomerInput, CustomerLanguageUncheckedUpdateWithoutCustomerInput>
  }

  export type CustomerLanguageUpdateManyWithWhereWithoutCustomerInput = {
    where: CustomerLanguageScalarWhereInput
    data: XOR<CustomerLanguageUpdateManyMutationInput, CustomerLanguageUncheckedUpdateManyWithoutCustomer_languagesInput>
  }

  export type CustomerLanguageScalarWhereInput = {
    AND?: Enumerable<CustomerLanguageScalarWhereInput>
    OR?: Enumerable<CustomerLanguageScalarWhereInput>
    NOT?: Enumerable<CustomerLanguageScalarWhereInput>
    language_id?: StringFilter | string
    customer_id?: StringFilter | string
    level?: EnumLanguageLevelNullableFilter | LanguageLevel | null
    language?: IntNullableFilter | number | null
    is_motherlanguage?: BoolFilter | boolean
    certificate?: JsonNullableFilter
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeNullableFilter | Date | string | null
    created_by?: StringNullableFilter | string | null
    updated_b?: StringNullableFilter | string | null
  }

  export type CustomerQualificationUpsertWithWhereUniqueWithoutCustomersInput = {
    where: CustomerQualificationWhereUniqueInput
    update: XOR<CustomerQualificationUpdateWithoutCustomersInput, CustomerQualificationUncheckedUpdateWithoutCustomersInput>
    create: XOR<CustomerQualificationCreateWithoutCustomersInput, CustomerQualificationUncheckedCreateWithoutCustomersInput>
  }

  export type CustomerQualificationUpdateWithWhereUniqueWithoutCustomersInput = {
    where: CustomerQualificationWhereUniqueInput
    data: XOR<CustomerQualificationUpdateWithoutCustomersInput, CustomerQualificationUncheckedUpdateWithoutCustomersInput>
  }

  export type CustomerQualificationUpdateManyWithWhereWithoutCustomersInput = {
    where: CustomerQualificationScalarWhereInput
    data: XOR<CustomerQualificationUpdateManyMutationInput, CustomerQualificationUncheckedUpdateManyWithoutCustomer_qualificationsInput>
  }

  export type CustomerQualificationScalarWhereInput = {
    AND?: Enumerable<CustomerQualificationScalarWhereInput>
    OR?: Enumerable<CustomerQualificationScalarWhereInput>
    NOT?: Enumerable<CustomerQualificationScalarWhereInput>
    qualification_id?: StringFilter | string
    customer_id?: StringFilter | string
    qualification?: JsonNullableFilter
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    created_by?: StringNullableFilter | string | null
    updated_by?: StringNullableFilter | string | null
  }

  export type CustomerWorkHistoryUpsertWithWhereUniqueWithoutCustomerInput = {
    where: CustomerWorkHistoryWhereUniqueInput
    update: XOR<CustomerWorkHistoryUpdateWithoutCustomerInput, CustomerWorkHistoryUncheckedUpdateWithoutCustomerInput>
    create: XOR<CustomerWorkHistoryCreateWithoutCustomerInput, CustomerWorkHistoryUncheckedCreateWithoutCustomerInput>
  }

  export type CustomerWorkHistoryUpdateWithWhereUniqueWithoutCustomerInput = {
    where: CustomerWorkHistoryWhereUniqueInput
    data: XOR<CustomerWorkHistoryUpdateWithoutCustomerInput, CustomerWorkHistoryUncheckedUpdateWithoutCustomerInput>
  }

  export type CustomerWorkHistoryUpdateManyWithWhereWithoutCustomerInput = {
    where: CustomerWorkHistoryScalarWhereInput
    data: XOR<CustomerWorkHistoryUpdateManyMutationInput, CustomerWorkHistoryUncheckedUpdateManyWithoutCustomer_workhistoriesInput>
  }

  export type CustomerWorkHistoryScalarWhereInput = {
    AND?: Enumerable<CustomerWorkHistoryScalarWhereInput>
    OR?: Enumerable<CustomerWorkHistoryScalarWhereInput>
    NOT?: Enumerable<CustomerWorkHistoryScalarWhereInput>
    workhistory_id?: StringFilter | string
    customer_id?: StringFilter | string
    company_id?: StringNullableFilter | string | null
    company_info?: JsonNullableFilter
    occupation?: JsonNullableFilter
    industry?: JsonNullableFilter
    position?: EnumJobPositionNullableFilter | JobPosition | null
    enter_date?: DateTimeNullableFilter | Date | string | null
    leave_date?: DateTimeNullableFilter | Date | string | null
    working_month?: IntNullableFilter | number | null
    is_current?: BoolNullableFilter | boolean | null
    duties?: StringNullableFilter | string | null
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    created_by?: StringNullableFilter | string | null
    updated_by?: StringNullableFilter | string | null
  }

  export type JobCandidateUpsertWithWhereUniqueWithoutCustomerInput = {
    where: JobCandidateWhereUniqueInput
    update: XOR<JobCandidateUpdateWithoutCustomerInput, JobCandidateUncheckedUpdateWithoutCustomerInput>
    create: XOR<JobCandidateCreateWithoutCustomerInput, JobCandidateUncheckedCreateWithoutCustomerInput>
  }

  export type JobCandidateUpdateWithWhereUniqueWithoutCustomerInput = {
    where: JobCandidateWhereUniqueInput
    data: XOR<JobCandidateUpdateWithoutCustomerInput, JobCandidateUncheckedUpdateWithoutCustomerInput>
  }

  export type JobCandidateUpdateManyWithWhereWithoutCustomerInput = {
    where: JobCandidateScalarWhereInput
    data: XOR<JobCandidateUpdateManyMutationInput, JobCandidateUncheckedUpdateManyWithoutJob_candidatesInput>
  }

  export type JobCandidateScalarWhereInput = {
    AND?: Enumerable<JobCandidateScalarWhereInput>
    OR?: Enumerable<JobCandidateScalarWhereInput>
    NOT?: Enumerable<JobCandidateScalarWhereInput>
    job_candidate_id?: StringFilter | string
    job_id?: StringFilter | string
    customer_id?: StringFilter | string
    candidate_status?: IntFilter | number
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    created_by?: StringNullableFilter | string | null
    updated_by?: StringNullableFilter | string | null
  }

  export type CustomerDesiredUpsertWithWhereUniqueWithoutCustomerInput = {
    where: CustomerDesiredWhereUniqueInput
    update: XOR<CustomerDesiredUpdateWithoutCustomerInput, CustomerDesiredUncheckedUpdateWithoutCustomerInput>
    create: XOR<CustomerDesiredCreateWithoutCustomerInput, CustomerDesiredUncheckedCreateWithoutCustomerInput>
  }

  export type CustomerDesiredUpdateWithWhereUniqueWithoutCustomerInput = {
    where: CustomerDesiredWhereUniqueInput
    data: XOR<CustomerDesiredUpdateWithoutCustomerInput, CustomerDesiredUncheckedUpdateWithoutCustomerInput>
  }

  export type CustomerDesiredUpdateManyWithWhereWithoutCustomerInput = {
    where: CustomerDesiredScalarWhereInput
    data: XOR<CustomerDesiredUpdateManyMutationInput, CustomerDesiredUncheckedUpdateManyWithoutCustomer_desiredInput>
  }

  export type CustomerDesiredScalarWhereInput = {
    AND?: Enumerable<CustomerDesiredScalarWhereInput>
    OR?: Enumerable<CustomerDesiredScalarWhereInput>
    NOT?: Enumerable<CustomerDesiredScalarWhereInput>
    desired_id?: StringFilter | string
    customer_id?: StringNullableFilter | string | null
    occupation?: JsonNullableListFilter
    industry?: JsonNullableListFilter
    location?: JsonNullableListFilter
    career_level?: JsonNullableListFilter
    contract_type?: JsonNullableListFilter
    desired_company?: JsonNullableListFilter
    time_to?: StringFilter | string
    annual_income?: IntFilter | number
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    created_by?: StringNullableFilter | string | null
    updated_by?: StringNullableFilter | string | null
  }

  export type CustomerCreateWithoutCustomer_desiredInput = {
    customer_id?: string
    first_name: string
    last_name: string
    first_name_kana: string
    last_name_kana: string
    gender?: Gender | null
    birth_date?: Date | string | null
    spouse?: NullableJsonNullValueInput | InputJsonValue
    family_size?: number | null
    email?: string | null
    mobile?: string | null
    phone?: string | null
    profile_image?: string | null
    cv_file?: string | null
    resume_file?: string | null
    prefecture?: NullableJsonNullValueInput | InputJsonValue
    post_code?: string | null
    city?: string | null
    district?: string | null
    address?: string | null
    address1?: string | null
    nearest_station?: string | null
    socials?: NullableJsonNullValueInput | InputJsonValue
    country?: string | null
    experienced_year?: number | null
    from_data?: number | null
    status_customer?: CustomerStatus | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: string | null
    updated_by?: string | null
    user?: UserCreateNestedOneWithoutCustomerInput
    customer_visas?: CustomerVisaCreateNestedManyWithoutCustomerInput
    customer_jobdetails?: CustomerJobDetailCreateNestedManyWithoutCustomerInput
    customer_educations?: CustomerEducationCreateNestedManyWithoutCustomerInput
    customer_languages?: CustomerLanguageCreateNestedManyWithoutCustomerInput
    customer_qualifications?: CustomerQualificationCreateNestedManyWithoutCustomersInput
    customer_workhistories?: CustomerWorkHistoryCreateNestedManyWithoutCustomerInput
    job_candidates?: JobCandidateCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutCustomer_desiredInput = {
    customer_id?: string
    first_name: string
    last_name: string
    first_name_kana: string
    last_name_kana: string
    gender?: Gender | null
    birth_date?: Date | string | null
    spouse?: NullableJsonNullValueInput | InputJsonValue
    family_size?: number | null
    email?: string | null
    mobile?: string | null
    phone?: string | null
    profile_image?: string | null
    cv_file?: string | null
    resume_file?: string | null
    prefecture?: NullableJsonNullValueInput | InputJsonValue
    post_code?: string | null
    city?: string | null
    district?: string | null
    address?: string | null
    address1?: string | null
    nearest_station?: string | null
    socials?: NullableJsonNullValueInput | InputJsonValue
    country?: string | null
    experienced_year?: number | null
    from_data?: number | null
    status_customer?: CustomerStatus | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: string | null
    updated_by?: string | null
    user?: UserUncheckedCreateNestedOneWithoutCustomerInput
    customer_visas?: CustomerVisaUncheckedCreateNestedManyWithoutCustomerInput
    customer_jobdetails?: CustomerJobDetailUncheckedCreateNestedManyWithoutCustomerInput
    customer_educations?: CustomerEducationUncheckedCreateNestedManyWithoutCustomerInput
    customer_languages?: CustomerLanguageUncheckedCreateNestedManyWithoutCustomerInput
    customer_qualifications?: CustomerQualificationUncheckedCreateNestedManyWithoutCustomersInput
    customer_workhistories?: CustomerWorkHistoryUncheckedCreateNestedManyWithoutCustomerInput
    job_candidates?: JobCandidateUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutCustomer_desiredInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutCustomer_desiredInput, CustomerUncheckedCreateWithoutCustomer_desiredInput>
  }

  export type CustomerUpsertWithoutCustomer_desiredInput = {
    update: XOR<CustomerUpdateWithoutCustomer_desiredInput, CustomerUncheckedUpdateWithoutCustomer_desiredInput>
    create: XOR<CustomerCreateWithoutCustomer_desiredInput, CustomerUncheckedCreateWithoutCustomer_desiredInput>
  }

  export type CustomerUpdateWithoutCustomer_desiredInput = {
    customer_id?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    first_name_kana?: StringFieldUpdateOperationsInput | string
    last_name_kana?: StringFieldUpdateOperationsInput | string
    gender?: NullableEnumGenderFieldUpdateOperationsInput | Gender | null
    birth_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    spouse?: NullableJsonNullValueInput | InputJsonValue
    family_size?: NullableIntFieldUpdateOperationsInput | number | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profile_image?: NullableStringFieldUpdateOperationsInput | string | null
    cv_file?: NullableStringFieldUpdateOperationsInput | string | null
    resume_file?: NullableStringFieldUpdateOperationsInput | string | null
    prefecture?: NullableJsonNullValueInput | InputJsonValue
    post_code?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    address1?: NullableStringFieldUpdateOperationsInput | string | null
    nearest_station?: NullableStringFieldUpdateOperationsInput | string | null
    socials?: NullableJsonNullValueInput | InputJsonValue
    country?: NullableStringFieldUpdateOperationsInput | string | null
    experienced_year?: NullableIntFieldUpdateOperationsInput | number | null
    from_data?: NullableIntFieldUpdateOperationsInput | number | null
    status_customer?: NullableEnumCustomerStatusFieldUpdateOperationsInput | CustomerStatus | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneWithoutCustomerNestedInput
    customer_visas?: CustomerVisaUpdateManyWithoutCustomerNestedInput
    customer_jobdetails?: CustomerJobDetailUpdateManyWithoutCustomerNestedInput
    customer_educations?: CustomerEducationUpdateManyWithoutCustomerNestedInput
    customer_languages?: CustomerLanguageUpdateManyWithoutCustomerNestedInput
    customer_qualifications?: CustomerQualificationUpdateManyWithoutCustomersNestedInput
    customer_workhistories?: CustomerWorkHistoryUpdateManyWithoutCustomerNestedInput
    job_candidates?: JobCandidateUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutCustomer_desiredInput = {
    customer_id?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    first_name_kana?: StringFieldUpdateOperationsInput | string
    last_name_kana?: StringFieldUpdateOperationsInput | string
    gender?: NullableEnumGenderFieldUpdateOperationsInput | Gender | null
    birth_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    spouse?: NullableJsonNullValueInput | InputJsonValue
    family_size?: NullableIntFieldUpdateOperationsInput | number | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profile_image?: NullableStringFieldUpdateOperationsInput | string | null
    cv_file?: NullableStringFieldUpdateOperationsInput | string | null
    resume_file?: NullableStringFieldUpdateOperationsInput | string | null
    prefecture?: NullableJsonNullValueInput | InputJsonValue
    post_code?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    address1?: NullableStringFieldUpdateOperationsInput | string | null
    nearest_station?: NullableStringFieldUpdateOperationsInput | string | null
    socials?: NullableJsonNullValueInput | InputJsonValue
    country?: NullableStringFieldUpdateOperationsInput | string | null
    experienced_year?: NullableIntFieldUpdateOperationsInput | number | null
    from_data?: NullableIntFieldUpdateOperationsInput | number | null
    status_customer?: NullableEnumCustomerStatusFieldUpdateOperationsInput | CustomerStatus | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUncheckedUpdateOneWithoutCustomerNestedInput
    customer_visas?: CustomerVisaUncheckedUpdateManyWithoutCustomerNestedInput
    customer_jobdetails?: CustomerJobDetailUncheckedUpdateManyWithoutCustomerNestedInput
    customer_educations?: CustomerEducationUncheckedUpdateManyWithoutCustomerNestedInput
    customer_languages?: CustomerLanguageUncheckedUpdateManyWithoutCustomerNestedInput
    customer_qualifications?: CustomerQualificationUncheckedUpdateManyWithoutCustomersNestedInput
    customer_workhistories?: CustomerWorkHistoryUncheckedUpdateManyWithoutCustomerNestedInput
    job_candidates?: JobCandidateUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerCreateWithoutCustomer_educationsInput = {
    customer_id?: string
    first_name: string
    last_name: string
    first_name_kana: string
    last_name_kana: string
    gender?: Gender | null
    birth_date?: Date | string | null
    spouse?: NullableJsonNullValueInput | InputJsonValue
    family_size?: number | null
    email?: string | null
    mobile?: string | null
    phone?: string | null
    profile_image?: string | null
    cv_file?: string | null
    resume_file?: string | null
    prefecture?: NullableJsonNullValueInput | InputJsonValue
    post_code?: string | null
    city?: string | null
    district?: string | null
    address?: string | null
    address1?: string | null
    nearest_station?: string | null
    socials?: NullableJsonNullValueInput | InputJsonValue
    country?: string | null
    experienced_year?: number | null
    from_data?: number | null
    status_customer?: CustomerStatus | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: string | null
    updated_by?: string | null
    user?: UserCreateNestedOneWithoutCustomerInput
    customer_visas?: CustomerVisaCreateNestedManyWithoutCustomerInput
    customer_jobdetails?: CustomerJobDetailCreateNestedManyWithoutCustomerInput
    customer_languages?: CustomerLanguageCreateNestedManyWithoutCustomerInput
    customer_qualifications?: CustomerQualificationCreateNestedManyWithoutCustomersInput
    customer_workhistories?: CustomerWorkHistoryCreateNestedManyWithoutCustomerInput
    job_candidates?: JobCandidateCreateNestedManyWithoutCustomerInput
    customer_desired?: CustomerDesiredCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutCustomer_educationsInput = {
    customer_id?: string
    first_name: string
    last_name: string
    first_name_kana: string
    last_name_kana: string
    gender?: Gender | null
    birth_date?: Date | string | null
    spouse?: NullableJsonNullValueInput | InputJsonValue
    family_size?: number | null
    email?: string | null
    mobile?: string | null
    phone?: string | null
    profile_image?: string | null
    cv_file?: string | null
    resume_file?: string | null
    prefecture?: NullableJsonNullValueInput | InputJsonValue
    post_code?: string | null
    city?: string | null
    district?: string | null
    address?: string | null
    address1?: string | null
    nearest_station?: string | null
    socials?: NullableJsonNullValueInput | InputJsonValue
    country?: string | null
    experienced_year?: number | null
    from_data?: number | null
    status_customer?: CustomerStatus | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: string | null
    updated_by?: string | null
    user?: UserUncheckedCreateNestedOneWithoutCustomerInput
    customer_visas?: CustomerVisaUncheckedCreateNestedManyWithoutCustomerInput
    customer_jobdetails?: CustomerJobDetailUncheckedCreateNestedManyWithoutCustomerInput
    customer_languages?: CustomerLanguageUncheckedCreateNestedManyWithoutCustomerInput
    customer_qualifications?: CustomerQualificationUncheckedCreateNestedManyWithoutCustomersInput
    customer_workhistories?: CustomerWorkHistoryUncheckedCreateNestedManyWithoutCustomerInput
    job_candidates?: JobCandidateUncheckedCreateNestedManyWithoutCustomerInput
    customer_desired?: CustomerDesiredUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutCustomer_educationsInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutCustomer_educationsInput, CustomerUncheckedCreateWithoutCustomer_educationsInput>
  }

  export type CustomerUpsertWithoutCustomer_educationsInput = {
    update: XOR<CustomerUpdateWithoutCustomer_educationsInput, CustomerUncheckedUpdateWithoutCustomer_educationsInput>
    create: XOR<CustomerCreateWithoutCustomer_educationsInput, CustomerUncheckedCreateWithoutCustomer_educationsInput>
  }

  export type CustomerUpdateWithoutCustomer_educationsInput = {
    customer_id?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    first_name_kana?: StringFieldUpdateOperationsInput | string
    last_name_kana?: StringFieldUpdateOperationsInput | string
    gender?: NullableEnumGenderFieldUpdateOperationsInput | Gender | null
    birth_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    spouse?: NullableJsonNullValueInput | InputJsonValue
    family_size?: NullableIntFieldUpdateOperationsInput | number | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profile_image?: NullableStringFieldUpdateOperationsInput | string | null
    cv_file?: NullableStringFieldUpdateOperationsInput | string | null
    resume_file?: NullableStringFieldUpdateOperationsInput | string | null
    prefecture?: NullableJsonNullValueInput | InputJsonValue
    post_code?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    address1?: NullableStringFieldUpdateOperationsInput | string | null
    nearest_station?: NullableStringFieldUpdateOperationsInput | string | null
    socials?: NullableJsonNullValueInput | InputJsonValue
    country?: NullableStringFieldUpdateOperationsInput | string | null
    experienced_year?: NullableIntFieldUpdateOperationsInput | number | null
    from_data?: NullableIntFieldUpdateOperationsInput | number | null
    status_customer?: NullableEnumCustomerStatusFieldUpdateOperationsInput | CustomerStatus | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneWithoutCustomerNestedInput
    customer_visas?: CustomerVisaUpdateManyWithoutCustomerNestedInput
    customer_jobdetails?: CustomerJobDetailUpdateManyWithoutCustomerNestedInput
    customer_languages?: CustomerLanguageUpdateManyWithoutCustomerNestedInput
    customer_qualifications?: CustomerQualificationUpdateManyWithoutCustomersNestedInput
    customer_workhistories?: CustomerWorkHistoryUpdateManyWithoutCustomerNestedInput
    job_candidates?: JobCandidateUpdateManyWithoutCustomerNestedInput
    customer_desired?: CustomerDesiredUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutCustomer_educationsInput = {
    customer_id?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    first_name_kana?: StringFieldUpdateOperationsInput | string
    last_name_kana?: StringFieldUpdateOperationsInput | string
    gender?: NullableEnumGenderFieldUpdateOperationsInput | Gender | null
    birth_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    spouse?: NullableJsonNullValueInput | InputJsonValue
    family_size?: NullableIntFieldUpdateOperationsInput | number | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profile_image?: NullableStringFieldUpdateOperationsInput | string | null
    cv_file?: NullableStringFieldUpdateOperationsInput | string | null
    resume_file?: NullableStringFieldUpdateOperationsInput | string | null
    prefecture?: NullableJsonNullValueInput | InputJsonValue
    post_code?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    address1?: NullableStringFieldUpdateOperationsInput | string | null
    nearest_station?: NullableStringFieldUpdateOperationsInput | string | null
    socials?: NullableJsonNullValueInput | InputJsonValue
    country?: NullableStringFieldUpdateOperationsInput | string | null
    experienced_year?: NullableIntFieldUpdateOperationsInput | number | null
    from_data?: NullableIntFieldUpdateOperationsInput | number | null
    status_customer?: NullableEnumCustomerStatusFieldUpdateOperationsInput | CustomerStatus | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUncheckedUpdateOneWithoutCustomerNestedInput
    customer_visas?: CustomerVisaUncheckedUpdateManyWithoutCustomerNestedInput
    customer_jobdetails?: CustomerJobDetailUncheckedUpdateManyWithoutCustomerNestedInput
    customer_languages?: CustomerLanguageUncheckedUpdateManyWithoutCustomerNestedInput
    customer_qualifications?: CustomerQualificationUncheckedUpdateManyWithoutCustomersNestedInput
    customer_workhistories?: CustomerWorkHistoryUncheckedUpdateManyWithoutCustomerNestedInput
    job_candidates?: JobCandidateUncheckedUpdateManyWithoutCustomerNestedInput
    customer_desired?: CustomerDesiredUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerJobDetailCreateWithoutCustomer_experiencesInput = {
    jobdetail_id?: string
    customer?: CustomerCreateNestedOneWithoutCustomer_jobdetailsInput
    experienced_company?: number
    annual_income?: number | null
    has_management_exp?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: string | null
    updated_by?: string | null
  }

  export type CustomerJobDetailUncheckedCreateWithoutCustomer_experiencesInput = {
    jobdetail_id?: string
    customer_id?: string | null
    experienced_company?: number
    annual_income?: number | null
    has_management_exp?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: string | null
    updated_by?: string | null
  }

  export type CustomerJobDetailCreateOrConnectWithoutCustomer_experiencesInput = {
    where: CustomerJobDetailWhereUniqueInput
    create: XOR<CustomerJobDetailCreateWithoutCustomer_experiencesInput, CustomerJobDetailUncheckedCreateWithoutCustomer_experiencesInput>
  }

  export type ReferenceListItemsCreateWithoutCustomer_experiencesInput = {
    list: ReferenceListCreateNestedOneWithoutListitemsInput
    dictionary_id: number
    code?: string | null
    listitem_value?: string | null
    parent_id?: number | null
    value?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    Dictionary?: DictionaryCreateNestedOneWithoutReference_listitemsInput
    JobReferenceList?: JobReferenceListCreateNestedManyWithoutReference_list_itemInput
  }

  export type ReferenceListItemsUncheckedCreateWithoutCustomer_experiencesInput = {
    listitem_id?: number
    list_id: number
    dictionary_id: number
    code?: string | null
    listitem_value?: string | null
    parent_id?: number | null
    value?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    dictionaryDictionaries_id?: string | null
    JobReferenceList?: JobReferenceListUncheckedCreateNestedManyWithoutReference_list_itemInput
  }

  export type ReferenceListItemsCreateOrConnectWithoutCustomer_experiencesInput = {
    where: ReferenceListItemsWhereUniqueInput
    create: XOR<ReferenceListItemsCreateWithoutCustomer_experiencesInput, ReferenceListItemsUncheckedCreateWithoutCustomer_experiencesInput>
  }

  export type CustomerJobDetailUpsertWithoutCustomer_experiencesInput = {
    update: XOR<CustomerJobDetailUpdateWithoutCustomer_experiencesInput, CustomerJobDetailUncheckedUpdateWithoutCustomer_experiencesInput>
    create: XOR<CustomerJobDetailCreateWithoutCustomer_experiencesInput, CustomerJobDetailUncheckedCreateWithoutCustomer_experiencesInput>
  }

  export type CustomerJobDetailUpdateWithoutCustomer_experiencesInput = {
    jobdetail_id?: StringFieldUpdateOperationsInput | string
    customer?: CustomerUpdateOneWithoutCustomer_jobdetailsNestedInput
    experienced_company?: IntFieldUpdateOperationsInput | number
    annual_income?: NullableIntFieldUpdateOperationsInput | number | null
    has_management_exp?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CustomerJobDetailUncheckedUpdateWithoutCustomer_experiencesInput = {
    jobdetail_id?: StringFieldUpdateOperationsInput | string
    customer_id?: NullableStringFieldUpdateOperationsInput | string | null
    experienced_company?: IntFieldUpdateOperationsInput | number
    annual_income?: NullableIntFieldUpdateOperationsInput | number | null
    has_management_exp?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ReferenceListItemsUpsertWithoutCustomer_experiencesInput = {
    update: XOR<ReferenceListItemsUpdateWithoutCustomer_experiencesInput, ReferenceListItemsUncheckedUpdateWithoutCustomer_experiencesInput>
    create: XOR<ReferenceListItemsCreateWithoutCustomer_experiencesInput, ReferenceListItemsUncheckedCreateWithoutCustomer_experiencesInput>
  }

  export type ReferenceListItemsUpdateWithoutCustomer_experiencesInput = {
    list?: ReferenceListUpdateOneRequiredWithoutListitemsNestedInput
    dictionary_id?: IntFieldUpdateOperationsInput | number
    code?: NullableStringFieldUpdateOperationsInput | string | null
    listitem_value?: NullableStringFieldUpdateOperationsInput | string | null
    parent_id?: NullableIntFieldUpdateOperationsInput | number | null
    value?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    Dictionary?: DictionaryUpdateOneWithoutReference_listitemsNestedInput
    JobReferenceList?: JobReferenceListUpdateManyWithoutReference_list_itemNestedInput
  }

  export type ReferenceListItemsUncheckedUpdateWithoutCustomer_experiencesInput = {
    listitem_id?: IntFieldUpdateOperationsInput | number
    list_id?: IntFieldUpdateOperationsInput | number
    dictionary_id?: IntFieldUpdateOperationsInput | number
    code?: NullableStringFieldUpdateOperationsInput | string | null
    listitem_value?: NullableStringFieldUpdateOperationsInput | string | null
    parent_id?: NullableIntFieldUpdateOperationsInput | number | null
    value?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    dictionaryDictionaries_id?: NullableStringFieldUpdateOperationsInput | string | null
    JobReferenceList?: JobReferenceListUncheckedUpdateManyWithoutReference_list_itemNestedInput
  }

  export type CustomerCreateWithoutCustomer_jobdetailsInput = {
    customer_id?: string
    first_name: string
    last_name: string
    first_name_kana: string
    last_name_kana: string
    gender?: Gender | null
    birth_date?: Date | string | null
    spouse?: NullableJsonNullValueInput | InputJsonValue
    family_size?: number | null
    email?: string | null
    mobile?: string | null
    phone?: string | null
    profile_image?: string | null
    cv_file?: string | null
    resume_file?: string | null
    prefecture?: NullableJsonNullValueInput | InputJsonValue
    post_code?: string | null
    city?: string | null
    district?: string | null
    address?: string | null
    address1?: string | null
    nearest_station?: string | null
    socials?: NullableJsonNullValueInput | InputJsonValue
    country?: string | null
    experienced_year?: number | null
    from_data?: number | null
    status_customer?: CustomerStatus | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: string | null
    updated_by?: string | null
    user?: UserCreateNestedOneWithoutCustomerInput
    customer_visas?: CustomerVisaCreateNestedManyWithoutCustomerInput
    customer_educations?: CustomerEducationCreateNestedManyWithoutCustomerInput
    customer_languages?: CustomerLanguageCreateNestedManyWithoutCustomerInput
    customer_qualifications?: CustomerQualificationCreateNestedManyWithoutCustomersInput
    customer_workhistories?: CustomerWorkHistoryCreateNestedManyWithoutCustomerInput
    job_candidates?: JobCandidateCreateNestedManyWithoutCustomerInput
    customer_desired?: CustomerDesiredCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutCustomer_jobdetailsInput = {
    customer_id?: string
    first_name: string
    last_name: string
    first_name_kana: string
    last_name_kana: string
    gender?: Gender | null
    birth_date?: Date | string | null
    spouse?: NullableJsonNullValueInput | InputJsonValue
    family_size?: number | null
    email?: string | null
    mobile?: string | null
    phone?: string | null
    profile_image?: string | null
    cv_file?: string | null
    resume_file?: string | null
    prefecture?: NullableJsonNullValueInput | InputJsonValue
    post_code?: string | null
    city?: string | null
    district?: string | null
    address?: string | null
    address1?: string | null
    nearest_station?: string | null
    socials?: NullableJsonNullValueInput | InputJsonValue
    country?: string | null
    experienced_year?: number | null
    from_data?: number | null
    status_customer?: CustomerStatus | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: string | null
    updated_by?: string | null
    user?: UserUncheckedCreateNestedOneWithoutCustomerInput
    customer_visas?: CustomerVisaUncheckedCreateNestedManyWithoutCustomerInput
    customer_educations?: CustomerEducationUncheckedCreateNestedManyWithoutCustomerInput
    customer_languages?: CustomerLanguageUncheckedCreateNestedManyWithoutCustomerInput
    customer_qualifications?: CustomerQualificationUncheckedCreateNestedManyWithoutCustomersInput
    customer_workhistories?: CustomerWorkHistoryUncheckedCreateNestedManyWithoutCustomerInput
    job_candidates?: JobCandidateUncheckedCreateNestedManyWithoutCustomerInput
    customer_desired?: CustomerDesiredUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutCustomer_jobdetailsInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutCustomer_jobdetailsInput, CustomerUncheckedCreateWithoutCustomer_jobdetailsInput>
  }

  export type CustomerExperienceCreateWithoutJobdetailsInput = {
    experience_id?: string
    listitems: ReferenceListItemsCreateNestedOneWithoutCustomer_experiencesInput
    over_year?: number | null
    created_at?: Date | string
    updated_at?: Date | string | null
    created_by?: string | null
    updated_by?: string | null
  }

  export type CustomerExperienceUncheckedCreateWithoutJobdetailsInput = {
    experience_id?: string
    skill_id: number
    over_year?: number | null
    created_at?: Date | string
    updated_at?: Date | string | null
    created_by?: string | null
    updated_by?: string | null
  }

  export type CustomerExperienceCreateOrConnectWithoutJobdetailsInput = {
    where: CustomerExperienceWhereUniqueInput
    create: XOR<CustomerExperienceCreateWithoutJobdetailsInput, CustomerExperienceUncheckedCreateWithoutJobdetailsInput>
  }

  export type CustomerExperienceCreateManyJobdetailsInputEnvelope = {
    data: Enumerable<CustomerExperienceCreateManyJobdetailsInput>
    skipDuplicates?: boolean
  }

  export type CustomerUpsertWithoutCustomer_jobdetailsInput = {
    update: XOR<CustomerUpdateWithoutCustomer_jobdetailsInput, CustomerUncheckedUpdateWithoutCustomer_jobdetailsInput>
    create: XOR<CustomerCreateWithoutCustomer_jobdetailsInput, CustomerUncheckedCreateWithoutCustomer_jobdetailsInput>
  }

  export type CustomerUpdateWithoutCustomer_jobdetailsInput = {
    customer_id?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    first_name_kana?: StringFieldUpdateOperationsInput | string
    last_name_kana?: StringFieldUpdateOperationsInput | string
    gender?: NullableEnumGenderFieldUpdateOperationsInput | Gender | null
    birth_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    spouse?: NullableJsonNullValueInput | InputJsonValue
    family_size?: NullableIntFieldUpdateOperationsInput | number | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profile_image?: NullableStringFieldUpdateOperationsInput | string | null
    cv_file?: NullableStringFieldUpdateOperationsInput | string | null
    resume_file?: NullableStringFieldUpdateOperationsInput | string | null
    prefecture?: NullableJsonNullValueInput | InputJsonValue
    post_code?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    address1?: NullableStringFieldUpdateOperationsInput | string | null
    nearest_station?: NullableStringFieldUpdateOperationsInput | string | null
    socials?: NullableJsonNullValueInput | InputJsonValue
    country?: NullableStringFieldUpdateOperationsInput | string | null
    experienced_year?: NullableIntFieldUpdateOperationsInput | number | null
    from_data?: NullableIntFieldUpdateOperationsInput | number | null
    status_customer?: NullableEnumCustomerStatusFieldUpdateOperationsInput | CustomerStatus | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneWithoutCustomerNestedInput
    customer_visas?: CustomerVisaUpdateManyWithoutCustomerNestedInput
    customer_educations?: CustomerEducationUpdateManyWithoutCustomerNestedInput
    customer_languages?: CustomerLanguageUpdateManyWithoutCustomerNestedInput
    customer_qualifications?: CustomerQualificationUpdateManyWithoutCustomersNestedInput
    customer_workhistories?: CustomerWorkHistoryUpdateManyWithoutCustomerNestedInput
    job_candidates?: JobCandidateUpdateManyWithoutCustomerNestedInput
    customer_desired?: CustomerDesiredUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutCustomer_jobdetailsInput = {
    customer_id?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    first_name_kana?: StringFieldUpdateOperationsInput | string
    last_name_kana?: StringFieldUpdateOperationsInput | string
    gender?: NullableEnumGenderFieldUpdateOperationsInput | Gender | null
    birth_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    spouse?: NullableJsonNullValueInput | InputJsonValue
    family_size?: NullableIntFieldUpdateOperationsInput | number | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profile_image?: NullableStringFieldUpdateOperationsInput | string | null
    cv_file?: NullableStringFieldUpdateOperationsInput | string | null
    resume_file?: NullableStringFieldUpdateOperationsInput | string | null
    prefecture?: NullableJsonNullValueInput | InputJsonValue
    post_code?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    address1?: NullableStringFieldUpdateOperationsInput | string | null
    nearest_station?: NullableStringFieldUpdateOperationsInput | string | null
    socials?: NullableJsonNullValueInput | InputJsonValue
    country?: NullableStringFieldUpdateOperationsInput | string | null
    experienced_year?: NullableIntFieldUpdateOperationsInput | number | null
    from_data?: NullableIntFieldUpdateOperationsInput | number | null
    status_customer?: NullableEnumCustomerStatusFieldUpdateOperationsInput | CustomerStatus | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUncheckedUpdateOneWithoutCustomerNestedInput
    customer_visas?: CustomerVisaUncheckedUpdateManyWithoutCustomerNestedInput
    customer_educations?: CustomerEducationUncheckedUpdateManyWithoutCustomerNestedInput
    customer_languages?: CustomerLanguageUncheckedUpdateManyWithoutCustomerNestedInput
    customer_qualifications?: CustomerQualificationUncheckedUpdateManyWithoutCustomersNestedInput
    customer_workhistories?: CustomerWorkHistoryUncheckedUpdateManyWithoutCustomerNestedInput
    job_candidates?: JobCandidateUncheckedUpdateManyWithoutCustomerNestedInput
    customer_desired?: CustomerDesiredUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerExperienceUpsertWithWhereUniqueWithoutJobdetailsInput = {
    where: CustomerExperienceWhereUniqueInput
    update: XOR<CustomerExperienceUpdateWithoutJobdetailsInput, CustomerExperienceUncheckedUpdateWithoutJobdetailsInput>
    create: XOR<CustomerExperienceCreateWithoutJobdetailsInput, CustomerExperienceUncheckedCreateWithoutJobdetailsInput>
  }

  export type CustomerExperienceUpdateWithWhereUniqueWithoutJobdetailsInput = {
    where: CustomerExperienceWhereUniqueInput
    data: XOR<CustomerExperienceUpdateWithoutJobdetailsInput, CustomerExperienceUncheckedUpdateWithoutJobdetailsInput>
  }

  export type CustomerExperienceUpdateManyWithWhereWithoutJobdetailsInput = {
    where: CustomerExperienceScalarWhereInput
    data: XOR<CustomerExperienceUpdateManyMutationInput, CustomerExperienceUncheckedUpdateManyWithoutCustomer_experiencesInput>
  }

  export type CustomerExperienceScalarWhereInput = {
    AND?: Enumerable<CustomerExperienceScalarWhereInput>
    OR?: Enumerable<CustomerExperienceScalarWhereInput>
    NOT?: Enumerable<CustomerExperienceScalarWhereInput>
    experience_id?: StringFilter | string
    jobdetail_id?: StringFilter | string
    skill_id?: IntFilter | number
    over_year?: IntNullableFilter | number | null
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeNullableFilter | Date | string | null
    created_by?: StringNullableFilter | string | null
    updated_by?: StringNullableFilter | string | null
  }

  export type CustomerCreateWithoutCustomer_languagesInput = {
    customer_id?: string
    first_name: string
    last_name: string
    first_name_kana: string
    last_name_kana: string
    gender?: Gender | null
    birth_date?: Date | string | null
    spouse?: NullableJsonNullValueInput | InputJsonValue
    family_size?: number | null
    email?: string | null
    mobile?: string | null
    phone?: string | null
    profile_image?: string | null
    cv_file?: string | null
    resume_file?: string | null
    prefecture?: NullableJsonNullValueInput | InputJsonValue
    post_code?: string | null
    city?: string | null
    district?: string | null
    address?: string | null
    address1?: string | null
    nearest_station?: string | null
    socials?: NullableJsonNullValueInput | InputJsonValue
    country?: string | null
    experienced_year?: number | null
    from_data?: number | null
    status_customer?: CustomerStatus | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: string | null
    updated_by?: string | null
    user?: UserCreateNestedOneWithoutCustomerInput
    customer_visas?: CustomerVisaCreateNestedManyWithoutCustomerInput
    customer_jobdetails?: CustomerJobDetailCreateNestedManyWithoutCustomerInput
    customer_educations?: CustomerEducationCreateNestedManyWithoutCustomerInput
    customer_qualifications?: CustomerQualificationCreateNestedManyWithoutCustomersInput
    customer_workhistories?: CustomerWorkHistoryCreateNestedManyWithoutCustomerInput
    job_candidates?: JobCandidateCreateNestedManyWithoutCustomerInput
    customer_desired?: CustomerDesiredCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutCustomer_languagesInput = {
    customer_id?: string
    first_name: string
    last_name: string
    first_name_kana: string
    last_name_kana: string
    gender?: Gender | null
    birth_date?: Date | string | null
    spouse?: NullableJsonNullValueInput | InputJsonValue
    family_size?: number | null
    email?: string | null
    mobile?: string | null
    phone?: string | null
    profile_image?: string | null
    cv_file?: string | null
    resume_file?: string | null
    prefecture?: NullableJsonNullValueInput | InputJsonValue
    post_code?: string | null
    city?: string | null
    district?: string | null
    address?: string | null
    address1?: string | null
    nearest_station?: string | null
    socials?: NullableJsonNullValueInput | InputJsonValue
    country?: string | null
    experienced_year?: number | null
    from_data?: number | null
    status_customer?: CustomerStatus | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: string | null
    updated_by?: string | null
    user?: UserUncheckedCreateNestedOneWithoutCustomerInput
    customer_visas?: CustomerVisaUncheckedCreateNestedManyWithoutCustomerInput
    customer_jobdetails?: CustomerJobDetailUncheckedCreateNestedManyWithoutCustomerInput
    customer_educations?: CustomerEducationUncheckedCreateNestedManyWithoutCustomerInput
    customer_qualifications?: CustomerQualificationUncheckedCreateNestedManyWithoutCustomersInput
    customer_workhistories?: CustomerWorkHistoryUncheckedCreateNestedManyWithoutCustomerInput
    job_candidates?: JobCandidateUncheckedCreateNestedManyWithoutCustomerInput
    customer_desired?: CustomerDesiredUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutCustomer_languagesInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutCustomer_languagesInput, CustomerUncheckedCreateWithoutCustomer_languagesInput>
  }

  export type CustomerUpsertWithoutCustomer_languagesInput = {
    update: XOR<CustomerUpdateWithoutCustomer_languagesInput, CustomerUncheckedUpdateWithoutCustomer_languagesInput>
    create: XOR<CustomerCreateWithoutCustomer_languagesInput, CustomerUncheckedCreateWithoutCustomer_languagesInput>
  }

  export type CustomerUpdateWithoutCustomer_languagesInput = {
    customer_id?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    first_name_kana?: StringFieldUpdateOperationsInput | string
    last_name_kana?: StringFieldUpdateOperationsInput | string
    gender?: NullableEnumGenderFieldUpdateOperationsInput | Gender | null
    birth_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    spouse?: NullableJsonNullValueInput | InputJsonValue
    family_size?: NullableIntFieldUpdateOperationsInput | number | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profile_image?: NullableStringFieldUpdateOperationsInput | string | null
    cv_file?: NullableStringFieldUpdateOperationsInput | string | null
    resume_file?: NullableStringFieldUpdateOperationsInput | string | null
    prefecture?: NullableJsonNullValueInput | InputJsonValue
    post_code?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    address1?: NullableStringFieldUpdateOperationsInput | string | null
    nearest_station?: NullableStringFieldUpdateOperationsInput | string | null
    socials?: NullableJsonNullValueInput | InputJsonValue
    country?: NullableStringFieldUpdateOperationsInput | string | null
    experienced_year?: NullableIntFieldUpdateOperationsInput | number | null
    from_data?: NullableIntFieldUpdateOperationsInput | number | null
    status_customer?: NullableEnumCustomerStatusFieldUpdateOperationsInput | CustomerStatus | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneWithoutCustomerNestedInput
    customer_visas?: CustomerVisaUpdateManyWithoutCustomerNestedInput
    customer_jobdetails?: CustomerJobDetailUpdateManyWithoutCustomerNestedInput
    customer_educations?: CustomerEducationUpdateManyWithoutCustomerNestedInput
    customer_qualifications?: CustomerQualificationUpdateManyWithoutCustomersNestedInput
    customer_workhistories?: CustomerWorkHistoryUpdateManyWithoutCustomerNestedInput
    job_candidates?: JobCandidateUpdateManyWithoutCustomerNestedInput
    customer_desired?: CustomerDesiredUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutCustomer_languagesInput = {
    customer_id?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    first_name_kana?: StringFieldUpdateOperationsInput | string
    last_name_kana?: StringFieldUpdateOperationsInput | string
    gender?: NullableEnumGenderFieldUpdateOperationsInput | Gender | null
    birth_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    spouse?: NullableJsonNullValueInput | InputJsonValue
    family_size?: NullableIntFieldUpdateOperationsInput | number | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profile_image?: NullableStringFieldUpdateOperationsInput | string | null
    cv_file?: NullableStringFieldUpdateOperationsInput | string | null
    resume_file?: NullableStringFieldUpdateOperationsInput | string | null
    prefecture?: NullableJsonNullValueInput | InputJsonValue
    post_code?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    address1?: NullableStringFieldUpdateOperationsInput | string | null
    nearest_station?: NullableStringFieldUpdateOperationsInput | string | null
    socials?: NullableJsonNullValueInput | InputJsonValue
    country?: NullableStringFieldUpdateOperationsInput | string | null
    experienced_year?: NullableIntFieldUpdateOperationsInput | number | null
    from_data?: NullableIntFieldUpdateOperationsInput | number | null
    status_customer?: NullableEnumCustomerStatusFieldUpdateOperationsInput | CustomerStatus | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUncheckedUpdateOneWithoutCustomerNestedInput
    customer_visas?: CustomerVisaUncheckedUpdateManyWithoutCustomerNestedInput
    customer_jobdetails?: CustomerJobDetailUncheckedUpdateManyWithoutCustomerNestedInput
    customer_educations?: CustomerEducationUncheckedUpdateManyWithoutCustomerNestedInput
    customer_qualifications?: CustomerQualificationUncheckedUpdateManyWithoutCustomersNestedInput
    customer_workhistories?: CustomerWorkHistoryUncheckedUpdateManyWithoutCustomerNestedInput
    job_candidates?: JobCandidateUncheckedUpdateManyWithoutCustomerNestedInput
    customer_desired?: CustomerDesiredUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerCreateWithoutCustomer_qualificationsInput = {
    customer_id?: string
    first_name: string
    last_name: string
    first_name_kana: string
    last_name_kana: string
    gender?: Gender | null
    birth_date?: Date | string | null
    spouse?: NullableJsonNullValueInput | InputJsonValue
    family_size?: number | null
    email?: string | null
    mobile?: string | null
    phone?: string | null
    profile_image?: string | null
    cv_file?: string | null
    resume_file?: string | null
    prefecture?: NullableJsonNullValueInput | InputJsonValue
    post_code?: string | null
    city?: string | null
    district?: string | null
    address?: string | null
    address1?: string | null
    nearest_station?: string | null
    socials?: NullableJsonNullValueInput | InputJsonValue
    country?: string | null
    experienced_year?: number | null
    from_data?: number | null
    status_customer?: CustomerStatus | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: string | null
    updated_by?: string | null
    user?: UserCreateNestedOneWithoutCustomerInput
    customer_visas?: CustomerVisaCreateNestedManyWithoutCustomerInput
    customer_jobdetails?: CustomerJobDetailCreateNestedManyWithoutCustomerInput
    customer_educations?: CustomerEducationCreateNestedManyWithoutCustomerInput
    customer_languages?: CustomerLanguageCreateNestedManyWithoutCustomerInput
    customer_workhistories?: CustomerWorkHistoryCreateNestedManyWithoutCustomerInput
    job_candidates?: JobCandidateCreateNestedManyWithoutCustomerInput
    customer_desired?: CustomerDesiredCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutCustomer_qualificationsInput = {
    customer_id?: string
    first_name: string
    last_name: string
    first_name_kana: string
    last_name_kana: string
    gender?: Gender | null
    birth_date?: Date | string | null
    spouse?: NullableJsonNullValueInput | InputJsonValue
    family_size?: number | null
    email?: string | null
    mobile?: string | null
    phone?: string | null
    profile_image?: string | null
    cv_file?: string | null
    resume_file?: string | null
    prefecture?: NullableJsonNullValueInput | InputJsonValue
    post_code?: string | null
    city?: string | null
    district?: string | null
    address?: string | null
    address1?: string | null
    nearest_station?: string | null
    socials?: NullableJsonNullValueInput | InputJsonValue
    country?: string | null
    experienced_year?: number | null
    from_data?: number | null
    status_customer?: CustomerStatus | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: string | null
    updated_by?: string | null
    user?: UserUncheckedCreateNestedOneWithoutCustomerInput
    customer_visas?: CustomerVisaUncheckedCreateNestedManyWithoutCustomerInput
    customer_jobdetails?: CustomerJobDetailUncheckedCreateNestedManyWithoutCustomerInput
    customer_educations?: CustomerEducationUncheckedCreateNestedManyWithoutCustomerInput
    customer_languages?: CustomerLanguageUncheckedCreateNestedManyWithoutCustomerInput
    customer_workhistories?: CustomerWorkHistoryUncheckedCreateNestedManyWithoutCustomerInput
    job_candidates?: JobCandidateUncheckedCreateNestedManyWithoutCustomerInput
    customer_desired?: CustomerDesiredUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutCustomer_qualificationsInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutCustomer_qualificationsInput, CustomerUncheckedCreateWithoutCustomer_qualificationsInput>
  }

  export type CustomerUpsertWithoutCustomer_qualificationsInput = {
    update: XOR<CustomerUpdateWithoutCustomer_qualificationsInput, CustomerUncheckedUpdateWithoutCustomer_qualificationsInput>
    create: XOR<CustomerCreateWithoutCustomer_qualificationsInput, CustomerUncheckedCreateWithoutCustomer_qualificationsInput>
  }

  export type CustomerUpdateWithoutCustomer_qualificationsInput = {
    customer_id?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    first_name_kana?: StringFieldUpdateOperationsInput | string
    last_name_kana?: StringFieldUpdateOperationsInput | string
    gender?: NullableEnumGenderFieldUpdateOperationsInput | Gender | null
    birth_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    spouse?: NullableJsonNullValueInput | InputJsonValue
    family_size?: NullableIntFieldUpdateOperationsInput | number | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profile_image?: NullableStringFieldUpdateOperationsInput | string | null
    cv_file?: NullableStringFieldUpdateOperationsInput | string | null
    resume_file?: NullableStringFieldUpdateOperationsInput | string | null
    prefecture?: NullableJsonNullValueInput | InputJsonValue
    post_code?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    address1?: NullableStringFieldUpdateOperationsInput | string | null
    nearest_station?: NullableStringFieldUpdateOperationsInput | string | null
    socials?: NullableJsonNullValueInput | InputJsonValue
    country?: NullableStringFieldUpdateOperationsInput | string | null
    experienced_year?: NullableIntFieldUpdateOperationsInput | number | null
    from_data?: NullableIntFieldUpdateOperationsInput | number | null
    status_customer?: NullableEnumCustomerStatusFieldUpdateOperationsInput | CustomerStatus | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneWithoutCustomerNestedInput
    customer_visas?: CustomerVisaUpdateManyWithoutCustomerNestedInput
    customer_jobdetails?: CustomerJobDetailUpdateManyWithoutCustomerNestedInput
    customer_educations?: CustomerEducationUpdateManyWithoutCustomerNestedInput
    customer_languages?: CustomerLanguageUpdateManyWithoutCustomerNestedInput
    customer_workhistories?: CustomerWorkHistoryUpdateManyWithoutCustomerNestedInput
    job_candidates?: JobCandidateUpdateManyWithoutCustomerNestedInput
    customer_desired?: CustomerDesiredUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutCustomer_qualificationsInput = {
    customer_id?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    first_name_kana?: StringFieldUpdateOperationsInput | string
    last_name_kana?: StringFieldUpdateOperationsInput | string
    gender?: NullableEnumGenderFieldUpdateOperationsInput | Gender | null
    birth_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    spouse?: NullableJsonNullValueInput | InputJsonValue
    family_size?: NullableIntFieldUpdateOperationsInput | number | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profile_image?: NullableStringFieldUpdateOperationsInput | string | null
    cv_file?: NullableStringFieldUpdateOperationsInput | string | null
    resume_file?: NullableStringFieldUpdateOperationsInput | string | null
    prefecture?: NullableJsonNullValueInput | InputJsonValue
    post_code?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    address1?: NullableStringFieldUpdateOperationsInput | string | null
    nearest_station?: NullableStringFieldUpdateOperationsInput | string | null
    socials?: NullableJsonNullValueInput | InputJsonValue
    country?: NullableStringFieldUpdateOperationsInput | string | null
    experienced_year?: NullableIntFieldUpdateOperationsInput | number | null
    from_data?: NullableIntFieldUpdateOperationsInput | number | null
    status_customer?: NullableEnumCustomerStatusFieldUpdateOperationsInput | CustomerStatus | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUncheckedUpdateOneWithoutCustomerNestedInput
    customer_visas?: CustomerVisaUncheckedUpdateManyWithoutCustomerNestedInput
    customer_jobdetails?: CustomerJobDetailUncheckedUpdateManyWithoutCustomerNestedInput
    customer_educations?: CustomerEducationUncheckedUpdateManyWithoutCustomerNestedInput
    customer_languages?: CustomerLanguageUncheckedUpdateManyWithoutCustomerNestedInput
    customer_workhistories?: CustomerWorkHistoryUncheckedUpdateManyWithoutCustomerNestedInput
    job_candidates?: JobCandidateUncheckedUpdateManyWithoutCustomerNestedInput
    customer_desired?: CustomerDesiredUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerCreateWithoutCustomer_visasInput = {
    customer_id?: string
    first_name: string
    last_name: string
    first_name_kana: string
    last_name_kana: string
    gender?: Gender | null
    birth_date?: Date | string | null
    spouse?: NullableJsonNullValueInput | InputJsonValue
    family_size?: number | null
    email?: string | null
    mobile?: string | null
    phone?: string | null
    profile_image?: string | null
    cv_file?: string | null
    resume_file?: string | null
    prefecture?: NullableJsonNullValueInput | InputJsonValue
    post_code?: string | null
    city?: string | null
    district?: string | null
    address?: string | null
    address1?: string | null
    nearest_station?: string | null
    socials?: NullableJsonNullValueInput | InputJsonValue
    country?: string | null
    experienced_year?: number | null
    from_data?: number | null
    status_customer?: CustomerStatus | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: string | null
    updated_by?: string | null
    user?: UserCreateNestedOneWithoutCustomerInput
    customer_jobdetails?: CustomerJobDetailCreateNestedManyWithoutCustomerInput
    customer_educations?: CustomerEducationCreateNestedManyWithoutCustomerInput
    customer_languages?: CustomerLanguageCreateNestedManyWithoutCustomerInput
    customer_qualifications?: CustomerQualificationCreateNestedManyWithoutCustomersInput
    customer_workhistories?: CustomerWorkHistoryCreateNestedManyWithoutCustomerInput
    job_candidates?: JobCandidateCreateNestedManyWithoutCustomerInput
    customer_desired?: CustomerDesiredCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutCustomer_visasInput = {
    customer_id?: string
    first_name: string
    last_name: string
    first_name_kana: string
    last_name_kana: string
    gender?: Gender | null
    birth_date?: Date | string | null
    spouse?: NullableJsonNullValueInput | InputJsonValue
    family_size?: number | null
    email?: string | null
    mobile?: string | null
    phone?: string | null
    profile_image?: string | null
    cv_file?: string | null
    resume_file?: string | null
    prefecture?: NullableJsonNullValueInput | InputJsonValue
    post_code?: string | null
    city?: string | null
    district?: string | null
    address?: string | null
    address1?: string | null
    nearest_station?: string | null
    socials?: NullableJsonNullValueInput | InputJsonValue
    country?: string | null
    experienced_year?: number | null
    from_data?: number | null
    status_customer?: CustomerStatus | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: string | null
    updated_by?: string | null
    user?: UserUncheckedCreateNestedOneWithoutCustomerInput
    customer_jobdetails?: CustomerJobDetailUncheckedCreateNestedManyWithoutCustomerInput
    customer_educations?: CustomerEducationUncheckedCreateNestedManyWithoutCustomerInput
    customer_languages?: CustomerLanguageUncheckedCreateNestedManyWithoutCustomerInput
    customer_qualifications?: CustomerQualificationUncheckedCreateNestedManyWithoutCustomersInput
    customer_workhistories?: CustomerWorkHistoryUncheckedCreateNestedManyWithoutCustomerInput
    job_candidates?: JobCandidateUncheckedCreateNestedManyWithoutCustomerInput
    customer_desired?: CustomerDesiredUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutCustomer_visasInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutCustomer_visasInput, CustomerUncheckedCreateWithoutCustomer_visasInput>
  }

  export type CustomerUpsertWithoutCustomer_visasInput = {
    update: XOR<CustomerUpdateWithoutCustomer_visasInput, CustomerUncheckedUpdateWithoutCustomer_visasInput>
    create: XOR<CustomerCreateWithoutCustomer_visasInput, CustomerUncheckedCreateWithoutCustomer_visasInput>
  }

  export type CustomerUpdateWithoutCustomer_visasInput = {
    customer_id?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    first_name_kana?: StringFieldUpdateOperationsInput | string
    last_name_kana?: StringFieldUpdateOperationsInput | string
    gender?: NullableEnumGenderFieldUpdateOperationsInput | Gender | null
    birth_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    spouse?: NullableJsonNullValueInput | InputJsonValue
    family_size?: NullableIntFieldUpdateOperationsInput | number | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profile_image?: NullableStringFieldUpdateOperationsInput | string | null
    cv_file?: NullableStringFieldUpdateOperationsInput | string | null
    resume_file?: NullableStringFieldUpdateOperationsInput | string | null
    prefecture?: NullableJsonNullValueInput | InputJsonValue
    post_code?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    address1?: NullableStringFieldUpdateOperationsInput | string | null
    nearest_station?: NullableStringFieldUpdateOperationsInput | string | null
    socials?: NullableJsonNullValueInput | InputJsonValue
    country?: NullableStringFieldUpdateOperationsInput | string | null
    experienced_year?: NullableIntFieldUpdateOperationsInput | number | null
    from_data?: NullableIntFieldUpdateOperationsInput | number | null
    status_customer?: NullableEnumCustomerStatusFieldUpdateOperationsInput | CustomerStatus | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneWithoutCustomerNestedInput
    customer_jobdetails?: CustomerJobDetailUpdateManyWithoutCustomerNestedInput
    customer_educations?: CustomerEducationUpdateManyWithoutCustomerNestedInput
    customer_languages?: CustomerLanguageUpdateManyWithoutCustomerNestedInput
    customer_qualifications?: CustomerQualificationUpdateManyWithoutCustomersNestedInput
    customer_workhistories?: CustomerWorkHistoryUpdateManyWithoutCustomerNestedInput
    job_candidates?: JobCandidateUpdateManyWithoutCustomerNestedInput
    customer_desired?: CustomerDesiredUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutCustomer_visasInput = {
    customer_id?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    first_name_kana?: StringFieldUpdateOperationsInput | string
    last_name_kana?: StringFieldUpdateOperationsInput | string
    gender?: NullableEnumGenderFieldUpdateOperationsInput | Gender | null
    birth_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    spouse?: NullableJsonNullValueInput | InputJsonValue
    family_size?: NullableIntFieldUpdateOperationsInput | number | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profile_image?: NullableStringFieldUpdateOperationsInput | string | null
    cv_file?: NullableStringFieldUpdateOperationsInput | string | null
    resume_file?: NullableStringFieldUpdateOperationsInput | string | null
    prefecture?: NullableJsonNullValueInput | InputJsonValue
    post_code?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    address1?: NullableStringFieldUpdateOperationsInput | string | null
    nearest_station?: NullableStringFieldUpdateOperationsInput | string | null
    socials?: NullableJsonNullValueInput | InputJsonValue
    country?: NullableStringFieldUpdateOperationsInput | string | null
    experienced_year?: NullableIntFieldUpdateOperationsInput | number | null
    from_data?: NullableIntFieldUpdateOperationsInput | number | null
    status_customer?: NullableEnumCustomerStatusFieldUpdateOperationsInput | CustomerStatus | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUncheckedUpdateOneWithoutCustomerNestedInput
    customer_jobdetails?: CustomerJobDetailUncheckedUpdateManyWithoutCustomerNestedInput
    customer_educations?: CustomerEducationUncheckedUpdateManyWithoutCustomerNestedInput
    customer_languages?: CustomerLanguageUncheckedUpdateManyWithoutCustomerNestedInput
    customer_qualifications?: CustomerQualificationUncheckedUpdateManyWithoutCustomersNestedInput
    customer_workhistories?: CustomerWorkHistoryUncheckedUpdateManyWithoutCustomerNestedInput
    job_candidates?: JobCandidateUncheckedUpdateManyWithoutCustomerNestedInput
    customer_desired?: CustomerDesiredUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerCreateWithoutCustomer_workhistoriesInput = {
    customer_id?: string
    first_name: string
    last_name: string
    first_name_kana: string
    last_name_kana: string
    gender?: Gender | null
    birth_date?: Date | string | null
    spouse?: NullableJsonNullValueInput | InputJsonValue
    family_size?: number | null
    email?: string | null
    mobile?: string | null
    phone?: string | null
    profile_image?: string | null
    cv_file?: string | null
    resume_file?: string | null
    prefecture?: NullableJsonNullValueInput | InputJsonValue
    post_code?: string | null
    city?: string | null
    district?: string | null
    address?: string | null
    address1?: string | null
    nearest_station?: string | null
    socials?: NullableJsonNullValueInput | InputJsonValue
    country?: string | null
    experienced_year?: number | null
    from_data?: number | null
    status_customer?: CustomerStatus | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: string | null
    updated_by?: string | null
    user?: UserCreateNestedOneWithoutCustomerInput
    customer_visas?: CustomerVisaCreateNestedManyWithoutCustomerInput
    customer_jobdetails?: CustomerJobDetailCreateNestedManyWithoutCustomerInput
    customer_educations?: CustomerEducationCreateNestedManyWithoutCustomerInput
    customer_languages?: CustomerLanguageCreateNestedManyWithoutCustomerInput
    customer_qualifications?: CustomerQualificationCreateNestedManyWithoutCustomersInput
    job_candidates?: JobCandidateCreateNestedManyWithoutCustomerInput
    customer_desired?: CustomerDesiredCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutCustomer_workhistoriesInput = {
    customer_id?: string
    first_name: string
    last_name: string
    first_name_kana: string
    last_name_kana: string
    gender?: Gender | null
    birth_date?: Date | string | null
    spouse?: NullableJsonNullValueInput | InputJsonValue
    family_size?: number | null
    email?: string | null
    mobile?: string | null
    phone?: string | null
    profile_image?: string | null
    cv_file?: string | null
    resume_file?: string | null
    prefecture?: NullableJsonNullValueInput | InputJsonValue
    post_code?: string | null
    city?: string | null
    district?: string | null
    address?: string | null
    address1?: string | null
    nearest_station?: string | null
    socials?: NullableJsonNullValueInput | InputJsonValue
    country?: string | null
    experienced_year?: number | null
    from_data?: number | null
    status_customer?: CustomerStatus | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: string | null
    updated_by?: string | null
    user?: UserUncheckedCreateNestedOneWithoutCustomerInput
    customer_visas?: CustomerVisaUncheckedCreateNestedManyWithoutCustomerInput
    customer_jobdetails?: CustomerJobDetailUncheckedCreateNestedManyWithoutCustomerInput
    customer_educations?: CustomerEducationUncheckedCreateNestedManyWithoutCustomerInput
    customer_languages?: CustomerLanguageUncheckedCreateNestedManyWithoutCustomerInput
    customer_qualifications?: CustomerQualificationUncheckedCreateNestedManyWithoutCustomersInput
    job_candidates?: JobCandidateUncheckedCreateNestedManyWithoutCustomerInput
    customer_desired?: CustomerDesiredUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutCustomer_workhistoriesInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutCustomer_workhistoriesInput, CustomerUncheckedCreateWithoutCustomer_workhistoriesInput>
  }

  export type CustomerUpsertWithoutCustomer_workhistoriesInput = {
    update: XOR<CustomerUpdateWithoutCustomer_workhistoriesInput, CustomerUncheckedUpdateWithoutCustomer_workhistoriesInput>
    create: XOR<CustomerCreateWithoutCustomer_workhistoriesInput, CustomerUncheckedCreateWithoutCustomer_workhistoriesInput>
  }

  export type CustomerUpdateWithoutCustomer_workhistoriesInput = {
    customer_id?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    first_name_kana?: StringFieldUpdateOperationsInput | string
    last_name_kana?: StringFieldUpdateOperationsInput | string
    gender?: NullableEnumGenderFieldUpdateOperationsInput | Gender | null
    birth_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    spouse?: NullableJsonNullValueInput | InputJsonValue
    family_size?: NullableIntFieldUpdateOperationsInput | number | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profile_image?: NullableStringFieldUpdateOperationsInput | string | null
    cv_file?: NullableStringFieldUpdateOperationsInput | string | null
    resume_file?: NullableStringFieldUpdateOperationsInput | string | null
    prefecture?: NullableJsonNullValueInput | InputJsonValue
    post_code?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    address1?: NullableStringFieldUpdateOperationsInput | string | null
    nearest_station?: NullableStringFieldUpdateOperationsInput | string | null
    socials?: NullableJsonNullValueInput | InputJsonValue
    country?: NullableStringFieldUpdateOperationsInput | string | null
    experienced_year?: NullableIntFieldUpdateOperationsInput | number | null
    from_data?: NullableIntFieldUpdateOperationsInput | number | null
    status_customer?: NullableEnumCustomerStatusFieldUpdateOperationsInput | CustomerStatus | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneWithoutCustomerNestedInput
    customer_visas?: CustomerVisaUpdateManyWithoutCustomerNestedInput
    customer_jobdetails?: CustomerJobDetailUpdateManyWithoutCustomerNestedInput
    customer_educations?: CustomerEducationUpdateManyWithoutCustomerNestedInput
    customer_languages?: CustomerLanguageUpdateManyWithoutCustomerNestedInput
    customer_qualifications?: CustomerQualificationUpdateManyWithoutCustomersNestedInput
    job_candidates?: JobCandidateUpdateManyWithoutCustomerNestedInput
    customer_desired?: CustomerDesiredUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutCustomer_workhistoriesInput = {
    customer_id?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    first_name_kana?: StringFieldUpdateOperationsInput | string
    last_name_kana?: StringFieldUpdateOperationsInput | string
    gender?: NullableEnumGenderFieldUpdateOperationsInput | Gender | null
    birth_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    spouse?: NullableJsonNullValueInput | InputJsonValue
    family_size?: NullableIntFieldUpdateOperationsInput | number | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profile_image?: NullableStringFieldUpdateOperationsInput | string | null
    cv_file?: NullableStringFieldUpdateOperationsInput | string | null
    resume_file?: NullableStringFieldUpdateOperationsInput | string | null
    prefecture?: NullableJsonNullValueInput | InputJsonValue
    post_code?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    address1?: NullableStringFieldUpdateOperationsInput | string | null
    nearest_station?: NullableStringFieldUpdateOperationsInput | string | null
    socials?: NullableJsonNullValueInput | InputJsonValue
    country?: NullableStringFieldUpdateOperationsInput | string | null
    experienced_year?: NullableIntFieldUpdateOperationsInput | number | null
    from_data?: NullableIntFieldUpdateOperationsInput | number | null
    status_customer?: NullableEnumCustomerStatusFieldUpdateOperationsInput | CustomerStatus | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUncheckedUpdateOneWithoutCustomerNestedInput
    customer_visas?: CustomerVisaUncheckedUpdateManyWithoutCustomerNestedInput
    customer_jobdetails?: CustomerJobDetailUncheckedUpdateManyWithoutCustomerNestedInput
    customer_educations?: CustomerEducationUncheckedUpdateManyWithoutCustomerNestedInput
    customer_languages?: CustomerLanguageUncheckedUpdateManyWithoutCustomerNestedInput
    customer_qualifications?: CustomerQualificationUncheckedUpdateManyWithoutCustomersNestedInput
    job_candidates?: JobCandidateUncheckedUpdateManyWithoutCustomerNestedInput
    customer_desired?: CustomerDesiredUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type ReferenceListItemsCreateWithoutDictionaryInput = {
    list: ReferenceListCreateNestedOneWithoutListitemsInput
    dictionary_id: number
    code?: string | null
    listitem_value?: string | null
    parent_id?: number | null
    value?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    customer_experiences?: CustomerExperienceCreateNestedManyWithoutListitemsInput
    JobReferenceList?: JobReferenceListCreateNestedManyWithoutReference_list_itemInput
  }

  export type ReferenceListItemsUncheckedCreateWithoutDictionaryInput = {
    listitem_id?: number
    list_id: number
    dictionary_id: number
    code?: string | null
    listitem_value?: string | null
    parent_id?: number | null
    value?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    customer_experiences?: CustomerExperienceUncheckedCreateNestedManyWithoutListitemsInput
    JobReferenceList?: JobReferenceListUncheckedCreateNestedManyWithoutReference_list_itemInput
  }

  export type ReferenceListItemsCreateOrConnectWithoutDictionaryInput = {
    where: ReferenceListItemsWhereUniqueInput
    create: XOR<ReferenceListItemsCreateWithoutDictionaryInput, ReferenceListItemsUncheckedCreateWithoutDictionaryInput>
  }

  export type ReferenceListItemsCreateManyDictionaryInputEnvelope = {
    data: Enumerable<ReferenceListItemsCreateManyDictionaryInput>
    skipDuplicates?: boolean
  }

  export type ReferenceListItemsUpsertWithWhereUniqueWithoutDictionaryInput = {
    where: ReferenceListItemsWhereUniqueInput
    update: XOR<ReferenceListItemsUpdateWithoutDictionaryInput, ReferenceListItemsUncheckedUpdateWithoutDictionaryInput>
    create: XOR<ReferenceListItemsCreateWithoutDictionaryInput, ReferenceListItemsUncheckedCreateWithoutDictionaryInput>
  }

  export type ReferenceListItemsUpdateWithWhereUniqueWithoutDictionaryInput = {
    where: ReferenceListItemsWhereUniqueInput
    data: XOR<ReferenceListItemsUpdateWithoutDictionaryInput, ReferenceListItemsUncheckedUpdateWithoutDictionaryInput>
  }

  export type ReferenceListItemsUpdateManyWithWhereWithoutDictionaryInput = {
    where: ReferenceListItemsScalarWhereInput
    data: XOR<ReferenceListItemsUpdateManyMutationInput, ReferenceListItemsUncheckedUpdateManyWithoutReference_listitemsInput>
  }

  export type ReferenceListItemsScalarWhereInput = {
    AND?: Enumerable<ReferenceListItemsScalarWhereInput>
    OR?: Enumerable<ReferenceListItemsScalarWhereInput>
    NOT?: Enumerable<ReferenceListItemsScalarWhereInput>
    listitem_id?: IntFilter | number
    list_id?: IntFilter | number
    dictionary_id?: IntFilter | number
    code?: StringNullableFilter | string | null
    listitem_value?: StringNullableFilter | string | null
    parent_id?: IntNullableFilter | number | null
    value?: StringNullableFilter | string | null
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    dictionaryDictionaries_id?: StringNullableFilter | string | null
  }

  export type EntityDetailCreateWithoutEntityInput = {
    entity_detail_id?: string
    establishment?: Date | string | null
    capital?: number | null
    numberof_employees?: number | null
    business_performance?: NullableJsonNullValueInput | InputJsonValue
    representative_telephone?: string | null
    representative?: string | null
    average_age?: number | null
    foreign_capitalratio?: number | null
    homepage?: string | null
    business_summary?: string | null
    organizational_structure?: string | null
    company_sales?: string | null
    workplace_environment?: string | null
    shareholder?: NullableJsonNullValueInput | InputJsonValue
    related_company?: number | null
    recruitment_personname?: string | null
    memo?: string | null
    business_status?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: string | null
    updated_by?: string | null
  }

  export type EntityDetailUncheckedCreateWithoutEntityInput = {
    entity_detail_id?: string
    establishment?: Date | string | null
    capital?: number | null
    numberof_employees?: number | null
    business_performance?: NullableJsonNullValueInput | InputJsonValue
    representative_telephone?: string | null
    representative?: string | null
    average_age?: number | null
    foreign_capitalratio?: number | null
    homepage?: string | null
    business_summary?: string | null
    organizational_structure?: string | null
    company_sales?: string | null
    workplace_environment?: string | null
    shareholder?: NullableJsonNullValueInput | InputJsonValue
    related_company?: number | null
    recruitment_personname?: string | null
    memo?: string | null
    business_status?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: string | null
    updated_by?: string | null
  }

  export type EntityDetailCreateOrConnectWithoutEntityInput = {
    where: EntityDetailWhereUniqueInput
    create: XOR<EntityDetailCreateWithoutEntityInput, EntityDetailUncheckedCreateWithoutEntityInput>
  }

  export type EntityDetailCreateManyEntityInputEnvelope = {
    data: Enumerable<EntityDetailCreateManyEntityInput>
    skipDuplicates?: boolean
  }

  export type EntityBranchCreateWithoutEntityInput = {
    branch_name?: string | null
    kana?: string | null
    is_jeadquarter?: boolean
    image?: string | null
    prefecture?: NullableJsonNullValueInput | InputJsonValue
    post_code?: string | null
    city?: string | null
    district?: string | null
    address?: string | null
    address1?: string | null
    nearest_station?: string | null
    socials?: NullableJsonNullValueInput | InputJsonValue
    gps?: NullableJsonNullValueInput | InputJsonValue
    contact_person?: NullableJsonNullValueInput | InputJsonValue
    contact_details?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: string | null
    updated_by?: string | null
    jobs?: JobCreateNestedManyWithoutEntity_branchInput
  }

  export type EntityBranchUncheckedCreateWithoutEntityInput = {
    branch_id?: number
    branch_name?: string | null
    kana?: string | null
    is_jeadquarter?: boolean
    image?: string | null
    prefecture?: NullableJsonNullValueInput | InputJsonValue
    post_code?: string | null
    city?: string | null
    district?: string | null
    address?: string | null
    address1?: string | null
    nearest_station?: string | null
    socials?: NullableJsonNullValueInput | InputJsonValue
    gps?: NullableJsonNullValueInput | InputJsonValue
    contact_person?: NullableJsonNullValueInput | InputJsonValue
    contact_details?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: string | null
    updated_by?: string | null
    jobs?: JobUncheckedCreateNestedManyWithoutEntity_branchInput
  }

  export type EntityBranchCreateOrConnectWithoutEntityInput = {
    where: EntityBranchWhereUniqueInput
    create: XOR<EntityBranchCreateWithoutEntityInput, EntityBranchUncheckedCreateWithoutEntityInput>
  }

  export type EntityBranchCreateManyEntityInputEnvelope = {
    data: Enumerable<EntityBranchCreateManyEntityInput>
    skipDuplicates?: boolean
  }

  export type EntityAccountInfoCreateWithoutEntityInput = {
    entity_accountinfo_id?: string
    bank_code?: string | null
    branch_code?: string | null
    account_id?: string | null
    is_default?: boolean | null
    created_at?: Date | string
    updated_at?: Date | string
    updated_by?: string | null
    created_by?: string | null
  }

  export type EntityAccountInfoUncheckedCreateWithoutEntityInput = {
    entity_accountinfo_id?: string
    bank_code?: string | null
    branch_code?: string | null
    account_id?: string | null
    is_default?: boolean | null
    created_at?: Date | string
    updated_at?: Date | string
    updated_by?: string | null
    created_by?: string | null
  }

  export type EntityAccountInfoCreateOrConnectWithoutEntityInput = {
    where: EntityAccountInfoWhereUniqueInput
    create: XOR<EntityAccountInfoCreateWithoutEntityInput, EntityAccountInfoUncheckedCreateWithoutEntityInput>
  }

  export type EntityAccountInfoCreateManyEntityInputEnvelope = {
    data: Enumerable<EntityAccountInfoCreateManyEntityInput>
    skipDuplicates?: boolean
  }

  export type InquiryCreateWithoutEntityInput = {
    inquire_id?: string
    parent_id?: string | null
    fromuser?: UserCreateNestedOneWithoutFrom_inquiriesInput
    assignUser?: UserCreateNestedOneWithoutAssign_inquiriesInput
    subject: string
    body: string
    inquiry_status?: InquiryStatus | null
    is_read?: boolean
    is_answer?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: string | null
  }

  export type InquiryUncheckedCreateWithoutEntityInput = {
    inquire_id?: string
    parent_id?: string | null
    fromuser_id?: string | null
    assigned_user_id?: string | null
    subject: string
    body: string
    inquiry_status?: InquiryStatus | null
    is_read?: boolean
    is_answer?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: string | null
  }

  export type InquiryCreateOrConnectWithoutEntityInput = {
    where: InquiryWhereUniqueInput
    create: XOR<InquiryCreateWithoutEntityInput, InquiryUncheckedCreateWithoutEntityInput>
  }

  export type InquiryCreateManyEntityInputEnvelope = {
    data: Enumerable<InquiryCreateManyEntityInput>
    skipDuplicates?: boolean
  }

  export type EntityDetailUpsertWithWhereUniqueWithoutEntityInput = {
    where: EntityDetailWhereUniqueInput
    update: XOR<EntityDetailUpdateWithoutEntityInput, EntityDetailUncheckedUpdateWithoutEntityInput>
    create: XOR<EntityDetailCreateWithoutEntityInput, EntityDetailUncheckedCreateWithoutEntityInput>
  }

  export type EntityDetailUpdateWithWhereUniqueWithoutEntityInput = {
    where: EntityDetailWhereUniqueInput
    data: XOR<EntityDetailUpdateWithoutEntityInput, EntityDetailUncheckedUpdateWithoutEntityInput>
  }

  export type EntityDetailUpdateManyWithWhereWithoutEntityInput = {
    where: EntityDetailScalarWhereInput
    data: XOR<EntityDetailUpdateManyMutationInput, EntityDetailUncheckedUpdateManyWithoutEntity_detailsInput>
  }

  export type EntityDetailScalarWhereInput = {
    AND?: Enumerable<EntityDetailScalarWhereInput>
    OR?: Enumerable<EntityDetailScalarWhereInput>
    NOT?: Enumerable<EntityDetailScalarWhereInput>
    entity_detail_id?: StringFilter | string
    entity_id?: IntNullableFilter | number | null
    establishment?: DateTimeNullableFilter | Date | string | null
    capital?: IntNullableFilter | number | null
    numberof_employees?: IntNullableFilter | number | null
    business_performance?: JsonNullableFilter
    representative_telephone?: StringNullableFilter | string | null
    representative?: StringNullableFilter | string | null
    average_age?: IntNullableFilter | number | null
    foreign_capitalratio?: IntNullableFilter | number | null
    homepage?: StringNullableFilter | string | null
    business_summary?: StringNullableFilter | string | null
    organizational_structure?: StringNullableFilter | string | null
    company_sales?: StringNullableFilter | string | null
    workplace_environment?: StringNullableFilter | string | null
    shareholder?: JsonNullableFilter
    related_company?: IntNullableFilter | number | null
    recruitment_personname?: StringNullableFilter | string | null
    memo?: StringNullableFilter | string | null
    business_status?: StringNullableFilter | string | null
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    created_by?: StringNullableFilter | string | null
    updated_by?: StringNullableFilter | string | null
  }

  export type EntityBranchUpsertWithWhereUniqueWithoutEntityInput = {
    where: EntityBranchWhereUniqueInput
    update: XOR<EntityBranchUpdateWithoutEntityInput, EntityBranchUncheckedUpdateWithoutEntityInput>
    create: XOR<EntityBranchCreateWithoutEntityInput, EntityBranchUncheckedCreateWithoutEntityInput>
  }

  export type EntityBranchUpdateWithWhereUniqueWithoutEntityInput = {
    where: EntityBranchWhereUniqueInput
    data: XOR<EntityBranchUpdateWithoutEntityInput, EntityBranchUncheckedUpdateWithoutEntityInput>
  }

  export type EntityBranchUpdateManyWithWhereWithoutEntityInput = {
    where: EntityBranchScalarWhereInput
    data: XOR<EntityBranchUpdateManyMutationInput, EntityBranchUncheckedUpdateManyWithoutEntity_branchesInput>
  }

  export type EntityBranchScalarWhereInput = {
    AND?: Enumerable<EntityBranchScalarWhereInput>
    OR?: Enumerable<EntityBranchScalarWhereInput>
    NOT?: Enumerable<EntityBranchScalarWhereInput>
    branch_id?: IntFilter | number
    branch_name?: StringNullableFilter | string | null
    kana?: StringNullableFilter | string | null
    is_jeadquarter?: BoolFilter | boolean
    image?: StringNullableFilter | string | null
    prefecture?: JsonNullableFilter
    post_code?: StringNullableFilter | string | null
    city?: StringNullableFilter | string | null
    district?: StringNullableFilter | string | null
    address?: StringNullableFilter | string | null
    address1?: StringNullableFilter | string | null
    nearest_station?: StringNullableFilter | string | null
    socials?: JsonNullableFilter
    gps?: JsonNullableFilter
    contact_person?: JsonNullableFilter
    contact_details?: JsonNullableFilter
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    created_by?: StringNullableFilter | string | null
    updated_by?: StringNullableFilter | string | null
    entity_id?: IntFilter | number
  }

  export type EntityAccountInfoUpsertWithWhereUniqueWithoutEntityInput = {
    where: EntityAccountInfoWhereUniqueInput
    update: XOR<EntityAccountInfoUpdateWithoutEntityInput, EntityAccountInfoUncheckedUpdateWithoutEntityInput>
    create: XOR<EntityAccountInfoCreateWithoutEntityInput, EntityAccountInfoUncheckedCreateWithoutEntityInput>
  }

  export type EntityAccountInfoUpdateWithWhereUniqueWithoutEntityInput = {
    where: EntityAccountInfoWhereUniqueInput
    data: XOR<EntityAccountInfoUpdateWithoutEntityInput, EntityAccountInfoUncheckedUpdateWithoutEntityInput>
  }

  export type EntityAccountInfoUpdateManyWithWhereWithoutEntityInput = {
    where: EntityAccountInfoScalarWhereInput
    data: XOR<EntityAccountInfoUpdateManyMutationInput, EntityAccountInfoUncheckedUpdateManyWithoutEntity_accountinfosInput>
  }

  export type EntityAccountInfoScalarWhereInput = {
    AND?: Enumerable<EntityAccountInfoScalarWhereInput>
    OR?: Enumerable<EntityAccountInfoScalarWhereInput>
    NOT?: Enumerable<EntityAccountInfoScalarWhereInput>
    entity_accountinfo_id?: StringFilter | string
    entity_id?: IntNullableFilter | number | null
    bank_code?: StringNullableFilter | string | null
    branch_code?: StringNullableFilter | string | null
    account_id?: StringNullableFilter | string | null
    is_default?: BoolNullableFilter | boolean | null
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    updated_by?: StringNullableFilter | string | null
    created_by?: StringNullableFilter | string | null
  }

  export type InquiryUpsertWithWhereUniqueWithoutEntityInput = {
    where: InquiryWhereUniqueInput
    update: XOR<InquiryUpdateWithoutEntityInput, InquiryUncheckedUpdateWithoutEntityInput>
    create: XOR<InquiryCreateWithoutEntityInput, InquiryUncheckedCreateWithoutEntityInput>
  }

  export type InquiryUpdateWithWhereUniqueWithoutEntityInput = {
    where: InquiryWhereUniqueInput
    data: XOR<InquiryUpdateWithoutEntityInput, InquiryUncheckedUpdateWithoutEntityInput>
  }

  export type InquiryUpdateManyWithWhereWithoutEntityInput = {
    where: InquiryScalarWhereInput
    data: XOR<InquiryUpdateManyMutationInput, InquiryUncheckedUpdateManyWithoutInquiriesInput>
  }

  export type InquiryScalarWhereInput = {
    AND?: Enumerable<InquiryScalarWhereInput>
    OR?: Enumerable<InquiryScalarWhereInput>
    NOT?: Enumerable<InquiryScalarWhereInput>
    inquire_id?: StringFilter | string
    parent_id?: StringNullableFilter | string | null
    fromuser_id?: StringNullableFilter | string | null
    entity_id?: IntNullableFilter | number | null
    assigned_user_id?: StringNullableFilter | string | null
    subject?: StringFilter | string
    body?: StringFilter | string
    inquiry_status?: EnumInquiryStatusNullableFilter | InquiryStatus | null
    is_read?: BoolFilter | boolean
    is_answer?: BoolFilter | boolean
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    created_by?: StringNullableFilter | string | null
  }

  export type EntityCreateWithoutEntity_accountinfosInput = {
    name: string
    kana?: string | null
    logo?: string | null
    socials?: NullableJsonNullValueInput | InputJsonValue
    gps?: NullableJsonNullValueInput | InputJsonValue
    contact_person?: NullableJsonNullValueInput | InputJsonValue
    contact_details?: NullableJsonNullValueInput | InputJsonValue
    is_system?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: string | null
    updated_by?: string | null
    entity_details?: EntityDetailCreateNestedManyWithoutEntityInput
    entity_branches?: EntityBranchCreateNestedManyWithoutEntityInput
    inquiries?: InquiryCreateNestedManyWithoutEntityInput
  }

  export type EntityUncheckedCreateWithoutEntity_accountinfosInput = {
    entity_id?: number
    name: string
    kana?: string | null
    logo?: string | null
    socials?: NullableJsonNullValueInput | InputJsonValue
    gps?: NullableJsonNullValueInput | InputJsonValue
    contact_person?: NullableJsonNullValueInput | InputJsonValue
    contact_details?: NullableJsonNullValueInput | InputJsonValue
    is_system?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: string | null
    updated_by?: string | null
    entity_details?: EntityDetailUncheckedCreateNestedManyWithoutEntityInput
    entity_branches?: EntityBranchUncheckedCreateNestedManyWithoutEntityInput
    inquiries?: InquiryUncheckedCreateNestedManyWithoutEntityInput
  }

  export type EntityCreateOrConnectWithoutEntity_accountinfosInput = {
    where: EntityWhereUniqueInput
    create: XOR<EntityCreateWithoutEntity_accountinfosInput, EntityUncheckedCreateWithoutEntity_accountinfosInput>
  }

  export type EntityUpsertWithoutEntity_accountinfosInput = {
    update: XOR<EntityUpdateWithoutEntity_accountinfosInput, EntityUncheckedUpdateWithoutEntity_accountinfosInput>
    create: XOR<EntityCreateWithoutEntity_accountinfosInput, EntityUncheckedCreateWithoutEntity_accountinfosInput>
  }

  export type EntityUpdateWithoutEntity_accountinfosInput = {
    name?: StringFieldUpdateOperationsInput | string
    kana?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    socials?: NullableJsonNullValueInput | InputJsonValue
    gps?: NullableJsonNullValueInput | InputJsonValue
    contact_person?: NullableJsonNullValueInput | InputJsonValue
    contact_details?: NullableJsonNullValueInput | InputJsonValue
    is_system?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    entity_details?: EntityDetailUpdateManyWithoutEntityNestedInput
    entity_branches?: EntityBranchUpdateManyWithoutEntityNestedInput
    inquiries?: InquiryUpdateManyWithoutEntityNestedInput
  }

  export type EntityUncheckedUpdateWithoutEntity_accountinfosInput = {
    entity_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    kana?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    socials?: NullableJsonNullValueInput | InputJsonValue
    gps?: NullableJsonNullValueInput | InputJsonValue
    contact_person?: NullableJsonNullValueInput | InputJsonValue
    contact_details?: NullableJsonNullValueInput | InputJsonValue
    is_system?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    entity_details?: EntityDetailUncheckedUpdateManyWithoutEntityNestedInput
    entity_branches?: EntityBranchUncheckedUpdateManyWithoutEntityNestedInput
    inquiries?: InquiryUncheckedUpdateManyWithoutEntityNestedInput
  }

  export type EntityCreateWithoutEntity_branchesInput = {
    name: string
    kana?: string | null
    logo?: string | null
    socials?: NullableJsonNullValueInput | InputJsonValue
    gps?: NullableJsonNullValueInput | InputJsonValue
    contact_person?: NullableJsonNullValueInput | InputJsonValue
    contact_details?: NullableJsonNullValueInput | InputJsonValue
    is_system?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: string | null
    updated_by?: string | null
    entity_details?: EntityDetailCreateNestedManyWithoutEntityInput
    entity_accountinfos?: EntityAccountInfoCreateNestedManyWithoutEntityInput
    inquiries?: InquiryCreateNestedManyWithoutEntityInput
  }

  export type EntityUncheckedCreateWithoutEntity_branchesInput = {
    entity_id?: number
    name: string
    kana?: string | null
    logo?: string | null
    socials?: NullableJsonNullValueInput | InputJsonValue
    gps?: NullableJsonNullValueInput | InputJsonValue
    contact_person?: NullableJsonNullValueInput | InputJsonValue
    contact_details?: NullableJsonNullValueInput | InputJsonValue
    is_system?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: string | null
    updated_by?: string | null
    entity_details?: EntityDetailUncheckedCreateNestedManyWithoutEntityInput
    entity_accountinfos?: EntityAccountInfoUncheckedCreateNestedManyWithoutEntityInput
    inquiries?: InquiryUncheckedCreateNestedManyWithoutEntityInput
  }

  export type EntityCreateOrConnectWithoutEntity_branchesInput = {
    where: EntityWhereUniqueInput
    create: XOR<EntityCreateWithoutEntity_branchesInput, EntityUncheckedCreateWithoutEntity_branchesInput>
  }

  export type JobCreateWithoutEntity_branchInput = {
    job_id?: string
    created_at?: Date | string
    updated_at?: Date | string
    created_by: string
    updated_by?: string | null
    job_publish: JobPublish
    job_references?: JobReferenceListCreateNestedManyWithoutJobInput
    location_details?: string | null
    career_level?: JobCreatecareer_levelInput | Enumerable<JobPosition>
    benefit_other?: string | null
    smoke?: JobCreatesmokeInput | Enumerable<Smoke>
    employment_status: EmploymentStatus
    japanese_level: LanguageLevel
    english_level: LanguageLevel
    job_other_languages?: JobOtherLanguageCreateNestedManyWithoutJobInput
    experienced_count: number
    age_min?: number | null
    age_max?: number | null
    set_age_reason?: string | null
    recruitment_type?: ReqriutmentType | null
    job_title: string
    job_description: string
    japanese_percentage?: number | null
    must_condition: string
    want_condition?: string | null
    position_name?: string | null
    working_hour: string
    salary_type: SalaryType
    salary_min?: number | null
    salary_max?: number | null
    salary_detail: string
    day_off?: string | null
    progress_detail: string
    expire_date?: Date | string | null
    job_candidates?: JobCandidateCreateNestedManyWithoutJobInput
    JobRequirement?: JobRequirementCreateNestedManyWithoutJobsInput
  }

  export type JobUncheckedCreateWithoutEntity_branchInput = {
    job_id?: string
    created_at?: Date | string
    updated_at?: Date | string
    created_by: string
    updated_by?: string | null
    job_publish: JobPublish
    job_references?: JobReferenceListUncheckedCreateNestedManyWithoutJobInput
    location_details?: string | null
    career_level?: JobCreatecareer_levelInput | Enumerable<JobPosition>
    benefit_other?: string | null
    smoke?: JobCreatesmokeInput | Enumerable<Smoke>
    employment_status: EmploymentStatus
    japanese_level: LanguageLevel
    english_level: LanguageLevel
    job_other_languages?: JobOtherLanguageUncheckedCreateNestedManyWithoutJobInput
    experienced_count: number
    age_min?: number | null
    age_max?: number | null
    set_age_reason?: string | null
    recruitment_type?: ReqriutmentType | null
    job_title: string
    job_description: string
    japanese_percentage?: number | null
    must_condition: string
    want_condition?: string | null
    position_name?: string | null
    working_hour: string
    salary_type: SalaryType
    salary_min?: number | null
    salary_max?: number | null
    salary_detail: string
    day_off?: string | null
    progress_detail: string
    expire_date?: Date | string | null
    job_candidates?: JobCandidateUncheckedCreateNestedManyWithoutJobInput
    JobRequirement?: JobRequirementUncheckedCreateNestedManyWithoutJobsInput
  }

  export type JobCreateOrConnectWithoutEntity_branchInput = {
    where: JobWhereUniqueInput
    create: XOR<JobCreateWithoutEntity_branchInput, JobUncheckedCreateWithoutEntity_branchInput>
  }

  export type JobCreateManyEntity_branchInputEnvelope = {
    data: Enumerable<JobCreateManyEntity_branchInput>
    skipDuplicates?: boolean
  }

  export type EntityUpsertWithoutEntity_branchesInput = {
    update: XOR<EntityUpdateWithoutEntity_branchesInput, EntityUncheckedUpdateWithoutEntity_branchesInput>
    create: XOR<EntityCreateWithoutEntity_branchesInput, EntityUncheckedCreateWithoutEntity_branchesInput>
  }

  export type EntityUpdateWithoutEntity_branchesInput = {
    name?: StringFieldUpdateOperationsInput | string
    kana?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    socials?: NullableJsonNullValueInput | InputJsonValue
    gps?: NullableJsonNullValueInput | InputJsonValue
    contact_person?: NullableJsonNullValueInput | InputJsonValue
    contact_details?: NullableJsonNullValueInput | InputJsonValue
    is_system?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    entity_details?: EntityDetailUpdateManyWithoutEntityNestedInput
    entity_accountinfos?: EntityAccountInfoUpdateManyWithoutEntityNestedInput
    inquiries?: InquiryUpdateManyWithoutEntityNestedInput
  }

  export type EntityUncheckedUpdateWithoutEntity_branchesInput = {
    entity_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    kana?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    socials?: NullableJsonNullValueInput | InputJsonValue
    gps?: NullableJsonNullValueInput | InputJsonValue
    contact_person?: NullableJsonNullValueInput | InputJsonValue
    contact_details?: NullableJsonNullValueInput | InputJsonValue
    is_system?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    entity_details?: EntityDetailUncheckedUpdateManyWithoutEntityNestedInput
    entity_accountinfos?: EntityAccountInfoUncheckedUpdateManyWithoutEntityNestedInput
    inquiries?: InquiryUncheckedUpdateManyWithoutEntityNestedInput
  }

  export type JobUpsertWithWhereUniqueWithoutEntity_branchInput = {
    where: JobWhereUniqueInput
    update: XOR<JobUpdateWithoutEntity_branchInput, JobUncheckedUpdateWithoutEntity_branchInput>
    create: XOR<JobCreateWithoutEntity_branchInput, JobUncheckedCreateWithoutEntity_branchInput>
  }

  export type JobUpdateWithWhereUniqueWithoutEntity_branchInput = {
    where: JobWhereUniqueInput
    data: XOR<JobUpdateWithoutEntity_branchInput, JobUncheckedUpdateWithoutEntity_branchInput>
  }

  export type JobUpdateManyWithWhereWithoutEntity_branchInput = {
    where: JobScalarWhereInput
    data: XOR<JobUpdateManyMutationInput, JobUncheckedUpdateManyWithoutJobsInput>
  }

  export type JobScalarWhereInput = {
    AND?: Enumerable<JobScalarWhereInput>
    OR?: Enumerable<JobScalarWhereInput>
    NOT?: Enumerable<JobScalarWhereInput>
    job_id?: StringFilter | string
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    created_by?: StringFilter | string
    updated_by?: StringNullableFilter | string | null
    job_publish?: EnumJobPublishFilter | JobPublish
    location_details?: StringNullableFilter | string | null
    career_level?: EnumJobPositionNullableListFilter
    benefit_other?: StringNullableFilter | string | null
    smoke?: EnumSmokeNullableListFilter
    employment_status?: EnumEmploymentStatusFilter | EmploymentStatus
    japanese_level?: EnumLanguageLevelFilter | LanguageLevel
    english_level?: EnumLanguageLevelFilter | LanguageLevel
    experienced_count?: IntFilter | number
    age_min?: IntNullableFilter | number | null
    age_max?: IntNullableFilter | number | null
    set_age_reason?: StringNullableFilter | string | null
    recruitment_type?: EnumReqriutmentTypeNullableFilter | ReqriutmentType | null
    job_title?: StringFilter | string
    job_description?: StringFilter | string
    japanese_percentage?: IntNullableFilter | number | null
    must_condition?: StringFilter | string
    want_condition?: StringNullableFilter | string | null
    position_name?: StringNullableFilter | string | null
    working_hour?: StringFilter | string
    salary_type?: EnumSalaryTypeFilter | SalaryType
    salary_min?: IntNullableFilter | number | null
    salary_max?: IntNullableFilter | number | null
    salary_detail?: StringFilter | string
    day_off?: StringNullableFilter | string | null
    progress_detail?: StringFilter | string
    entity_branch_id?: IntFilter | number
    expire_date?: DateTimeNullableFilter | Date | string | null
  }

  export type EntityCreateWithoutEntity_detailsInput = {
    name: string
    kana?: string | null
    logo?: string | null
    socials?: NullableJsonNullValueInput | InputJsonValue
    gps?: NullableJsonNullValueInput | InputJsonValue
    contact_person?: NullableJsonNullValueInput | InputJsonValue
    contact_details?: NullableJsonNullValueInput | InputJsonValue
    is_system?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: string | null
    updated_by?: string | null
    entity_branches?: EntityBranchCreateNestedManyWithoutEntityInput
    entity_accountinfos?: EntityAccountInfoCreateNestedManyWithoutEntityInput
    inquiries?: InquiryCreateNestedManyWithoutEntityInput
  }

  export type EntityUncheckedCreateWithoutEntity_detailsInput = {
    entity_id?: number
    name: string
    kana?: string | null
    logo?: string | null
    socials?: NullableJsonNullValueInput | InputJsonValue
    gps?: NullableJsonNullValueInput | InputJsonValue
    contact_person?: NullableJsonNullValueInput | InputJsonValue
    contact_details?: NullableJsonNullValueInput | InputJsonValue
    is_system?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: string | null
    updated_by?: string | null
    entity_branches?: EntityBranchUncheckedCreateNestedManyWithoutEntityInput
    entity_accountinfos?: EntityAccountInfoUncheckedCreateNestedManyWithoutEntityInput
    inquiries?: InquiryUncheckedCreateNestedManyWithoutEntityInput
  }

  export type EntityCreateOrConnectWithoutEntity_detailsInput = {
    where: EntityWhereUniqueInput
    create: XOR<EntityCreateWithoutEntity_detailsInput, EntityUncheckedCreateWithoutEntity_detailsInput>
  }

  export type EntityUpsertWithoutEntity_detailsInput = {
    update: XOR<EntityUpdateWithoutEntity_detailsInput, EntityUncheckedUpdateWithoutEntity_detailsInput>
    create: XOR<EntityCreateWithoutEntity_detailsInput, EntityUncheckedCreateWithoutEntity_detailsInput>
  }

  export type EntityUpdateWithoutEntity_detailsInput = {
    name?: StringFieldUpdateOperationsInput | string
    kana?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    socials?: NullableJsonNullValueInput | InputJsonValue
    gps?: NullableJsonNullValueInput | InputJsonValue
    contact_person?: NullableJsonNullValueInput | InputJsonValue
    contact_details?: NullableJsonNullValueInput | InputJsonValue
    is_system?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    entity_branches?: EntityBranchUpdateManyWithoutEntityNestedInput
    entity_accountinfos?: EntityAccountInfoUpdateManyWithoutEntityNestedInput
    inquiries?: InquiryUpdateManyWithoutEntityNestedInput
  }

  export type EntityUncheckedUpdateWithoutEntity_detailsInput = {
    entity_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    kana?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    socials?: NullableJsonNullValueInput | InputJsonValue
    gps?: NullableJsonNullValueInput | InputJsonValue
    contact_person?: NullableJsonNullValueInput | InputJsonValue
    contact_details?: NullableJsonNullValueInput | InputJsonValue
    is_system?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    entity_branches?: EntityBranchUncheckedUpdateManyWithoutEntityNestedInput
    entity_accountinfos?: EntityAccountInfoUncheckedUpdateManyWithoutEntityNestedInput
    inquiries?: InquiryUncheckedUpdateManyWithoutEntityNestedInput
  }

  export type UserCreateWithoutFrom_inquiriesInput = {
    user_id?: string
    email: string
    mobile?: string | null
    name?: string | null
    password_hash: string
    role?: UserRole
    company_id?: number
    attemptpass_count?: number | null
    reset_code?: string
    is_emailverified?: boolean
    is_mobileverified?: boolean
    user_status?: UserStatus
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    favs: JsonNullValueInput | InputJsonValue
    Customer?: CustomerCreateNestedOneWithoutUserInput
    loggers?: LoggerCreateNestedManyWithoutUserInput
    assign_inquiries?: InquiryCreateNestedManyWithoutAssignUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    ScoutFav?: ScoutFavCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutFrom_inquiriesInput = {
    user_id?: string
    email: string
    mobile?: string | null
    name?: string | null
    password_hash: string
    role?: UserRole
    company_id?: number
    customer_id?: string | null
    attemptpass_count?: number | null
    reset_code?: string
    is_emailverified?: boolean
    is_mobileverified?: boolean
    user_status?: UserStatus
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    favs: JsonNullValueInput | InputJsonValue
    loggers?: LoggerUncheckedCreateNestedManyWithoutUserInput
    assign_inquiries?: InquiryUncheckedCreateNestedManyWithoutAssignUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    ScoutFav?: ScoutFavUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutFrom_inquiriesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutFrom_inquiriesInput, UserUncheckedCreateWithoutFrom_inquiriesInput>
  }

  export type EntityCreateWithoutInquiriesInput = {
    name: string
    kana?: string | null
    logo?: string | null
    socials?: NullableJsonNullValueInput | InputJsonValue
    gps?: NullableJsonNullValueInput | InputJsonValue
    contact_person?: NullableJsonNullValueInput | InputJsonValue
    contact_details?: NullableJsonNullValueInput | InputJsonValue
    is_system?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: string | null
    updated_by?: string | null
    entity_details?: EntityDetailCreateNestedManyWithoutEntityInput
    entity_branches?: EntityBranchCreateNestedManyWithoutEntityInput
    entity_accountinfos?: EntityAccountInfoCreateNestedManyWithoutEntityInput
  }

  export type EntityUncheckedCreateWithoutInquiriesInput = {
    entity_id?: number
    name: string
    kana?: string | null
    logo?: string | null
    socials?: NullableJsonNullValueInput | InputJsonValue
    gps?: NullableJsonNullValueInput | InputJsonValue
    contact_person?: NullableJsonNullValueInput | InputJsonValue
    contact_details?: NullableJsonNullValueInput | InputJsonValue
    is_system?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: string | null
    updated_by?: string | null
    entity_details?: EntityDetailUncheckedCreateNestedManyWithoutEntityInput
    entity_branches?: EntityBranchUncheckedCreateNestedManyWithoutEntityInput
    entity_accountinfos?: EntityAccountInfoUncheckedCreateNestedManyWithoutEntityInput
  }

  export type EntityCreateOrConnectWithoutInquiriesInput = {
    where: EntityWhereUniqueInput
    create: XOR<EntityCreateWithoutInquiriesInput, EntityUncheckedCreateWithoutInquiriesInput>
  }

  export type UserCreateWithoutAssign_inquiriesInput = {
    user_id?: string
    email: string
    mobile?: string | null
    name?: string | null
    password_hash: string
    role?: UserRole
    company_id?: number
    attemptpass_count?: number | null
    reset_code?: string
    is_emailverified?: boolean
    is_mobileverified?: boolean
    user_status?: UserStatus
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    favs: JsonNullValueInput | InputJsonValue
    Customer?: CustomerCreateNestedOneWithoutUserInput
    loggers?: LoggerCreateNestedManyWithoutUserInput
    from_inquiries?: InquiryCreateNestedManyWithoutFromuserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    ScoutFav?: ScoutFavCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAssign_inquiriesInput = {
    user_id?: string
    email: string
    mobile?: string | null
    name?: string | null
    password_hash: string
    role?: UserRole
    company_id?: number
    customer_id?: string | null
    attemptpass_count?: number | null
    reset_code?: string
    is_emailverified?: boolean
    is_mobileverified?: boolean
    user_status?: UserStatus
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    favs: JsonNullValueInput | InputJsonValue
    loggers?: LoggerUncheckedCreateNestedManyWithoutUserInput
    from_inquiries?: InquiryUncheckedCreateNestedManyWithoutFromuserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    ScoutFav?: ScoutFavUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAssign_inquiriesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAssign_inquiriesInput, UserUncheckedCreateWithoutAssign_inquiriesInput>
  }

  export type UserUpsertWithoutFrom_inquiriesInput = {
    update: XOR<UserUpdateWithoutFrom_inquiriesInput, UserUncheckedUpdateWithoutFrom_inquiriesInput>
    create: XOR<UserCreateWithoutFrom_inquiriesInput, UserUncheckedCreateWithoutFrom_inquiriesInput>
  }

  export type UserUpdateWithoutFrom_inquiriesInput = {
    user_id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | UserRole
    company_id?: IntFieldUpdateOperationsInput | number
    attemptpass_count?: NullableIntFieldUpdateOperationsInput | number | null
    reset_code?: StringFieldUpdateOperationsInput | string
    is_emailverified?: BoolFieldUpdateOperationsInput | boolean
    is_mobileverified?: BoolFieldUpdateOperationsInput | boolean
    user_status?: EnumUserStatusFieldUpdateOperationsInput | UserStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    favs?: JsonNullValueInput | InputJsonValue
    Customer?: CustomerUpdateOneWithoutUserNestedInput
    loggers?: LoggerUpdateManyWithoutUserNestedInput
    assign_inquiries?: InquiryUpdateManyWithoutAssignUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    ScoutFav?: ScoutFavUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutFrom_inquiriesInput = {
    user_id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | UserRole
    company_id?: IntFieldUpdateOperationsInput | number
    customer_id?: NullableStringFieldUpdateOperationsInput | string | null
    attemptpass_count?: NullableIntFieldUpdateOperationsInput | number | null
    reset_code?: StringFieldUpdateOperationsInput | string
    is_emailverified?: BoolFieldUpdateOperationsInput | boolean
    is_mobileverified?: BoolFieldUpdateOperationsInput | boolean
    user_status?: EnumUserStatusFieldUpdateOperationsInput | UserStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    favs?: JsonNullValueInput | InputJsonValue
    loggers?: LoggerUncheckedUpdateManyWithoutUserNestedInput
    assign_inquiries?: InquiryUncheckedUpdateManyWithoutAssignUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    ScoutFav?: ScoutFavUncheckedUpdateManyWithoutUserNestedInput
  }

  export type EntityUpsertWithoutInquiriesInput = {
    update: XOR<EntityUpdateWithoutInquiriesInput, EntityUncheckedUpdateWithoutInquiriesInput>
    create: XOR<EntityCreateWithoutInquiriesInput, EntityUncheckedCreateWithoutInquiriesInput>
  }

  export type EntityUpdateWithoutInquiriesInput = {
    name?: StringFieldUpdateOperationsInput | string
    kana?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    socials?: NullableJsonNullValueInput | InputJsonValue
    gps?: NullableJsonNullValueInput | InputJsonValue
    contact_person?: NullableJsonNullValueInput | InputJsonValue
    contact_details?: NullableJsonNullValueInput | InputJsonValue
    is_system?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    entity_details?: EntityDetailUpdateManyWithoutEntityNestedInput
    entity_branches?: EntityBranchUpdateManyWithoutEntityNestedInput
    entity_accountinfos?: EntityAccountInfoUpdateManyWithoutEntityNestedInput
  }

  export type EntityUncheckedUpdateWithoutInquiriesInput = {
    entity_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    kana?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    socials?: NullableJsonNullValueInput | InputJsonValue
    gps?: NullableJsonNullValueInput | InputJsonValue
    contact_person?: NullableJsonNullValueInput | InputJsonValue
    contact_details?: NullableJsonNullValueInput | InputJsonValue
    is_system?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    entity_details?: EntityDetailUncheckedUpdateManyWithoutEntityNestedInput
    entity_branches?: EntityBranchUncheckedUpdateManyWithoutEntityNestedInput
    entity_accountinfos?: EntityAccountInfoUncheckedUpdateManyWithoutEntityNestedInput
  }

  export type UserUpsertWithoutAssign_inquiriesInput = {
    update: XOR<UserUpdateWithoutAssign_inquiriesInput, UserUncheckedUpdateWithoutAssign_inquiriesInput>
    create: XOR<UserCreateWithoutAssign_inquiriesInput, UserUncheckedCreateWithoutAssign_inquiriesInput>
  }

  export type UserUpdateWithoutAssign_inquiriesInput = {
    user_id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | UserRole
    company_id?: IntFieldUpdateOperationsInput | number
    attemptpass_count?: NullableIntFieldUpdateOperationsInput | number | null
    reset_code?: StringFieldUpdateOperationsInput | string
    is_emailverified?: BoolFieldUpdateOperationsInput | boolean
    is_mobileverified?: BoolFieldUpdateOperationsInput | boolean
    user_status?: EnumUserStatusFieldUpdateOperationsInput | UserStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    favs?: JsonNullValueInput | InputJsonValue
    Customer?: CustomerUpdateOneWithoutUserNestedInput
    loggers?: LoggerUpdateManyWithoutUserNestedInput
    from_inquiries?: InquiryUpdateManyWithoutFromuserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    ScoutFav?: ScoutFavUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAssign_inquiriesInput = {
    user_id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | UserRole
    company_id?: IntFieldUpdateOperationsInput | number
    customer_id?: NullableStringFieldUpdateOperationsInput | string | null
    attemptpass_count?: NullableIntFieldUpdateOperationsInput | number | null
    reset_code?: StringFieldUpdateOperationsInput | string
    is_emailverified?: BoolFieldUpdateOperationsInput | boolean
    is_mobileverified?: BoolFieldUpdateOperationsInput | boolean
    user_status?: EnumUserStatusFieldUpdateOperationsInput | UserStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    favs?: JsonNullValueInput | InputJsonValue
    loggers?: LoggerUncheckedUpdateManyWithoutUserNestedInput
    from_inquiries?: InquiryUncheckedUpdateManyWithoutFromuserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    ScoutFav?: ScoutFavUncheckedUpdateManyWithoutUserNestedInput
  }

  export type JobReferenceListCreateWithoutJobInput = {
    job_reference_id?: string
    reference_list: ReferenceListCreateNestedOneWithoutJobReferenceListInput
    reference_list_item: ReferenceListItemsCreateNestedOneWithoutJobReferenceListInput
  }

  export type JobReferenceListUncheckedCreateWithoutJobInput = {
    job_reference_id?: string
    reference_list_id: number
    reference_list_item_id: number
  }

  export type JobReferenceListCreateOrConnectWithoutJobInput = {
    where: JobReferenceListWhereUniqueInput
    create: XOR<JobReferenceListCreateWithoutJobInput, JobReferenceListUncheckedCreateWithoutJobInput>
  }

  export type JobReferenceListCreateManyJobInputEnvelope = {
    data: Enumerable<JobReferenceListCreateManyJobInput>
    skipDuplicates?: boolean
  }

  export type JobOtherLanguageCreateWithoutJobInput = {
    job_other_language_id?: string
    language_id: number
    language_level: LanguageLevel
  }

  export type JobOtherLanguageUncheckedCreateWithoutJobInput = {
    job_other_language_id?: string
    language_id: number
    language_level: LanguageLevel
  }

  export type JobOtherLanguageCreateOrConnectWithoutJobInput = {
    where: JobOtherLanguageWhereUniqueInput
    create: XOR<JobOtherLanguageCreateWithoutJobInput, JobOtherLanguageUncheckedCreateWithoutJobInput>
  }

  export type JobOtherLanguageCreateManyJobInputEnvelope = {
    data: Enumerable<JobOtherLanguageCreateManyJobInput>
    skipDuplicates?: boolean
  }

  export type EntityBranchCreateWithoutJobsInput = {
    branch_name?: string | null
    kana?: string | null
    is_jeadquarter?: boolean
    image?: string | null
    prefecture?: NullableJsonNullValueInput | InputJsonValue
    post_code?: string | null
    city?: string | null
    district?: string | null
    address?: string | null
    address1?: string | null
    nearest_station?: string | null
    socials?: NullableJsonNullValueInput | InputJsonValue
    gps?: NullableJsonNullValueInput | InputJsonValue
    contact_person?: NullableJsonNullValueInput | InputJsonValue
    contact_details?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: string | null
    updated_by?: string | null
    entity: EntityCreateNestedOneWithoutEntity_branchesInput
  }

  export type EntityBranchUncheckedCreateWithoutJobsInput = {
    branch_id?: number
    branch_name?: string | null
    kana?: string | null
    is_jeadquarter?: boolean
    image?: string | null
    prefecture?: NullableJsonNullValueInput | InputJsonValue
    post_code?: string | null
    city?: string | null
    district?: string | null
    address?: string | null
    address1?: string | null
    nearest_station?: string | null
    socials?: NullableJsonNullValueInput | InputJsonValue
    gps?: NullableJsonNullValueInput | InputJsonValue
    contact_person?: NullableJsonNullValueInput | InputJsonValue
    contact_details?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: string | null
    updated_by?: string | null
    entity_id: number
  }

  export type EntityBranchCreateOrConnectWithoutJobsInput = {
    where: EntityBranchWhereUniqueInput
    create: XOR<EntityBranchCreateWithoutJobsInput, EntityBranchUncheckedCreateWithoutJobsInput>
  }

  export type JobCandidateCreateWithoutJobInput = {
    job_candidate_id?: string
    customer: CustomerCreateNestedOneWithoutJob_candidatesInput
    candidate_status: number
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: string | null
    updated_by?: string | null
  }

  export type JobCandidateUncheckedCreateWithoutJobInput = {
    job_candidate_id?: string
    customer_id: string
    candidate_status: number
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: string | null
    updated_by?: string | null
  }

  export type JobCandidateCreateOrConnectWithoutJobInput = {
    where: JobCandidateWhereUniqueInput
    create: XOR<JobCandidateCreateWithoutJobInput, JobCandidateUncheckedCreateWithoutJobInput>
  }

  export type JobCandidateCreateManyJobInputEnvelope = {
    data: Enumerable<JobCandidateCreateManyJobInput>
    skipDuplicates?: boolean
  }

  export type JobRequirementCreateWithoutJobsInput = {
    job_require_id?: string
    require_id: number
    require_detial?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: string | null
    updated_by?: string | null
  }

  export type JobRequirementUncheckedCreateWithoutJobsInput = {
    job_require_id?: string
    require_id: number
    require_detial?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: string | null
    updated_by?: string | null
  }

  export type JobRequirementCreateOrConnectWithoutJobsInput = {
    where: JobRequirementWhereUniqueInput
    create: XOR<JobRequirementCreateWithoutJobsInput, JobRequirementUncheckedCreateWithoutJobsInput>
  }

  export type JobRequirementCreateManyJobsInputEnvelope = {
    data: Enumerable<JobRequirementCreateManyJobsInput>
    skipDuplicates?: boolean
  }

  export type JobReferenceListUpsertWithWhereUniqueWithoutJobInput = {
    where: JobReferenceListWhereUniqueInput
    update: XOR<JobReferenceListUpdateWithoutJobInput, JobReferenceListUncheckedUpdateWithoutJobInput>
    create: XOR<JobReferenceListCreateWithoutJobInput, JobReferenceListUncheckedCreateWithoutJobInput>
  }

  export type JobReferenceListUpdateWithWhereUniqueWithoutJobInput = {
    where: JobReferenceListWhereUniqueInput
    data: XOR<JobReferenceListUpdateWithoutJobInput, JobReferenceListUncheckedUpdateWithoutJobInput>
  }

  export type JobReferenceListUpdateManyWithWhereWithoutJobInput = {
    where: JobReferenceListScalarWhereInput
    data: XOR<JobReferenceListUpdateManyMutationInput, JobReferenceListUncheckedUpdateManyWithoutJob_referencesInput>
  }

  export type JobReferenceListScalarWhereInput = {
    AND?: Enumerable<JobReferenceListScalarWhereInput>
    OR?: Enumerable<JobReferenceListScalarWhereInput>
    NOT?: Enumerable<JobReferenceListScalarWhereInput>
    job_reference_id?: StringFilter | string
    job_id?: StringFilter | string
    reference_list_id?: IntFilter | number
    reference_list_item_id?: IntFilter | number
  }

  export type JobOtherLanguageUpsertWithWhereUniqueWithoutJobInput = {
    where: JobOtherLanguageWhereUniqueInput
    update: XOR<JobOtherLanguageUpdateWithoutJobInput, JobOtherLanguageUncheckedUpdateWithoutJobInput>
    create: XOR<JobOtherLanguageCreateWithoutJobInput, JobOtherLanguageUncheckedCreateWithoutJobInput>
  }

  export type JobOtherLanguageUpdateWithWhereUniqueWithoutJobInput = {
    where: JobOtherLanguageWhereUniqueInput
    data: XOR<JobOtherLanguageUpdateWithoutJobInput, JobOtherLanguageUncheckedUpdateWithoutJobInput>
  }

  export type JobOtherLanguageUpdateManyWithWhereWithoutJobInput = {
    where: JobOtherLanguageScalarWhereInput
    data: XOR<JobOtherLanguageUpdateManyMutationInput, JobOtherLanguageUncheckedUpdateManyWithoutJob_other_languagesInput>
  }

  export type JobOtherLanguageScalarWhereInput = {
    AND?: Enumerable<JobOtherLanguageScalarWhereInput>
    OR?: Enumerable<JobOtherLanguageScalarWhereInput>
    NOT?: Enumerable<JobOtherLanguageScalarWhereInput>
    job_other_language_id?: StringFilter | string
    language_id?: IntFilter | number
    language_level?: EnumLanguageLevelFilter | LanguageLevel
    job_id?: StringFilter | string
  }

  export type EntityBranchUpsertWithoutJobsInput = {
    update: XOR<EntityBranchUpdateWithoutJobsInput, EntityBranchUncheckedUpdateWithoutJobsInput>
    create: XOR<EntityBranchCreateWithoutJobsInput, EntityBranchUncheckedCreateWithoutJobsInput>
  }

  export type EntityBranchUpdateWithoutJobsInput = {
    branch_name?: NullableStringFieldUpdateOperationsInput | string | null
    kana?: NullableStringFieldUpdateOperationsInput | string | null
    is_jeadquarter?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    prefecture?: NullableJsonNullValueInput | InputJsonValue
    post_code?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    address1?: NullableStringFieldUpdateOperationsInput | string | null
    nearest_station?: NullableStringFieldUpdateOperationsInput | string | null
    socials?: NullableJsonNullValueInput | InputJsonValue
    gps?: NullableJsonNullValueInput | InputJsonValue
    contact_person?: NullableJsonNullValueInput | InputJsonValue
    contact_details?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    entity?: EntityUpdateOneRequiredWithoutEntity_branchesNestedInput
  }

  export type EntityBranchUncheckedUpdateWithoutJobsInput = {
    branch_id?: IntFieldUpdateOperationsInput | number
    branch_name?: NullableStringFieldUpdateOperationsInput | string | null
    kana?: NullableStringFieldUpdateOperationsInput | string | null
    is_jeadquarter?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    prefecture?: NullableJsonNullValueInput | InputJsonValue
    post_code?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    address1?: NullableStringFieldUpdateOperationsInput | string | null
    nearest_station?: NullableStringFieldUpdateOperationsInput | string | null
    socials?: NullableJsonNullValueInput | InputJsonValue
    gps?: NullableJsonNullValueInput | InputJsonValue
    contact_person?: NullableJsonNullValueInput | InputJsonValue
    contact_details?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    entity_id?: IntFieldUpdateOperationsInput | number
  }

  export type JobCandidateUpsertWithWhereUniqueWithoutJobInput = {
    where: JobCandidateWhereUniqueInput
    update: XOR<JobCandidateUpdateWithoutJobInput, JobCandidateUncheckedUpdateWithoutJobInput>
    create: XOR<JobCandidateCreateWithoutJobInput, JobCandidateUncheckedCreateWithoutJobInput>
  }

  export type JobCandidateUpdateWithWhereUniqueWithoutJobInput = {
    where: JobCandidateWhereUniqueInput
    data: XOR<JobCandidateUpdateWithoutJobInput, JobCandidateUncheckedUpdateWithoutJobInput>
  }

  export type JobCandidateUpdateManyWithWhereWithoutJobInput = {
    where: JobCandidateScalarWhereInput
    data: XOR<JobCandidateUpdateManyMutationInput, JobCandidateUncheckedUpdateManyWithoutJob_candidatesInput>
  }

  export type JobRequirementUpsertWithWhereUniqueWithoutJobsInput = {
    where: JobRequirementWhereUniqueInput
    update: XOR<JobRequirementUpdateWithoutJobsInput, JobRequirementUncheckedUpdateWithoutJobsInput>
    create: XOR<JobRequirementCreateWithoutJobsInput, JobRequirementUncheckedCreateWithoutJobsInput>
  }

  export type JobRequirementUpdateWithWhereUniqueWithoutJobsInput = {
    where: JobRequirementWhereUniqueInput
    data: XOR<JobRequirementUpdateWithoutJobsInput, JobRequirementUncheckedUpdateWithoutJobsInput>
  }

  export type JobRequirementUpdateManyWithWhereWithoutJobsInput = {
    where: JobRequirementScalarWhereInput
    data: XOR<JobRequirementUpdateManyMutationInput, JobRequirementUncheckedUpdateManyWithoutJobRequirementInput>
  }

  export type JobRequirementScalarWhereInput = {
    AND?: Enumerable<JobRequirementScalarWhereInput>
    OR?: Enumerable<JobRequirementScalarWhereInput>
    NOT?: Enumerable<JobRequirementScalarWhereInput>
    job_require_id?: StringFilter | string
    job_id?: StringFilter | string
    require_id?: IntFilter | number
    require_detial?: JsonNullableFilter
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    created_by?: StringNullableFilter | string | null
    updated_by?: StringNullableFilter | string | null
  }

  export type JobCreateWithoutJob_other_languagesInput = {
    job_id?: string
    created_at?: Date | string
    updated_at?: Date | string
    created_by: string
    updated_by?: string | null
    job_publish: JobPublish
    job_references?: JobReferenceListCreateNestedManyWithoutJobInput
    location_details?: string | null
    career_level?: JobCreatecareer_levelInput | Enumerable<JobPosition>
    benefit_other?: string | null
    smoke?: JobCreatesmokeInput | Enumerable<Smoke>
    employment_status: EmploymentStatus
    japanese_level: LanguageLevel
    english_level: LanguageLevel
    experienced_count: number
    age_min?: number | null
    age_max?: number | null
    set_age_reason?: string | null
    recruitment_type?: ReqriutmentType | null
    job_title: string
    job_description: string
    japanese_percentage?: number | null
    must_condition: string
    want_condition?: string | null
    position_name?: string | null
    working_hour: string
    salary_type: SalaryType
    salary_min?: number | null
    salary_max?: number | null
    salary_detail: string
    day_off?: string | null
    progress_detail: string
    expire_date?: Date | string | null
    entity_branch?: EntityBranchCreateNestedOneWithoutJobsInput
    job_candidates?: JobCandidateCreateNestedManyWithoutJobInput
    JobRequirement?: JobRequirementCreateNestedManyWithoutJobsInput
  }

  export type JobUncheckedCreateWithoutJob_other_languagesInput = {
    job_id?: string
    created_at?: Date | string
    updated_at?: Date | string
    created_by: string
    updated_by?: string | null
    job_publish: JobPublish
    job_references?: JobReferenceListUncheckedCreateNestedManyWithoutJobInput
    location_details?: string | null
    career_level?: JobCreatecareer_levelInput | Enumerable<JobPosition>
    benefit_other?: string | null
    smoke?: JobCreatesmokeInput | Enumerable<Smoke>
    employment_status: EmploymentStatus
    japanese_level: LanguageLevel
    english_level: LanguageLevel
    experienced_count: number
    age_min?: number | null
    age_max?: number | null
    set_age_reason?: string | null
    recruitment_type?: ReqriutmentType | null
    job_title: string
    job_description: string
    japanese_percentage?: number | null
    must_condition: string
    want_condition?: string | null
    position_name?: string | null
    working_hour: string
    salary_type: SalaryType
    salary_min?: number | null
    salary_max?: number | null
    salary_detail: string
    day_off?: string | null
    progress_detail: string
    entity_branch_id: number
    expire_date?: Date | string | null
    job_candidates?: JobCandidateUncheckedCreateNestedManyWithoutJobInput
    JobRequirement?: JobRequirementUncheckedCreateNestedManyWithoutJobsInput
  }

  export type JobCreateOrConnectWithoutJob_other_languagesInput = {
    where: JobWhereUniqueInput
    create: XOR<JobCreateWithoutJob_other_languagesInput, JobUncheckedCreateWithoutJob_other_languagesInput>
  }

  export type JobUpsertWithoutJob_other_languagesInput = {
    update: XOR<JobUpdateWithoutJob_other_languagesInput, JobUncheckedUpdateWithoutJob_other_languagesInput>
    create: XOR<JobCreateWithoutJob_other_languagesInput, JobUncheckedCreateWithoutJob_other_languagesInput>
  }

  export type JobUpdateWithoutJob_other_languagesInput = {
    job_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    job_publish?: EnumJobPublishFieldUpdateOperationsInput | JobPublish
    job_references?: JobReferenceListUpdateManyWithoutJobNestedInput
    location_details?: NullableStringFieldUpdateOperationsInput | string | null
    career_level?: JobUpdatecareer_levelInput | Enumerable<JobPosition>
    benefit_other?: NullableStringFieldUpdateOperationsInput | string | null
    smoke?: JobUpdatesmokeInput | Enumerable<Smoke>
    employment_status?: EnumEmploymentStatusFieldUpdateOperationsInput | EmploymentStatus
    japanese_level?: EnumLanguageLevelFieldUpdateOperationsInput | LanguageLevel
    english_level?: EnumLanguageLevelFieldUpdateOperationsInput | LanguageLevel
    experienced_count?: IntFieldUpdateOperationsInput | number
    age_min?: NullableIntFieldUpdateOperationsInput | number | null
    age_max?: NullableIntFieldUpdateOperationsInput | number | null
    set_age_reason?: NullableStringFieldUpdateOperationsInput | string | null
    recruitment_type?: NullableEnumReqriutmentTypeFieldUpdateOperationsInput | ReqriutmentType | null
    job_title?: StringFieldUpdateOperationsInput | string
    job_description?: StringFieldUpdateOperationsInput | string
    japanese_percentage?: NullableIntFieldUpdateOperationsInput | number | null
    must_condition?: StringFieldUpdateOperationsInput | string
    want_condition?: NullableStringFieldUpdateOperationsInput | string | null
    position_name?: NullableStringFieldUpdateOperationsInput | string | null
    working_hour?: StringFieldUpdateOperationsInput | string
    salary_type?: EnumSalaryTypeFieldUpdateOperationsInput | SalaryType
    salary_min?: NullableIntFieldUpdateOperationsInput | number | null
    salary_max?: NullableIntFieldUpdateOperationsInput | number | null
    salary_detail?: StringFieldUpdateOperationsInput | string
    day_off?: NullableStringFieldUpdateOperationsInput | string | null
    progress_detail?: StringFieldUpdateOperationsInput | string
    expire_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    entity_branch?: EntityBranchUpdateOneWithoutJobsNestedInput
    job_candidates?: JobCandidateUpdateManyWithoutJobNestedInput
    JobRequirement?: JobRequirementUpdateManyWithoutJobsNestedInput
  }

  export type JobUncheckedUpdateWithoutJob_other_languagesInput = {
    job_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    job_publish?: EnumJobPublishFieldUpdateOperationsInput | JobPublish
    job_references?: JobReferenceListUncheckedUpdateManyWithoutJobNestedInput
    location_details?: NullableStringFieldUpdateOperationsInput | string | null
    career_level?: JobUpdatecareer_levelInput | Enumerable<JobPosition>
    benefit_other?: NullableStringFieldUpdateOperationsInput | string | null
    smoke?: JobUpdatesmokeInput | Enumerable<Smoke>
    employment_status?: EnumEmploymentStatusFieldUpdateOperationsInput | EmploymentStatus
    japanese_level?: EnumLanguageLevelFieldUpdateOperationsInput | LanguageLevel
    english_level?: EnumLanguageLevelFieldUpdateOperationsInput | LanguageLevel
    experienced_count?: IntFieldUpdateOperationsInput | number
    age_min?: NullableIntFieldUpdateOperationsInput | number | null
    age_max?: NullableIntFieldUpdateOperationsInput | number | null
    set_age_reason?: NullableStringFieldUpdateOperationsInput | string | null
    recruitment_type?: NullableEnumReqriutmentTypeFieldUpdateOperationsInput | ReqriutmentType | null
    job_title?: StringFieldUpdateOperationsInput | string
    job_description?: StringFieldUpdateOperationsInput | string
    japanese_percentage?: NullableIntFieldUpdateOperationsInput | number | null
    must_condition?: StringFieldUpdateOperationsInput | string
    want_condition?: NullableStringFieldUpdateOperationsInput | string | null
    position_name?: NullableStringFieldUpdateOperationsInput | string | null
    working_hour?: StringFieldUpdateOperationsInput | string
    salary_type?: EnumSalaryTypeFieldUpdateOperationsInput | SalaryType
    salary_min?: NullableIntFieldUpdateOperationsInput | number | null
    salary_max?: NullableIntFieldUpdateOperationsInput | number | null
    salary_detail?: StringFieldUpdateOperationsInput | string
    day_off?: NullableStringFieldUpdateOperationsInput | string | null
    progress_detail?: StringFieldUpdateOperationsInput | string
    entity_branch_id?: IntFieldUpdateOperationsInput | number
    expire_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    job_candidates?: JobCandidateUncheckedUpdateManyWithoutJobNestedInput
    JobRequirement?: JobRequirementUncheckedUpdateManyWithoutJobsNestedInput
  }

  export type JobCreateWithoutJob_referencesInput = {
    job_id?: string
    created_at?: Date | string
    updated_at?: Date | string
    created_by: string
    updated_by?: string | null
    job_publish: JobPublish
    location_details?: string | null
    career_level?: JobCreatecareer_levelInput | Enumerable<JobPosition>
    benefit_other?: string | null
    smoke?: JobCreatesmokeInput | Enumerable<Smoke>
    employment_status: EmploymentStatus
    japanese_level: LanguageLevel
    english_level: LanguageLevel
    job_other_languages?: JobOtherLanguageCreateNestedManyWithoutJobInput
    experienced_count: number
    age_min?: number | null
    age_max?: number | null
    set_age_reason?: string | null
    recruitment_type?: ReqriutmentType | null
    job_title: string
    job_description: string
    japanese_percentage?: number | null
    must_condition: string
    want_condition?: string | null
    position_name?: string | null
    working_hour: string
    salary_type: SalaryType
    salary_min?: number | null
    salary_max?: number | null
    salary_detail: string
    day_off?: string | null
    progress_detail: string
    expire_date?: Date | string | null
    entity_branch?: EntityBranchCreateNestedOneWithoutJobsInput
    job_candidates?: JobCandidateCreateNestedManyWithoutJobInput
    JobRequirement?: JobRequirementCreateNestedManyWithoutJobsInput
  }

  export type JobUncheckedCreateWithoutJob_referencesInput = {
    job_id?: string
    created_at?: Date | string
    updated_at?: Date | string
    created_by: string
    updated_by?: string | null
    job_publish: JobPublish
    location_details?: string | null
    career_level?: JobCreatecareer_levelInput | Enumerable<JobPosition>
    benefit_other?: string | null
    smoke?: JobCreatesmokeInput | Enumerable<Smoke>
    employment_status: EmploymentStatus
    japanese_level: LanguageLevel
    english_level: LanguageLevel
    job_other_languages?: JobOtherLanguageUncheckedCreateNestedManyWithoutJobInput
    experienced_count: number
    age_min?: number | null
    age_max?: number | null
    set_age_reason?: string | null
    recruitment_type?: ReqriutmentType | null
    job_title: string
    job_description: string
    japanese_percentage?: number | null
    must_condition: string
    want_condition?: string | null
    position_name?: string | null
    working_hour: string
    salary_type: SalaryType
    salary_min?: number | null
    salary_max?: number | null
    salary_detail: string
    day_off?: string | null
    progress_detail: string
    entity_branch_id: number
    expire_date?: Date | string | null
    job_candidates?: JobCandidateUncheckedCreateNestedManyWithoutJobInput
    JobRequirement?: JobRequirementUncheckedCreateNestedManyWithoutJobsInput
  }

  export type JobCreateOrConnectWithoutJob_referencesInput = {
    where: JobWhereUniqueInput
    create: XOR<JobCreateWithoutJob_referencesInput, JobUncheckedCreateWithoutJob_referencesInput>
  }

  export type ReferenceListCreateWithoutJobReferenceListInput = {
    list_name: string
    created_at?: Date | string
    listitems?: ReferenceListItemsCreateNestedManyWithoutListInput
  }

  export type ReferenceListUncheckedCreateWithoutJobReferenceListInput = {
    list_id?: number
    list_name: string
    created_at?: Date | string
    listitems?: ReferenceListItemsUncheckedCreateNestedManyWithoutListInput
  }

  export type ReferenceListCreateOrConnectWithoutJobReferenceListInput = {
    where: ReferenceListWhereUniqueInput
    create: XOR<ReferenceListCreateWithoutJobReferenceListInput, ReferenceListUncheckedCreateWithoutJobReferenceListInput>
  }

  export type ReferenceListItemsCreateWithoutJobReferenceListInput = {
    list: ReferenceListCreateNestedOneWithoutListitemsInput
    dictionary_id: number
    code?: string | null
    listitem_value?: string | null
    parent_id?: number | null
    value?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    customer_experiences?: CustomerExperienceCreateNestedManyWithoutListitemsInput
    Dictionary?: DictionaryCreateNestedOneWithoutReference_listitemsInput
  }

  export type ReferenceListItemsUncheckedCreateWithoutJobReferenceListInput = {
    listitem_id?: number
    list_id: number
    dictionary_id: number
    code?: string | null
    listitem_value?: string | null
    parent_id?: number | null
    value?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    customer_experiences?: CustomerExperienceUncheckedCreateNestedManyWithoutListitemsInput
    dictionaryDictionaries_id?: string | null
  }

  export type ReferenceListItemsCreateOrConnectWithoutJobReferenceListInput = {
    where: ReferenceListItemsWhereUniqueInput
    create: XOR<ReferenceListItemsCreateWithoutJobReferenceListInput, ReferenceListItemsUncheckedCreateWithoutJobReferenceListInput>
  }

  export type JobUpsertWithoutJob_referencesInput = {
    update: XOR<JobUpdateWithoutJob_referencesInput, JobUncheckedUpdateWithoutJob_referencesInput>
    create: XOR<JobCreateWithoutJob_referencesInput, JobUncheckedCreateWithoutJob_referencesInput>
  }

  export type JobUpdateWithoutJob_referencesInput = {
    job_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    job_publish?: EnumJobPublishFieldUpdateOperationsInput | JobPublish
    location_details?: NullableStringFieldUpdateOperationsInput | string | null
    career_level?: JobUpdatecareer_levelInput | Enumerable<JobPosition>
    benefit_other?: NullableStringFieldUpdateOperationsInput | string | null
    smoke?: JobUpdatesmokeInput | Enumerable<Smoke>
    employment_status?: EnumEmploymentStatusFieldUpdateOperationsInput | EmploymentStatus
    japanese_level?: EnumLanguageLevelFieldUpdateOperationsInput | LanguageLevel
    english_level?: EnumLanguageLevelFieldUpdateOperationsInput | LanguageLevel
    job_other_languages?: JobOtherLanguageUpdateManyWithoutJobNestedInput
    experienced_count?: IntFieldUpdateOperationsInput | number
    age_min?: NullableIntFieldUpdateOperationsInput | number | null
    age_max?: NullableIntFieldUpdateOperationsInput | number | null
    set_age_reason?: NullableStringFieldUpdateOperationsInput | string | null
    recruitment_type?: NullableEnumReqriutmentTypeFieldUpdateOperationsInput | ReqriutmentType | null
    job_title?: StringFieldUpdateOperationsInput | string
    job_description?: StringFieldUpdateOperationsInput | string
    japanese_percentage?: NullableIntFieldUpdateOperationsInput | number | null
    must_condition?: StringFieldUpdateOperationsInput | string
    want_condition?: NullableStringFieldUpdateOperationsInput | string | null
    position_name?: NullableStringFieldUpdateOperationsInput | string | null
    working_hour?: StringFieldUpdateOperationsInput | string
    salary_type?: EnumSalaryTypeFieldUpdateOperationsInput | SalaryType
    salary_min?: NullableIntFieldUpdateOperationsInput | number | null
    salary_max?: NullableIntFieldUpdateOperationsInput | number | null
    salary_detail?: StringFieldUpdateOperationsInput | string
    day_off?: NullableStringFieldUpdateOperationsInput | string | null
    progress_detail?: StringFieldUpdateOperationsInput | string
    expire_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    entity_branch?: EntityBranchUpdateOneWithoutJobsNestedInput
    job_candidates?: JobCandidateUpdateManyWithoutJobNestedInput
    JobRequirement?: JobRequirementUpdateManyWithoutJobsNestedInput
  }

  export type JobUncheckedUpdateWithoutJob_referencesInput = {
    job_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    job_publish?: EnumJobPublishFieldUpdateOperationsInput | JobPublish
    location_details?: NullableStringFieldUpdateOperationsInput | string | null
    career_level?: JobUpdatecareer_levelInput | Enumerable<JobPosition>
    benefit_other?: NullableStringFieldUpdateOperationsInput | string | null
    smoke?: JobUpdatesmokeInput | Enumerable<Smoke>
    employment_status?: EnumEmploymentStatusFieldUpdateOperationsInput | EmploymentStatus
    japanese_level?: EnumLanguageLevelFieldUpdateOperationsInput | LanguageLevel
    english_level?: EnumLanguageLevelFieldUpdateOperationsInput | LanguageLevel
    job_other_languages?: JobOtherLanguageUncheckedUpdateManyWithoutJobNestedInput
    experienced_count?: IntFieldUpdateOperationsInput | number
    age_min?: NullableIntFieldUpdateOperationsInput | number | null
    age_max?: NullableIntFieldUpdateOperationsInput | number | null
    set_age_reason?: NullableStringFieldUpdateOperationsInput | string | null
    recruitment_type?: NullableEnumReqriutmentTypeFieldUpdateOperationsInput | ReqriutmentType | null
    job_title?: StringFieldUpdateOperationsInput | string
    job_description?: StringFieldUpdateOperationsInput | string
    japanese_percentage?: NullableIntFieldUpdateOperationsInput | number | null
    must_condition?: StringFieldUpdateOperationsInput | string
    want_condition?: NullableStringFieldUpdateOperationsInput | string | null
    position_name?: NullableStringFieldUpdateOperationsInput | string | null
    working_hour?: StringFieldUpdateOperationsInput | string
    salary_type?: EnumSalaryTypeFieldUpdateOperationsInput | SalaryType
    salary_min?: NullableIntFieldUpdateOperationsInput | number | null
    salary_max?: NullableIntFieldUpdateOperationsInput | number | null
    salary_detail?: StringFieldUpdateOperationsInput | string
    day_off?: NullableStringFieldUpdateOperationsInput | string | null
    progress_detail?: StringFieldUpdateOperationsInput | string
    entity_branch_id?: IntFieldUpdateOperationsInput | number
    expire_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    job_candidates?: JobCandidateUncheckedUpdateManyWithoutJobNestedInput
    JobRequirement?: JobRequirementUncheckedUpdateManyWithoutJobsNestedInput
  }

  export type ReferenceListUpsertWithoutJobReferenceListInput = {
    update: XOR<ReferenceListUpdateWithoutJobReferenceListInput, ReferenceListUncheckedUpdateWithoutJobReferenceListInput>
    create: XOR<ReferenceListCreateWithoutJobReferenceListInput, ReferenceListUncheckedCreateWithoutJobReferenceListInput>
  }

  export type ReferenceListUpdateWithoutJobReferenceListInput = {
    list_name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    listitems?: ReferenceListItemsUpdateManyWithoutListNestedInput
  }

  export type ReferenceListUncheckedUpdateWithoutJobReferenceListInput = {
    list_id?: IntFieldUpdateOperationsInput | number
    list_name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    listitems?: ReferenceListItemsUncheckedUpdateManyWithoutListNestedInput
  }

  export type ReferenceListItemsUpsertWithoutJobReferenceListInput = {
    update: XOR<ReferenceListItemsUpdateWithoutJobReferenceListInput, ReferenceListItemsUncheckedUpdateWithoutJobReferenceListInput>
    create: XOR<ReferenceListItemsCreateWithoutJobReferenceListInput, ReferenceListItemsUncheckedCreateWithoutJobReferenceListInput>
  }

  export type ReferenceListItemsUpdateWithoutJobReferenceListInput = {
    list?: ReferenceListUpdateOneRequiredWithoutListitemsNestedInput
    dictionary_id?: IntFieldUpdateOperationsInput | number
    code?: NullableStringFieldUpdateOperationsInput | string | null
    listitem_value?: NullableStringFieldUpdateOperationsInput | string | null
    parent_id?: NullableIntFieldUpdateOperationsInput | number | null
    value?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    customer_experiences?: CustomerExperienceUpdateManyWithoutListitemsNestedInput
    Dictionary?: DictionaryUpdateOneWithoutReference_listitemsNestedInput
  }

  export type ReferenceListItemsUncheckedUpdateWithoutJobReferenceListInput = {
    listitem_id?: IntFieldUpdateOperationsInput | number
    list_id?: IntFieldUpdateOperationsInput | number
    dictionary_id?: IntFieldUpdateOperationsInput | number
    code?: NullableStringFieldUpdateOperationsInput | string | null
    listitem_value?: NullableStringFieldUpdateOperationsInput | string | null
    parent_id?: NullableIntFieldUpdateOperationsInput | number | null
    value?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    customer_experiences?: CustomerExperienceUncheckedUpdateManyWithoutListitemsNestedInput
    dictionaryDictionaries_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type JobCreateWithoutJob_candidatesInput = {
    job_id?: string
    created_at?: Date | string
    updated_at?: Date | string
    created_by: string
    updated_by?: string | null
    job_publish: JobPublish
    job_references?: JobReferenceListCreateNestedManyWithoutJobInput
    location_details?: string | null
    career_level?: JobCreatecareer_levelInput | Enumerable<JobPosition>
    benefit_other?: string | null
    smoke?: JobCreatesmokeInput | Enumerable<Smoke>
    employment_status: EmploymentStatus
    japanese_level: LanguageLevel
    english_level: LanguageLevel
    job_other_languages?: JobOtherLanguageCreateNestedManyWithoutJobInput
    experienced_count: number
    age_min?: number | null
    age_max?: number | null
    set_age_reason?: string | null
    recruitment_type?: ReqriutmentType | null
    job_title: string
    job_description: string
    japanese_percentage?: number | null
    must_condition: string
    want_condition?: string | null
    position_name?: string | null
    working_hour: string
    salary_type: SalaryType
    salary_min?: number | null
    salary_max?: number | null
    salary_detail: string
    day_off?: string | null
    progress_detail: string
    expire_date?: Date | string | null
    entity_branch?: EntityBranchCreateNestedOneWithoutJobsInput
    JobRequirement?: JobRequirementCreateNestedManyWithoutJobsInput
  }

  export type JobUncheckedCreateWithoutJob_candidatesInput = {
    job_id?: string
    created_at?: Date | string
    updated_at?: Date | string
    created_by: string
    updated_by?: string | null
    job_publish: JobPublish
    job_references?: JobReferenceListUncheckedCreateNestedManyWithoutJobInput
    location_details?: string | null
    career_level?: JobCreatecareer_levelInput | Enumerable<JobPosition>
    benefit_other?: string | null
    smoke?: JobCreatesmokeInput | Enumerable<Smoke>
    employment_status: EmploymentStatus
    japanese_level: LanguageLevel
    english_level: LanguageLevel
    job_other_languages?: JobOtherLanguageUncheckedCreateNestedManyWithoutJobInput
    experienced_count: number
    age_min?: number | null
    age_max?: number | null
    set_age_reason?: string | null
    recruitment_type?: ReqriutmentType | null
    job_title: string
    job_description: string
    japanese_percentage?: number | null
    must_condition: string
    want_condition?: string | null
    position_name?: string | null
    working_hour: string
    salary_type: SalaryType
    salary_min?: number | null
    salary_max?: number | null
    salary_detail: string
    day_off?: string | null
    progress_detail: string
    entity_branch_id: number
    expire_date?: Date | string | null
    JobRequirement?: JobRequirementUncheckedCreateNestedManyWithoutJobsInput
  }

  export type JobCreateOrConnectWithoutJob_candidatesInput = {
    where: JobWhereUniqueInput
    create: XOR<JobCreateWithoutJob_candidatesInput, JobUncheckedCreateWithoutJob_candidatesInput>
  }

  export type CustomerCreateWithoutJob_candidatesInput = {
    customer_id?: string
    first_name: string
    last_name: string
    first_name_kana: string
    last_name_kana: string
    gender?: Gender | null
    birth_date?: Date | string | null
    spouse?: NullableJsonNullValueInput | InputJsonValue
    family_size?: number | null
    email?: string | null
    mobile?: string | null
    phone?: string | null
    profile_image?: string | null
    cv_file?: string | null
    resume_file?: string | null
    prefecture?: NullableJsonNullValueInput | InputJsonValue
    post_code?: string | null
    city?: string | null
    district?: string | null
    address?: string | null
    address1?: string | null
    nearest_station?: string | null
    socials?: NullableJsonNullValueInput | InputJsonValue
    country?: string | null
    experienced_year?: number | null
    from_data?: number | null
    status_customer?: CustomerStatus | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: string | null
    updated_by?: string | null
    user?: UserCreateNestedOneWithoutCustomerInput
    customer_visas?: CustomerVisaCreateNestedManyWithoutCustomerInput
    customer_jobdetails?: CustomerJobDetailCreateNestedManyWithoutCustomerInput
    customer_educations?: CustomerEducationCreateNestedManyWithoutCustomerInput
    customer_languages?: CustomerLanguageCreateNestedManyWithoutCustomerInput
    customer_qualifications?: CustomerQualificationCreateNestedManyWithoutCustomersInput
    customer_workhistories?: CustomerWorkHistoryCreateNestedManyWithoutCustomerInput
    customer_desired?: CustomerDesiredCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutJob_candidatesInput = {
    customer_id?: string
    first_name: string
    last_name: string
    first_name_kana: string
    last_name_kana: string
    gender?: Gender | null
    birth_date?: Date | string | null
    spouse?: NullableJsonNullValueInput | InputJsonValue
    family_size?: number | null
    email?: string | null
    mobile?: string | null
    phone?: string | null
    profile_image?: string | null
    cv_file?: string | null
    resume_file?: string | null
    prefecture?: NullableJsonNullValueInput | InputJsonValue
    post_code?: string | null
    city?: string | null
    district?: string | null
    address?: string | null
    address1?: string | null
    nearest_station?: string | null
    socials?: NullableJsonNullValueInput | InputJsonValue
    country?: string | null
    experienced_year?: number | null
    from_data?: number | null
    status_customer?: CustomerStatus | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: string | null
    updated_by?: string | null
    user?: UserUncheckedCreateNestedOneWithoutCustomerInput
    customer_visas?: CustomerVisaUncheckedCreateNestedManyWithoutCustomerInput
    customer_jobdetails?: CustomerJobDetailUncheckedCreateNestedManyWithoutCustomerInput
    customer_educations?: CustomerEducationUncheckedCreateNestedManyWithoutCustomerInput
    customer_languages?: CustomerLanguageUncheckedCreateNestedManyWithoutCustomerInput
    customer_qualifications?: CustomerQualificationUncheckedCreateNestedManyWithoutCustomersInput
    customer_workhistories?: CustomerWorkHistoryUncheckedCreateNestedManyWithoutCustomerInput
    customer_desired?: CustomerDesiredUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutJob_candidatesInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutJob_candidatesInput, CustomerUncheckedCreateWithoutJob_candidatesInput>
  }

  export type JobUpsertWithoutJob_candidatesInput = {
    update: XOR<JobUpdateWithoutJob_candidatesInput, JobUncheckedUpdateWithoutJob_candidatesInput>
    create: XOR<JobCreateWithoutJob_candidatesInput, JobUncheckedCreateWithoutJob_candidatesInput>
  }

  export type JobUpdateWithoutJob_candidatesInput = {
    job_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    job_publish?: EnumJobPublishFieldUpdateOperationsInput | JobPublish
    job_references?: JobReferenceListUpdateManyWithoutJobNestedInput
    location_details?: NullableStringFieldUpdateOperationsInput | string | null
    career_level?: JobUpdatecareer_levelInput | Enumerable<JobPosition>
    benefit_other?: NullableStringFieldUpdateOperationsInput | string | null
    smoke?: JobUpdatesmokeInput | Enumerable<Smoke>
    employment_status?: EnumEmploymentStatusFieldUpdateOperationsInput | EmploymentStatus
    japanese_level?: EnumLanguageLevelFieldUpdateOperationsInput | LanguageLevel
    english_level?: EnumLanguageLevelFieldUpdateOperationsInput | LanguageLevel
    job_other_languages?: JobOtherLanguageUpdateManyWithoutJobNestedInput
    experienced_count?: IntFieldUpdateOperationsInput | number
    age_min?: NullableIntFieldUpdateOperationsInput | number | null
    age_max?: NullableIntFieldUpdateOperationsInput | number | null
    set_age_reason?: NullableStringFieldUpdateOperationsInput | string | null
    recruitment_type?: NullableEnumReqriutmentTypeFieldUpdateOperationsInput | ReqriutmentType | null
    job_title?: StringFieldUpdateOperationsInput | string
    job_description?: StringFieldUpdateOperationsInput | string
    japanese_percentage?: NullableIntFieldUpdateOperationsInput | number | null
    must_condition?: StringFieldUpdateOperationsInput | string
    want_condition?: NullableStringFieldUpdateOperationsInput | string | null
    position_name?: NullableStringFieldUpdateOperationsInput | string | null
    working_hour?: StringFieldUpdateOperationsInput | string
    salary_type?: EnumSalaryTypeFieldUpdateOperationsInput | SalaryType
    salary_min?: NullableIntFieldUpdateOperationsInput | number | null
    salary_max?: NullableIntFieldUpdateOperationsInput | number | null
    salary_detail?: StringFieldUpdateOperationsInput | string
    day_off?: NullableStringFieldUpdateOperationsInput | string | null
    progress_detail?: StringFieldUpdateOperationsInput | string
    expire_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    entity_branch?: EntityBranchUpdateOneWithoutJobsNestedInput
    JobRequirement?: JobRequirementUpdateManyWithoutJobsNestedInput
  }

  export type JobUncheckedUpdateWithoutJob_candidatesInput = {
    job_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    job_publish?: EnumJobPublishFieldUpdateOperationsInput | JobPublish
    job_references?: JobReferenceListUncheckedUpdateManyWithoutJobNestedInput
    location_details?: NullableStringFieldUpdateOperationsInput | string | null
    career_level?: JobUpdatecareer_levelInput | Enumerable<JobPosition>
    benefit_other?: NullableStringFieldUpdateOperationsInput | string | null
    smoke?: JobUpdatesmokeInput | Enumerable<Smoke>
    employment_status?: EnumEmploymentStatusFieldUpdateOperationsInput | EmploymentStatus
    japanese_level?: EnumLanguageLevelFieldUpdateOperationsInput | LanguageLevel
    english_level?: EnumLanguageLevelFieldUpdateOperationsInput | LanguageLevel
    job_other_languages?: JobOtherLanguageUncheckedUpdateManyWithoutJobNestedInput
    experienced_count?: IntFieldUpdateOperationsInput | number
    age_min?: NullableIntFieldUpdateOperationsInput | number | null
    age_max?: NullableIntFieldUpdateOperationsInput | number | null
    set_age_reason?: NullableStringFieldUpdateOperationsInput | string | null
    recruitment_type?: NullableEnumReqriutmentTypeFieldUpdateOperationsInput | ReqriutmentType | null
    job_title?: StringFieldUpdateOperationsInput | string
    job_description?: StringFieldUpdateOperationsInput | string
    japanese_percentage?: NullableIntFieldUpdateOperationsInput | number | null
    must_condition?: StringFieldUpdateOperationsInput | string
    want_condition?: NullableStringFieldUpdateOperationsInput | string | null
    position_name?: NullableStringFieldUpdateOperationsInput | string | null
    working_hour?: StringFieldUpdateOperationsInput | string
    salary_type?: EnumSalaryTypeFieldUpdateOperationsInput | SalaryType
    salary_min?: NullableIntFieldUpdateOperationsInput | number | null
    salary_max?: NullableIntFieldUpdateOperationsInput | number | null
    salary_detail?: StringFieldUpdateOperationsInput | string
    day_off?: NullableStringFieldUpdateOperationsInput | string | null
    progress_detail?: StringFieldUpdateOperationsInput | string
    entity_branch_id?: IntFieldUpdateOperationsInput | number
    expire_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    JobRequirement?: JobRequirementUncheckedUpdateManyWithoutJobsNestedInput
  }

  export type CustomerUpsertWithoutJob_candidatesInput = {
    update: XOR<CustomerUpdateWithoutJob_candidatesInput, CustomerUncheckedUpdateWithoutJob_candidatesInput>
    create: XOR<CustomerCreateWithoutJob_candidatesInput, CustomerUncheckedCreateWithoutJob_candidatesInput>
  }

  export type CustomerUpdateWithoutJob_candidatesInput = {
    customer_id?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    first_name_kana?: StringFieldUpdateOperationsInput | string
    last_name_kana?: StringFieldUpdateOperationsInput | string
    gender?: NullableEnumGenderFieldUpdateOperationsInput | Gender | null
    birth_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    spouse?: NullableJsonNullValueInput | InputJsonValue
    family_size?: NullableIntFieldUpdateOperationsInput | number | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profile_image?: NullableStringFieldUpdateOperationsInput | string | null
    cv_file?: NullableStringFieldUpdateOperationsInput | string | null
    resume_file?: NullableStringFieldUpdateOperationsInput | string | null
    prefecture?: NullableJsonNullValueInput | InputJsonValue
    post_code?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    address1?: NullableStringFieldUpdateOperationsInput | string | null
    nearest_station?: NullableStringFieldUpdateOperationsInput | string | null
    socials?: NullableJsonNullValueInput | InputJsonValue
    country?: NullableStringFieldUpdateOperationsInput | string | null
    experienced_year?: NullableIntFieldUpdateOperationsInput | number | null
    from_data?: NullableIntFieldUpdateOperationsInput | number | null
    status_customer?: NullableEnumCustomerStatusFieldUpdateOperationsInput | CustomerStatus | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneWithoutCustomerNestedInput
    customer_visas?: CustomerVisaUpdateManyWithoutCustomerNestedInput
    customer_jobdetails?: CustomerJobDetailUpdateManyWithoutCustomerNestedInput
    customer_educations?: CustomerEducationUpdateManyWithoutCustomerNestedInput
    customer_languages?: CustomerLanguageUpdateManyWithoutCustomerNestedInput
    customer_qualifications?: CustomerQualificationUpdateManyWithoutCustomersNestedInput
    customer_workhistories?: CustomerWorkHistoryUpdateManyWithoutCustomerNestedInput
    customer_desired?: CustomerDesiredUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutJob_candidatesInput = {
    customer_id?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    first_name_kana?: StringFieldUpdateOperationsInput | string
    last_name_kana?: StringFieldUpdateOperationsInput | string
    gender?: NullableEnumGenderFieldUpdateOperationsInput | Gender | null
    birth_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    spouse?: NullableJsonNullValueInput | InputJsonValue
    family_size?: NullableIntFieldUpdateOperationsInput | number | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profile_image?: NullableStringFieldUpdateOperationsInput | string | null
    cv_file?: NullableStringFieldUpdateOperationsInput | string | null
    resume_file?: NullableStringFieldUpdateOperationsInput | string | null
    prefecture?: NullableJsonNullValueInput | InputJsonValue
    post_code?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    address1?: NullableStringFieldUpdateOperationsInput | string | null
    nearest_station?: NullableStringFieldUpdateOperationsInput | string | null
    socials?: NullableJsonNullValueInput | InputJsonValue
    country?: NullableStringFieldUpdateOperationsInput | string | null
    experienced_year?: NullableIntFieldUpdateOperationsInput | number | null
    from_data?: NullableIntFieldUpdateOperationsInput | number | null
    status_customer?: NullableEnumCustomerStatusFieldUpdateOperationsInput | CustomerStatus | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUncheckedUpdateOneWithoutCustomerNestedInput
    customer_visas?: CustomerVisaUncheckedUpdateManyWithoutCustomerNestedInput
    customer_jobdetails?: CustomerJobDetailUncheckedUpdateManyWithoutCustomerNestedInput
    customer_educations?: CustomerEducationUncheckedUpdateManyWithoutCustomerNestedInput
    customer_languages?: CustomerLanguageUncheckedUpdateManyWithoutCustomerNestedInput
    customer_qualifications?: CustomerQualificationUncheckedUpdateManyWithoutCustomersNestedInput
    customer_workhistories?: CustomerWorkHistoryUncheckedUpdateManyWithoutCustomerNestedInput
    customer_desired?: CustomerDesiredUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type JobCreateWithoutJobRequirementInput = {
    job_id?: string
    created_at?: Date | string
    updated_at?: Date | string
    created_by: string
    updated_by?: string | null
    job_publish: JobPublish
    job_references?: JobReferenceListCreateNestedManyWithoutJobInput
    location_details?: string | null
    career_level?: JobCreatecareer_levelInput | Enumerable<JobPosition>
    benefit_other?: string | null
    smoke?: JobCreatesmokeInput | Enumerable<Smoke>
    employment_status: EmploymentStatus
    japanese_level: LanguageLevel
    english_level: LanguageLevel
    job_other_languages?: JobOtherLanguageCreateNestedManyWithoutJobInput
    experienced_count: number
    age_min?: number | null
    age_max?: number | null
    set_age_reason?: string | null
    recruitment_type?: ReqriutmentType | null
    job_title: string
    job_description: string
    japanese_percentage?: number | null
    must_condition: string
    want_condition?: string | null
    position_name?: string | null
    working_hour: string
    salary_type: SalaryType
    salary_min?: number | null
    salary_max?: number | null
    salary_detail: string
    day_off?: string | null
    progress_detail: string
    expire_date?: Date | string | null
    entity_branch?: EntityBranchCreateNestedOneWithoutJobsInput
    job_candidates?: JobCandidateCreateNestedManyWithoutJobInput
  }

  export type JobUncheckedCreateWithoutJobRequirementInput = {
    job_id?: string
    created_at?: Date | string
    updated_at?: Date | string
    created_by: string
    updated_by?: string | null
    job_publish: JobPublish
    job_references?: JobReferenceListUncheckedCreateNestedManyWithoutJobInput
    location_details?: string | null
    career_level?: JobCreatecareer_levelInput | Enumerable<JobPosition>
    benefit_other?: string | null
    smoke?: JobCreatesmokeInput | Enumerable<Smoke>
    employment_status: EmploymentStatus
    japanese_level: LanguageLevel
    english_level: LanguageLevel
    job_other_languages?: JobOtherLanguageUncheckedCreateNestedManyWithoutJobInput
    experienced_count: number
    age_min?: number | null
    age_max?: number | null
    set_age_reason?: string | null
    recruitment_type?: ReqriutmentType | null
    job_title: string
    job_description: string
    japanese_percentage?: number | null
    must_condition: string
    want_condition?: string | null
    position_name?: string | null
    working_hour: string
    salary_type: SalaryType
    salary_min?: number | null
    salary_max?: number | null
    salary_detail: string
    day_off?: string | null
    progress_detail: string
    entity_branch_id: number
    expire_date?: Date | string | null
    job_candidates?: JobCandidateUncheckedCreateNestedManyWithoutJobInput
  }

  export type JobCreateOrConnectWithoutJobRequirementInput = {
    where: JobWhereUniqueInput
    create: XOR<JobCreateWithoutJobRequirementInput, JobUncheckedCreateWithoutJobRequirementInput>
  }

  export type JobUpsertWithoutJobRequirementInput = {
    update: XOR<JobUpdateWithoutJobRequirementInput, JobUncheckedUpdateWithoutJobRequirementInput>
    create: XOR<JobCreateWithoutJobRequirementInput, JobUncheckedCreateWithoutJobRequirementInput>
  }

  export type JobUpdateWithoutJobRequirementInput = {
    job_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    job_publish?: EnumJobPublishFieldUpdateOperationsInput | JobPublish
    job_references?: JobReferenceListUpdateManyWithoutJobNestedInput
    location_details?: NullableStringFieldUpdateOperationsInput | string | null
    career_level?: JobUpdatecareer_levelInput | Enumerable<JobPosition>
    benefit_other?: NullableStringFieldUpdateOperationsInput | string | null
    smoke?: JobUpdatesmokeInput | Enumerable<Smoke>
    employment_status?: EnumEmploymentStatusFieldUpdateOperationsInput | EmploymentStatus
    japanese_level?: EnumLanguageLevelFieldUpdateOperationsInput | LanguageLevel
    english_level?: EnumLanguageLevelFieldUpdateOperationsInput | LanguageLevel
    job_other_languages?: JobOtherLanguageUpdateManyWithoutJobNestedInput
    experienced_count?: IntFieldUpdateOperationsInput | number
    age_min?: NullableIntFieldUpdateOperationsInput | number | null
    age_max?: NullableIntFieldUpdateOperationsInput | number | null
    set_age_reason?: NullableStringFieldUpdateOperationsInput | string | null
    recruitment_type?: NullableEnumReqriutmentTypeFieldUpdateOperationsInput | ReqriutmentType | null
    job_title?: StringFieldUpdateOperationsInput | string
    job_description?: StringFieldUpdateOperationsInput | string
    japanese_percentage?: NullableIntFieldUpdateOperationsInput | number | null
    must_condition?: StringFieldUpdateOperationsInput | string
    want_condition?: NullableStringFieldUpdateOperationsInput | string | null
    position_name?: NullableStringFieldUpdateOperationsInput | string | null
    working_hour?: StringFieldUpdateOperationsInput | string
    salary_type?: EnumSalaryTypeFieldUpdateOperationsInput | SalaryType
    salary_min?: NullableIntFieldUpdateOperationsInput | number | null
    salary_max?: NullableIntFieldUpdateOperationsInput | number | null
    salary_detail?: StringFieldUpdateOperationsInput | string
    day_off?: NullableStringFieldUpdateOperationsInput | string | null
    progress_detail?: StringFieldUpdateOperationsInput | string
    expire_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    entity_branch?: EntityBranchUpdateOneWithoutJobsNestedInput
    job_candidates?: JobCandidateUpdateManyWithoutJobNestedInput
  }

  export type JobUncheckedUpdateWithoutJobRequirementInput = {
    job_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    job_publish?: EnumJobPublishFieldUpdateOperationsInput | JobPublish
    job_references?: JobReferenceListUncheckedUpdateManyWithoutJobNestedInput
    location_details?: NullableStringFieldUpdateOperationsInput | string | null
    career_level?: JobUpdatecareer_levelInput | Enumerable<JobPosition>
    benefit_other?: NullableStringFieldUpdateOperationsInput | string | null
    smoke?: JobUpdatesmokeInput | Enumerable<Smoke>
    employment_status?: EnumEmploymentStatusFieldUpdateOperationsInput | EmploymentStatus
    japanese_level?: EnumLanguageLevelFieldUpdateOperationsInput | LanguageLevel
    english_level?: EnumLanguageLevelFieldUpdateOperationsInput | LanguageLevel
    job_other_languages?: JobOtherLanguageUncheckedUpdateManyWithoutJobNestedInput
    experienced_count?: IntFieldUpdateOperationsInput | number
    age_min?: NullableIntFieldUpdateOperationsInput | number | null
    age_max?: NullableIntFieldUpdateOperationsInput | number | null
    set_age_reason?: NullableStringFieldUpdateOperationsInput | string | null
    recruitment_type?: NullableEnumReqriutmentTypeFieldUpdateOperationsInput | ReqriutmentType | null
    job_title?: StringFieldUpdateOperationsInput | string
    job_description?: StringFieldUpdateOperationsInput | string
    japanese_percentage?: NullableIntFieldUpdateOperationsInput | number | null
    must_condition?: StringFieldUpdateOperationsInput | string
    want_condition?: NullableStringFieldUpdateOperationsInput | string | null
    position_name?: NullableStringFieldUpdateOperationsInput | string | null
    working_hour?: StringFieldUpdateOperationsInput | string
    salary_type?: EnumSalaryTypeFieldUpdateOperationsInput | SalaryType
    salary_min?: NullableIntFieldUpdateOperationsInput | number | null
    salary_max?: NullableIntFieldUpdateOperationsInput | number | null
    salary_detail?: StringFieldUpdateOperationsInput | string
    day_off?: NullableStringFieldUpdateOperationsInput | string | null
    progress_detail?: StringFieldUpdateOperationsInput | string
    entity_branch_id?: IntFieldUpdateOperationsInput | number
    expire_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    job_candidates?: JobCandidateUncheckedUpdateManyWithoutJobNestedInput
  }

  export type UserCreateWithoutLoggersInput = {
    user_id?: string
    email: string
    mobile?: string | null
    name?: string | null
    password_hash: string
    role?: UserRole
    company_id?: number
    attemptpass_count?: number | null
    reset_code?: string
    is_emailverified?: boolean
    is_mobileverified?: boolean
    user_status?: UserStatus
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    favs: JsonNullValueInput | InputJsonValue
    Customer?: CustomerCreateNestedOneWithoutUserInput
    from_inquiries?: InquiryCreateNestedManyWithoutFromuserInput
    assign_inquiries?: InquiryCreateNestedManyWithoutAssignUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    ScoutFav?: ScoutFavCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutLoggersInput = {
    user_id?: string
    email: string
    mobile?: string | null
    name?: string | null
    password_hash: string
    role?: UserRole
    company_id?: number
    customer_id?: string | null
    attemptpass_count?: number | null
    reset_code?: string
    is_emailverified?: boolean
    is_mobileverified?: boolean
    user_status?: UserStatus
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    favs: JsonNullValueInput | InputJsonValue
    from_inquiries?: InquiryUncheckedCreateNestedManyWithoutFromuserInput
    assign_inquiries?: InquiryUncheckedCreateNestedManyWithoutAssignUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    ScoutFav?: ScoutFavUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutLoggersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutLoggersInput, UserUncheckedCreateWithoutLoggersInput>
  }

  export type UserUpsertWithoutLoggersInput = {
    update: XOR<UserUpdateWithoutLoggersInput, UserUncheckedUpdateWithoutLoggersInput>
    create: XOR<UserCreateWithoutLoggersInput, UserUncheckedCreateWithoutLoggersInput>
  }

  export type UserUpdateWithoutLoggersInput = {
    user_id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | UserRole
    company_id?: IntFieldUpdateOperationsInput | number
    attemptpass_count?: NullableIntFieldUpdateOperationsInput | number | null
    reset_code?: StringFieldUpdateOperationsInput | string
    is_emailverified?: BoolFieldUpdateOperationsInput | boolean
    is_mobileverified?: BoolFieldUpdateOperationsInput | boolean
    user_status?: EnumUserStatusFieldUpdateOperationsInput | UserStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    favs?: JsonNullValueInput | InputJsonValue
    Customer?: CustomerUpdateOneWithoutUserNestedInput
    from_inquiries?: InquiryUpdateManyWithoutFromuserNestedInput
    assign_inquiries?: InquiryUpdateManyWithoutAssignUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    ScoutFav?: ScoutFavUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutLoggersInput = {
    user_id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | UserRole
    company_id?: IntFieldUpdateOperationsInput | number
    customer_id?: NullableStringFieldUpdateOperationsInput | string | null
    attemptpass_count?: NullableIntFieldUpdateOperationsInput | number | null
    reset_code?: StringFieldUpdateOperationsInput | string
    is_emailverified?: BoolFieldUpdateOperationsInput | boolean
    is_mobileverified?: BoolFieldUpdateOperationsInput | boolean
    user_status?: EnumUserStatusFieldUpdateOperationsInput | UserStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    favs?: JsonNullValueInput | InputJsonValue
    from_inquiries?: InquiryUncheckedUpdateManyWithoutFromuserNestedInput
    assign_inquiries?: InquiryUncheckedUpdateManyWithoutAssignUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    ScoutFav?: ScoutFavUncheckedUpdateManyWithoutUserNestedInput
  }

  export type PagesCreateWithoutNewsInput = {
    page_name: string
    page_type?: number
    created_at?: Date | string
    created_by: string
  }

  export type PagesUncheckedCreateWithoutNewsInput = {
    page_id?: number
    page_name: string
    page_type?: number
    created_at?: Date | string
    created_by: string
  }

  export type PagesCreateOrConnectWithoutNewsInput = {
    where: PagesWhereUniqueInput
    create: XOR<PagesCreateWithoutNewsInput, PagesUncheckedCreateWithoutNewsInput>
  }

  export type PagesUpsertWithoutNewsInput = {
    update: XOR<PagesUpdateWithoutNewsInput, PagesUncheckedUpdateWithoutNewsInput>
    create: XOR<PagesCreateWithoutNewsInput, PagesUncheckedCreateWithoutNewsInput>
  }

  export type PagesUpdateWithoutNewsInput = {
    page_name?: StringFieldUpdateOperationsInput | string
    page_type?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: StringFieldUpdateOperationsInput | string
  }

  export type PagesUncheckedUpdateWithoutNewsInput = {
    page_id?: IntFieldUpdateOperationsInput | number
    page_name?: StringFieldUpdateOperationsInput | string
    page_type?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: StringFieldUpdateOperationsInput | string
  }

  export type UserCreateWithoutNotificationsInput = {
    user_id?: string
    email: string
    mobile?: string | null
    name?: string | null
    password_hash: string
    role?: UserRole
    company_id?: number
    attemptpass_count?: number | null
    reset_code?: string
    is_emailverified?: boolean
    is_mobileverified?: boolean
    user_status?: UserStatus
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    favs: JsonNullValueInput | InputJsonValue
    Customer?: CustomerCreateNestedOneWithoutUserInput
    loggers?: LoggerCreateNestedManyWithoutUserInput
    from_inquiries?: InquiryCreateNestedManyWithoutFromuserInput
    assign_inquiries?: InquiryCreateNestedManyWithoutAssignUserInput
    ScoutFav?: ScoutFavCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutNotificationsInput = {
    user_id?: string
    email: string
    mobile?: string | null
    name?: string | null
    password_hash: string
    role?: UserRole
    company_id?: number
    customer_id?: string | null
    attemptpass_count?: number | null
    reset_code?: string
    is_emailverified?: boolean
    is_mobileverified?: boolean
    user_status?: UserStatus
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    favs: JsonNullValueInput | InputJsonValue
    loggers?: LoggerUncheckedCreateNestedManyWithoutUserInput
    from_inquiries?: InquiryUncheckedCreateNestedManyWithoutFromuserInput
    assign_inquiries?: InquiryUncheckedCreateNestedManyWithoutAssignUserInput
    ScoutFav?: ScoutFavUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutNotificationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
  }

  export type UserUpsertWithoutNotificationsInput = {
    update: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
  }

  export type UserUpdateWithoutNotificationsInput = {
    user_id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | UserRole
    company_id?: IntFieldUpdateOperationsInput | number
    attemptpass_count?: NullableIntFieldUpdateOperationsInput | number | null
    reset_code?: StringFieldUpdateOperationsInput | string
    is_emailverified?: BoolFieldUpdateOperationsInput | boolean
    is_mobileverified?: BoolFieldUpdateOperationsInput | boolean
    user_status?: EnumUserStatusFieldUpdateOperationsInput | UserStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    favs?: JsonNullValueInput | InputJsonValue
    Customer?: CustomerUpdateOneWithoutUserNestedInput
    loggers?: LoggerUpdateManyWithoutUserNestedInput
    from_inquiries?: InquiryUpdateManyWithoutFromuserNestedInput
    assign_inquiries?: InquiryUpdateManyWithoutAssignUserNestedInput
    ScoutFav?: ScoutFavUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutNotificationsInput = {
    user_id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | UserRole
    company_id?: IntFieldUpdateOperationsInput | number
    customer_id?: NullableStringFieldUpdateOperationsInput | string | null
    attemptpass_count?: NullableIntFieldUpdateOperationsInput | number | null
    reset_code?: StringFieldUpdateOperationsInput | string
    is_emailverified?: BoolFieldUpdateOperationsInput | boolean
    is_mobileverified?: BoolFieldUpdateOperationsInput | boolean
    user_status?: EnumUserStatusFieldUpdateOperationsInput | UserStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    favs?: JsonNullValueInput | InputJsonValue
    loggers?: LoggerUncheckedUpdateManyWithoutUserNestedInput
    from_inquiries?: InquiryUncheckedUpdateManyWithoutFromuserNestedInput
    assign_inquiries?: InquiryUncheckedUpdateManyWithoutAssignUserNestedInput
    ScoutFav?: ScoutFavUncheckedUpdateManyWithoutUserNestedInput
  }

  export type NewsCreateWithoutPagesInput = {
    news_id?: string
    title: string
    brief: string
    image_id: string
    content: string
    is_top?: boolean
    is_publish?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    created_by: string
    update_by: string
  }

  export type NewsUncheckedCreateWithoutPagesInput = {
    news_id?: string
    title: string
    brief: string
    image_id: string
    content: string
    is_top?: boolean
    is_publish?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    created_by: string
    update_by: string
  }

  export type NewsCreateOrConnectWithoutPagesInput = {
    where: NewsWhereUniqueInput
    create: XOR<NewsCreateWithoutPagesInput, NewsUncheckedCreateWithoutPagesInput>
  }

  export type NewsCreateManyPagesInputEnvelope = {
    data: Enumerable<NewsCreateManyPagesInput>
    skipDuplicates?: boolean
  }

  export type NewsUpsertWithWhereUniqueWithoutPagesInput = {
    where: NewsWhereUniqueInput
    update: XOR<NewsUpdateWithoutPagesInput, NewsUncheckedUpdateWithoutPagesInput>
    create: XOR<NewsCreateWithoutPagesInput, NewsUncheckedCreateWithoutPagesInput>
  }

  export type NewsUpdateWithWhereUniqueWithoutPagesInput = {
    where: NewsWhereUniqueInput
    data: XOR<NewsUpdateWithoutPagesInput, NewsUncheckedUpdateWithoutPagesInput>
  }

  export type NewsUpdateManyWithWhereWithoutPagesInput = {
    where: NewsScalarWhereInput
    data: XOR<NewsUpdateManyMutationInput, NewsUncheckedUpdateManyWithoutNewsInput>
  }

  export type NewsScalarWhereInput = {
    AND?: Enumerable<NewsScalarWhereInput>
    OR?: Enumerable<NewsScalarWhereInput>
    NOT?: Enumerable<NewsScalarWhereInput>
    news_id?: StringFilter | string
    page_id?: IntFilter | number
    title?: StringFilter | string
    brief?: StringFilter | string
    image_id?: StringFilter | string
    content?: StringFilter | string
    is_top?: BoolFilter | boolean
    is_publish?: BoolFilter | boolean
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    created_by?: StringFilter | string
    update_by?: StringFilter | string
  }

  export type ReferenceListItemsCreateWithoutListInput = {
    dictionary_id: number
    code?: string | null
    listitem_value?: string | null
    parent_id?: number | null
    value?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    customer_experiences?: CustomerExperienceCreateNestedManyWithoutListitemsInput
    Dictionary?: DictionaryCreateNestedOneWithoutReference_listitemsInput
    JobReferenceList?: JobReferenceListCreateNestedManyWithoutReference_list_itemInput
  }

  export type ReferenceListItemsUncheckedCreateWithoutListInput = {
    listitem_id?: number
    dictionary_id: number
    code?: string | null
    listitem_value?: string | null
    parent_id?: number | null
    value?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    customer_experiences?: CustomerExperienceUncheckedCreateNestedManyWithoutListitemsInput
    dictionaryDictionaries_id?: string | null
    JobReferenceList?: JobReferenceListUncheckedCreateNestedManyWithoutReference_list_itemInput
  }

  export type ReferenceListItemsCreateOrConnectWithoutListInput = {
    where: ReferenceListItemsWhereUniqueInput
    create: XOR<ReferenceListItemsCreateWithoutListInput, ReferenceListItemsUncheckedCreateWithoutListInput>
  }

  export type ReferenceListItemsCreateManyListInputEnvelope = {
    data: Enumerable<ReferenceListItemsCreateManyListInput>
    skipDuplicates?: boolean
  }

  export type JobReferenceListCreateWithoutReference_listInput = {
    job_reference_id?: string
    job: JobCreateNestedOneWithoutJob_referencesInput
    reference_list_item: ReferenceListItemsCreateNestedOneWithoutJobReferenceListInput
  }

  export type JobReferenceListUncheckedCreateWithoutReference_listInput = {
    job_reference_id?: string
    job_id: string
    reference_list_item_id: number
  }

  export type JobReferenceListCreateOrConnectWithoutReference_listInput = {
    where: JobReferenceListWhereUniqueInput
    create: XOR<JobReferenceListCreateWithoutReference_listInput, JobReferenceListUncheckedCreateWithoutReference_listInput>
  }

  export type JobReferenceListCreateManyReference_listInputEnvelope = {
    data: Enumerable<JobReferenceListCreateManyReference_listInput>
    skipDuplicates?: boolean
  }

  export type ReferenceListItemsUpsertWithWhereUniqueWithoutListInput = {
    where: ReferenceListItemsWhereUniqueInput
    update: XOR<ReferenceListItemsUpdateWithoutListInput, ReferenceListItemsUncheckedUpdateWithoutListInput>
    create: XOR<ReferenceListItemsCreateWithoutListInput, ReferenceListItemsUncheckedCreateWithoutListInput>
  }

  export type ReferenceListItemsUpdateWithWhereUniqueWithoutListInput = {
    where: ReferenceListItemsWhereUniqueInput
    data: XOR<ReferenceListItemsUpdateWithoutListInput, ReferenceListItemsUncheckedUpdateWithoutListInput>
  }

  export type ReferenceListItemsUpdateManyWithWhereWithoutListInput = {
    where: ReferenceListItemsScalarWhereInput
    data: XOR<ReferenceListItemsUpdateManyMutationInput, ReferenceListItemsUncheckedUpdateManyWithoutListitemsInput>
  }

  export type JobReferenceListUpsertWithWhereUniqueWithoutReference_listInput = {
    where: JobReferenceListWhereUniqueInput
    update: XOR<JobReferenceListUpdateWithoutReference_listInput, JobReferenceListUncheckedUpdateWithoutReference_listInput>
    create: XOR<JobReferenceListCreateWithoutReference_listInput, JobReferenceListUncheckedCreateWithoutReference_listInput>
  }

  export type JobReferenceListUpdateWithWhereUniqueWithoutReference_listInput = {
    where: JobReferenceListWhereUniqueInput
    data: XOR<JobReferenceListUpdateWithoutReference_listInput, JobReferenceListUncheckedUpdateWithoutReference_listInput>
  }

  export type JobReferenceListUpdateManyWithWhereWithoutReference_listInput = {
    where: JobReferenceListScalarWhereInput
    data: XOR<JobReferenceListUpdateManyMutationInput, JobReferenceListUncheckedUpdateManyWithoutJobReferenceListInput>
  }

  export type ReferenceListCreateWithoutListitemsInput = {
    list_name: string
    created_at?: Date | string
    JobReferenceList?: JobReferenceListCreateNestedManyWithoutReference_listInput
  }

  export type ReferenceListUncheckedCreateWithoutListitemsInput = {
    list_id?: number
    list_name: string
    created_at?: Date | string
    JobReferenceList?: JobReferenceListUncheckedCreateNestedManyWithoutReference_listInput
  }

  export type ReferenceListCreateOrConnectWithoutListitemsInput = {
    where: ReferenceListWhereUniqueInput
    create: XOR<ReferenceListCreateWithoutListitemsInput, ReferenceListUncheckedCreateWithoutListitemsInput>
  }

  export type CustomerExperienceCreateWithoutListitemsInput = {
    experience_id?: string
    jobdetails: CustomerJobDetailCreateNestedOneWithoutCustomer_experiencesInput
    over_year?: number | null
    created_at?: Date | string
    updated_at?: Date | string | null
    created_by?: string | null
    updated_by?: string | null
  }

  export type CustomerExperienceUncheckedCreateWithoutListitemsInput = {
    experience_id?: string
    jobdetail_id: string
    over_year?: number | null
    created_at?: Date | string
    updated_at?: Date | string | null
    created_by?: string | null
    updated_by?: string | null
  }

  export type CustomerExperienceCreateOrConnectWithoutListitemsInput = {
    where: CustomerExperienceWhereUniqueInput
    create: XOR<CustomerExperienceCreateWithoutListitemsInput, CustomerExperienceUncheckedCreateWithoutListitemsInput>
  }

  export type CustomerExperienceCreateManyListitemsInputEnvelope = {
    data: Enumerable<CustomerExperienceCreateManyListitemsInput>
    skipDuplicates?: boolean
  }

  export type DictionaryCreateWithoutReference_listitemsInput = {
    dictionaries_id?: string
    dictionary_id: number
    language_code: string
    dic_value: string
    created_at?: Date | string
  }

  export type DictionaryUncheckedCreateWithoutReference_listitemsInput = {
    dictionaries_id?: string
    dictionary_id: number
    language_code: string
    dic_value: string
    created_at?: Date | string
  }

  export type DictionaryCreateOrConnectWithoutReference_listitemsInput = {
    where: DictionaryWhereUniqueInput
    create: XOR<DictionaryCreateWithoutReference_listitemsInput, DictionaryUncheckedCreateWithoutReference_listitemsInput>
  }

  export type JobReferenceListCreateWithoutReference_list_itemInput = {
    job_reference_id?: string
    job: JobCreateNestedOneWithoutJob_referencesInput
    reference_list: ReferenceListCreateNestedOneWithoutJobReferenceListInput
  }

  export type JobReferenceListUncheckedCreateWithoutReference_list_itemInput = {
    job_reference_id?: string
    job_id: string
    reference_list_id: number
  }

  export type JobReferenceListCreateOrConnectWithoutReference_list_itemInput = {
    where: JobReferenceListWhereUniqueInput
    create: XOR<JobReferenceListCreateWithoutReference_list_itemInput, JobReferenceListUncheckedCreateWithoutReference_list_itemInput>
  }

  export type JobReferenceListCreateManyReference_list_itemInputEnvelope = {
    data: Enumerable<JobReferenceListCreateManyReference_list_itemInput>
    skipDuplicates?: boolean
  }

  export type ReferenceListUpsertWithoutListitemsInput = {
    update: XOR<ReferenceListUpdateWithoutListitemsInput, ReferenceListUncheckedUpdateWithoutListitemsInput>
    create: XOR<ReferenceListCreateWithoutListitemsInput, ReferenceListUncheckedCreateWithoutListitemsInput>
  }

  export type ReferenceListUpdateWithoutListitemsInput = {
    list_name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    JobReferenceList?: JobReferenceListUpdateManyWithoutReference_listNestedInput
  }

  export type ReferenceListUncheckedUpdateWithoutListitemsInput = {
    list_id?: IntFieldUpdateOperationsInput | number
    list_name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    JobReferenceList?: JobReferenceListUncheckedUpdateManyWithoutReference_listNestedInput
  }

  export type CustomerExperienceUpsertWithWhereUniqueWithoutListitemsInput = {
    where: CustomerExperienceWhereUniqueInput
    update: XOR<CustomerExperienceUpdateWithoutListitemsInput, CustomerExperienceUncheckedUpdateWithoutListitemsInput>
    create: XOR<CustomerExperienceCreateWithoutListitemsInput, CustomerExperienceUncheckedCreateWithoutListitemsInput>
  }

  export type CustomerExperienceUpdateWithWhereUniqueWithoutListitemsInput = {
    where: CustomerExperienceWhereUniqueInput
    data: XOR<CustomerExperienceUpdateWithoutListitemsInput, CustomerExperienceUncheckedUpdateWithoutListitemsInput>
  }

  export type CustomerExperienceUpdateManyWithWhereWithoutListitemsInput = {
    where: CustomerExperienceScalarWhereInput
    data: XOR<CustomerExperienceUpdateManyMutationInput, CustomerExperienceUncheckedUpdateManyWithoutCustomer_experiencesInput>
  }

  export type DictionaryUpsertWithoutReference_listitemsInput = {
    update: XOR<DictionaryUpdateWithoutReference_listitemsInput, DictionaryUncheckedUpdateWithoutReference_listitemsInput>
    create: XOR<DictionaryCreateWithoutReference_listitemsInput, DictionaryUncheckedCreateWithoutReference_listitemsInput>
  }

  export type DictionaryUpdateWithoutReference_listitemsInput = {
    dictionaries_id?: StringFieldUpdateOperationsInput | string
    dictionary_id?: IntFieldUpdateOperationsInput | number
    language_code?: StringFieldUpdateOperationsInput | string
    dic_value?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DictionaryUncheckedUpdateWithoutReference_listitemsInput = {
    dictionaries_id?: StringFieldUpdateOperationsInput | string
    dictionary_id?: IntFieldUpdateOperationsInput | number
    language_code?: StringFieldUpdateOperationsInput | string
    dic_value?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JobReferenceListUpsertWithWhereUniqueWithoutReference_list_itemInput = {
    where: JobReferenceListWhereUniqueInput
    update: XOR<JobReferenceListUpdateWithoutReference_list_itemInput, JobReferenceListUncheckedUpdateWithoutReference_list_itemInput>
    create: XOR<JobReferenceListCreateWithoutReference_list_itemInput, JobReferenceListUncheckedCreateWithoutReference_list_itemInput>
  }

  export type JobReferenceListUpdateWithWhereUniqueWithoutReference_list_itemInput = {
    where: JobReferenceListWhereUniqueInput
    data: XOR<JobReferenceListUpdateWithoutReference_list_itemInput, JobReferenceListUncheckedUpdateWithoutReference_list_itemInput>
  }

  export type JobReferenceListUpdateManyWithWhereWithoutReference_list_itemInput = {
    where: JobReferenceListScalarWhereInput
    data: XOR<JobReferenceListUpdateManyMutationInput, JobReferenceListUncheckedUpdateManyWithoutJobReferenceListInput>
  }

  export type UserCreateWithoutScoutFavInput = {
    user_id?: string
    email: string
    mobile?: string | null
    name?: string | null
    password_hash: string
    role?: UserRole
    company_id?: number
    attemptpass_count?: number | null
    reset_code?: string
    is_emailverified?: boolean
    is_mobileverified?: boolean
    user_status?: UserStatus
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    favs: JsonNullValueInput | InputJsonValue
    Customer?: CustomerCreateNestedOneWithoutUserInput
    loggers?: LoggerCreateNestedManyWithoutUserInput
    from_inquiries?: InquiryCreateNestedManyWithoutFromuserInput
    assign_inquiries?: InquiryCreateNestedManyWithoutAssignUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutScoutFavInput = {
    user_id?: string
    email: string
    mobile?: string | null
    name?: string | null
    password_hash: string
    role?: UserRole
    company_id?: number
    customer_id?: string | null
    attemptpass_count?: number | null
    reset_code?: string
    is_emailverified?: boolean
    is_mobileverified?: boolean
    user_status?: UserStatus
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    favs: JsonNullValueInput | InputJsonValue
    loggers?: LoggerUncheckedCreateNestedManyWithoutUserInput
    from_inquiries?: InquiryUncheckedCreateNestedManyWithoutFromuserInput
    assign_inquiries?: InquiryUncheckedCreateNestedManyWithoutAssignUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutScoutFavInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutScoutFavInput, UserUncheckedCreateWithoutScoutFavInput>
  }

  export type UserUpsertWithoutScoutFavInput = {
    update: XOR<UserUpdateWithoutScoutFavInput, UserUncheckedUpdateWithoutScoutFavInput>
    create: XOR<UserCreateWithoutScoutFavInput, UserUncheckedCreateWithoutScoutFavInput>
  }

  export type UserUpdateWithoutScoutFavInput = {
    user_id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | UserRole
    company_id?: IntFieldUpdateOperationsInput | number
    attemptpass_count?: NullableIntFieldUpdateOperationsInput | number | null
    reset_code?: StringFieldUpdateOperationsInput | string
    is_emailverified?: BoolFieldUpdateOperationsInput | boolean
    is_mobileverified?: BoolFieldUpdateOperationsInput | boolean
    user_status?: EnumUserStatusFieldUpdateOperationsInput | UserStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    favs?: JsonNullValueInput | InputJsonValue
    Customer?: CustomerUpdateOneWithoutUserNestedInput
    loggers?: LoggerUpdateManyWithoutUserNestedInput
    from_inquiries?: InquiryUpdateManyWithoutFromuserNestedInput
    assign_inquiries?: InquiryUpdateManyWithoutAssignUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutScoutFavInput = {
    user_id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | UserRole
    company_id?: IntFieldUpdateOperationsInput | number
    customer_id?: NullableStringFieldUpdateOperationsInput | string | null
    attemptpass_count?: NullableIntFieldUpdateOperationsInput | number | null
    reset_code?: StringFieldUpdateOperationsInput | string
    is_emailverified?: BoolFieldUpdateOperationsInput | boolean
    is_mobileverified?: BoolFieldUpdateOperationsInput | boolean
    user_status?: EnumUserStatusFieldUpdateOperationsInput | UserStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    favs?: JsonNullValueInput | InputJsonValue
    loggers?: LoggerUncheckedUpdateManyWithoutUserNestedInput
    from_inquiries?: InquiryUncheckedUpdateManyWithoutFromuserNestedInput
    assign_inquiries?: InquiryUncheckedUpdateManyWithoutAssignUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CustomerCreateWithoutUserInput = {
    customer_id?: string
    first_name: string
    last_name: string
    first_name_kana: string
    last_name_kana: string
    gender?: Gender | null
    birth_date?: Date | string | null
    spouse?: NullableJsonNullValueInput | InputJsonValue
    family_size?: number | null
    email?: string | null
    mobile?: string | null
    phone?: string | null
    profile_image?: string | null
    cv_file?: string | null
    resume_file?: string | null
    prefecture?: NullableJsonNullValueInput | InputJsonValue
    post_code?: string | null
    city?: string | null
    district?: string | null
    address?: string | null
    address1?: string | null
    nearest_station?: string | null
    socials?: NullableJsonNullValueInput | InputJsonValue
    country?: string | null
    experienced_year?: number | null
    from_data?: number | null
    status_customer?: CustomerStatus | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: string | null
    updated_by?: string | null
    customer_visas?: CustomerVisaCreateNestedManyWithoutCustomerInput
    customer_jobdetails?: CustomerJobDetailCreateNestedManyWithoutCustomerInput
    customer_educations?: CustomerEducationCreateNestedManyWithoutCustomerInput
    customer_languages?: CustomerLanguageCreateNestedManyWithoutCustomerInput
    customer_qualifications?: CustomerQualificationCreateNestedManyWithoutCustomersInput
    customer_workhistories?: CustomerWorkHistoryCreateNestedManyWithoutCustomerInput
    job_candidates?: JobCandidateCreateNestedManyWithoutCustomerInput
    customer_desired?: CustomerDesiredCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutUserInput = {
    customer_id?: string
    first_name: string
    last_name: string
    first_name_kana: string
    last_name_kana: string
    gender?: Gender | null
    birth_date?: Date | string | null
    spouse?: NullableJsonNullValueInput | InputJsonValue
    family_size?: number | null
    email?: string | null
    mobile?: string | null
    phone?: string | null
    profile_image?: string | null
    cv_file?: string | null
    resume_file?: string | null
    prefecture?: NullableJsonNullValueInput | InputJsonValue
    post_code?: string | null
    city?: string | null
    district?: string | null
    address?: string | null
    address1?: string | null
    nearest_station?: string | null
    socials?: NullableJsonNullValueInput | InputJsonValue
    country?: string | null
    experienced_year?: number | null
    from_data?: number | null
    status_customer?: CustomerStatus | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: string | null
    updated_by?: string | null
    customer_visas?: CustomerVisaUncheckedCreateNestedManyWithoutCustomerInput
    customer_jobdetails?: CustomerJobDetailUncheckedCreateNestedManyWithoutCustomerInput
    customer_educations?: CustomerEducationUncheckedCreateNestedManyWithoutCustomerInput
    customer_languages?: CustomerLanguageUncheckedCreateNestedManyWithoutCustomerInput
    customer_qualifications?: CustomerQualificationUncheckedCreateNestedManyWithoutCustomersInput
    customer_workhistories?: CustomerWorkHistoryUncheckedCreateNestedManyWithoutCustomerInput
    job_candidates?: JobCandidateUncheckedCreateNestedManyWithoutCustomerInput
    customer_desired?: CustomerDesiredUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutUserInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutUserInput, CustomerUncheckedCreateWithoutUserInput>
  }

  export type LoggerCreateWithoutUserInput = {
    log_id?: string
    action_user?: UserAction
    new_value?: NullableJsonNullValueInput | InputJsonValue
    old_value?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: string | null
    updated_by?: string | null
  }

  export type LoggerUncheckedCreateWithoutUserInput = {
    log_id?: string
    action_user?: UserAction
    new_value?: NullableJsonNullValueInput | InputJsonValue
    old_value?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: string | null
    updated_by?: string | null
  }

  export type LoggerCreateOrConnectWithoutUserInput = {
    where: LoggerWhereUniqueInput
    create: XOR<LoggerCreateWithoutUserInput, LoggerUncheckedCreateWithoutUserInput>
  }

  export type LoggerCreateManyUserInputEnvelope = {
    data: Enumerable<LoggerCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type InquiryCreateWithoutFromuserInput = {
    inquire_id?: string
    parent_id?: string | null
    entity?: EntityCreateNestedOneWithoutInquiriesInput
    assignUser?: UserCreateNestedOneWithoutAssign_inquiriesInput
    subject: string
    body: string
    inquiry_status?: InquiryStatus | null
    is_read?: boolean
    is_answer?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: string | null
  }

  export type InquiryUncheckedCreateWithoutFromuserInput = {
    inquire_id?: string
    parent_id?: string | null
    entity_id?: number | null
    assigned_user_id?: string | null
    subject: string
    body: string
    inquiry_status?: InquiryStatus | null
    is_read?: boolean
    is_answer?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: string | null
  }

  export type InquiryCreateOrConnectWithoutFromuserInput = {
    where: InquiryWhereUniqueInput
    create: XOR<InquiryCreateWithoutFromuserInput, InquiryUncheckedCreateWithoutFromuserInput>
  }

  export type InquiryCreateManyFromuserInputEnvelope = {
    data: Enumerable<InquiryCreateManyFromuserInput>
    skipDuplicates?: boolean
  }

  export type InquiryCreateWithoutAssignUserInput = {
    inquire_id?: string
    parent_id?: string | null
    fromuser?: UserCreateNestedOneWithoutFrom_inquiriesInput
    entity?: EntityCreateNestedOneWithoutInquiriesInput
    subject: string
    body: string
    inquiry_status?: InquiryStatus | null
    is_read?: boolean
    is_answer?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: string | null
  }

  export type InquiryUncheckedCreateWithoutAssignUserInput = {
    inquire_id?: string
    parent_id?: string | null
    fromuser_id?: string | null
    entity_id?: number | null
    subject: string
    body: string
    inquiry_status?: InquiryStatus | null
    is_read?: boolean
    is_answer?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: string | null
  }

  export type InquiryCreateOrConnectWithoutAssignUserInput = {
    where: InquiryWhereUniqueInput
    create: XOR<InquiryCreateWithoutAssignUserInput, InquiryUncheckedCreateWithoutAssignUserInput>
  }

  export type InquiryCreateManyAssignUserInputEnvelope = {
    data: Enumerable<InquiryCreateManyAssignUserInput>
    skipDuplicates?: boolean
  }

  export type NotificationCreateWithoutUserInput = {
    notifiation_id?: string
    link: string
    message: string
    is_new?: boolean
    is_badge?: boolean
    created_at?: Date | string
    created_by: string
  }

  export type NotificationUncheckedCreateWithoutUserInput = {
    notifiation_id?: string
    link: string
    message: string
    is_new?: boolean
    is_badge?: boolean
    created_at?: Date | string
    created_by: string
  }

  export type NotificationCreateOrConnectWithoutUserInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationCreateManyUserInputEnvelope = {
    data: Enumerable<NotificationCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type ScoutFavCreateWithoutUserInput = {
    scout_id?: string
    entity_id?: number | null
    branch_id?: number | null
    job_id?: string | null
    note: string
    created_at?: Date | string
    created_by: string
  }

  export type ScoutFavUncheckedCreateWithoutUserInput = {
    scout_id?: string
    entity_id?: number | null
    branch_id?: number | null
    job_id?: string | null
    note: string
    created_at?: Date | string
    created_by: string
  }

  export type ScoutFavCreateOrConnectWithoutUserInput = {
    where: ScoutFavWhereUniqueInput
    create: XOR<ScoutFavCreateWithoutUserInput, ScoutFavUncheckedCreateWithoutUserInput>
  }

  export type ScoutFavCreateManyUserInputEnvelope = {
    data: Enumerable<ScoutFavCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type CustomerUpsertWithoutUserInput = {
    update: XOR<CustomerUpdateWithoutUserInput, CustomerUncheckedUpdateWithoutUserInput>
    create: XOR<CustomerCreateWithoutUserInput, CustomerUncheckedCreateWithoutUserInput>
  }

  export type CustomerUpdateWithoutUserInput = {
    customer_id?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    first_name_kana?: StringFieldUpdateOperationsInput | string
    last_name_kana?: StringFieldUpdateOperationsInput | string
    gender?: NullableEnumGenderFieldUpdateOperationsInput | Gender | null
    birth_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    spouse?: NullableJsonNullValueInput | InputJsonValue
    family_size?: NullableIntFieldUpdateOperationsInput | number | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profile_image?: NullableStringFieldUpdateOperationsInput | string | null
    cv_file?: NullableStringFieldUpdateOperationsInput | string | null
    resume_file?: NullableStringFieldUpdateOperationsInput | string | null
    prefecture?: NullableJsonNullValueInput | InputJsonValue
    post_code?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    address1?: NullableStringFieldUpdateOperationsInput | string | null
    nearest_station?: NullableStringFieldUpdateOperationsInput | string | null
    socials?: NullableJsonNullValueInput | InputJsonValue
    country?: NullableStringFieldUpdateOperationsInput | string | null
    experienced_year?: NullableIntFieldUpdateOperationsInput | number | null
    from_data?: NullableIntFieldUpdateOperationsInput | number | null
    status_customer?: NullableEnumCustomerStatusFieldUpdateOperationsInput | CustomerStatus | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    customer_visas?: CustomerVisaUpdateManyWithoutCustomerNestedInput
    customer_jobdetails?: CustomerJobDetailUpdateManyWithoutCustomerNestedInput
    customer_educations?: CustomerEducationUpdateManyWithoutCustomerNestedInput
    customer_languages?: CustomerLanguageUpdateManyWithoutCustomerNestedInput
    customer_qualifications?: CustomerQualificationUpdateManyWithoutCustomersNestedInput
    customer_workhistories?: CustomerWorkHistoryUpdateManyWithoutCustomerNestedInput
    job_candidates?: JobCandidateUpdateManyWithoutCustomerNestedInput
    customer_desired?: CustomerDesiredUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutUserInput = {
    customer_id?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    first_name_kana?: StringFieldUpdateOperationsInput | string
    last_name_kana?: StringFieldUpdateOperationsInput | string
    gender?: NullableEnumGenderFieldUpdateOperationsInput | Gender | null
    birth_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    spouse?: NullableJsonNullValueInput | InputJsonValue
    family_size?: NullableIntFieldUpdateOperationsInput | number | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profile_image?: NullableStringFieldUpdateOperationsInput | string | null
    cv_file?: NullableStringFieldUpdateOperationsInput | string | null
    resume_file?: NullableStringFieldUpdateOperationsInput | string | null
    prefecture?: NullableJsonNullValueInput | InputJsonValue
    post_code?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    address1?: NullableStringFieldUpdateOperationsInput | string | null
    nearest_station?: NullableStringFieldUpdateOperationsInput | string | null
    socials?: NullableJsonNullValueInput | InputJsonValue
    country?: NullableStringFieldUpdateOperationsInput | string | null
    experienced_year?: NullableIntFieldUpdateOperationsInput | number | null
    from_data?: NullableIntFieldUpdateOperationsInput | number | null
    status_customer?: NullableEnumCustomerStatusFieldUpdateOperationsInput | CustomerStatus | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    customer_visas?: CustomerVisaUncheckedUpdateManyWithoutCustomerNestedInput
    customer_jobdetails?: CustomerJobDetailUncheckedUpdateManyWithoutCustomerNestedInput
    customer_educations?: CustomerEducationUncheckedUpdateManyWithoutCustomerNestedInput
    customer_languages?: CustomerLanguageUncheckedUpdateManyWithoutCustomerNestedInput
    customer_qualifications?: CustomerQualificationUncheckedUpdateManyWithoutCustomersNestedInput
    customer_workhistories?: CustomerWorkHistoryUncheckedUpdateManyWithoutCustomerNestedInput
    job_candidates?: JobCandidateUncheckedUpdateManyWithoutCustomerNestedInput
    customer_desired?: CustomerDesiredUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type LoggerUpsertWithWhereUniqueWithoutUserInput = {
    where: LoggerWhereUniqueInput
    update: XOR<LoggerUpdateWithoutUserInput, LoggerUncheckedUpdateWithoutUserInput>
    create: XOR<LoggerCreateWithoutUserInput, LoggerUncheckedCreateWithoutUserInput>
  }

  export type LoggerUpdateWithWhereUniqueWithoutUserInput = {
    where: LoggerWhereUniqueInput
    data: XOR<LoggerUpdateWithoutUserInput, LoggerUncheckedUpdateWithoutUserInput>
  }

  export type LoggerUpdateManyWithWhereWithoutUserInput = {
    where: LoggerScalarWhereInput
    data: XOR<LoggerUpdateManyMutationInput, LoggerUncheckedUpdateManyWithoutLoggersInput>
  }

  export type LoggerScalarWhereInput = {
    AND?: Enumerable<LoggerScalarWhereInput>
    OR?: Enumerable<LoggerScalarWhereInput>
    NOT?: Enumerable<LoggerScalarWhereInput>
    log_id?: StringFilter | string
    action_user?: EnumUserActionFilter | UserAction
    user_id?: StringNullableFilter | string | null
    new_value?: JsonNullableFilter
    old_value?: JsonNullableFilter
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    created_by?: StringNullableFilter | string | null
    updated_by?: StringNullableFilter | string | null
  }

  export type InquiryUpsertWithWhereUniqueWithoutFromuserInput = {
    where: InquiryWhereUniqueInput
    update: XOR<InquiryUpdateWithoutFromuserInput, InquiryUncheckedUpdateWithoutFromuserInput>
    create: XOR<InquiryCreateWithoutFromuserInput, InquiryUncheckedCreateWithoutFromuserInput>
  }

  export type InquiryUpdateWithWhereUniqueWithoutFromuserInput = {
    where: InquiryWhereUniqueInput
    data: XOR<InquiryUpdateWithoutFromuserInput, InquiryUncheckedUpdateWithoutFromuserInput>
  }

  export type InquiryUpdateManyWithWhereWithoutFromuserInput = {
    where: InquiryScalarWhereInput
    data: XOR<InquiryUpdateManyMutationInput, InquiryUncheckedUpdateManyWithoutFrom_inquiriesInput>
  }

  export type InquiryUpsertWithWhereUniqueWithoutAssignUserInput = {
    where: InquiryWhereUniqueInput
    update: XOR<InquiryUpdateWithoutAssignUserInput, InquiryUncheckedUpdateWithoutAssignUserInput>
    create: XOR<InquiryCreateWithoutAssignUserInput, InquiryUncheckedCreateWithoutAssignUserInput>
  }

  export type InquiryUpdateWithWhereUniqueWithoutAssignUserInput = {
    where: InquiryWhereUniqueInput
    data: XOR<InquiryUpdateWithoutAssignUserInput, InquiryUncheckedUpdateWithoutAssignUserInput>
  }

  export type InquiryUpdateManyWithWhereWithoutAssignUserInput = {
    where: InquiryScalarWhereInput
    data: XOR<InquiryUpdateManyMutationInput, InquiryUncheckedUpdateManyWithoutAssign_inquiriesInput>
  }

  export type NotificationUpsertWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
  }

  export type NotificationUpdateManyWithWhereWithoutUserInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutNotificationsInput>
  }

  export type NotificationScalarWhereInput = {
    AND?: Enumerable<NotificationScalarWhereInput>
    OR?: Enumerable<NotificationScalarWhereInput>
    NOT?: Enumerable<NotificationScalarWhereInput>
    notifiation_id?: StringFilter | string
    user_id?: StringFilter | string
    link?: StringFilter | string
    message?: StringFilter | string
    is_new?: BoolFilter | boolean
    is_badge?: BoolFilter | boolean
    created_at?: DateTimeFilter | Date | string
    created_by?: StringFilter | string
  }

  export type ScoutFavUpsertWithWhereUniqueWithoutUserInput = {
    where: ScoutFavWhereUniqueInput
    update: XOR<ScoutFavUpdateWithoutUserInput, ScoutFavUncheckedUpdateWithoutUserInput>
    create: XOR<ScoutFavCreateWithoutUserInput, ScoutFavUncheckedCreateWithoutUserInput>
  }

  export type ScoutFavUpdateWithWhereUniqueWithoutUserInput = {
    where: ScoutFavWhereUniqueInput
    data: XOR<ScoutFavUpdateWithoutUserInput, ScoutFavUncheckedUpdateWithoutUserInput>
  }

  export type ScoutFavUpdateManyWithWhereWithoutUserInput = {
    where: ScoutFavScalarWhereInput
    data: XOR<ScoutFavUpdateManyMutationInput, ScoutFavUncheckedUpdateManyWithoutScoutFavInput>
  }

  export type ScoutFavScalarWhereInput = {
    AND?: Enumerable<ScoutFavScalarWhereInput>
    OR?: Enumerable<ScoutFavScalarWhereInput>
    NOT?: Enumerable<ScoutFavScalarWhereInput>
    scout_id?: StringFilter | string
    entity_id?: IntNullableFilter | number | null
    branch_id?: IntNullableFilter | number | null
    user_id?: StringFilter | string
    job_id?: StringNullableFilter | string | null
    note?: StringFilter | string
    created_at?: DateTimeFilter | Date | string
    created_by?: StringFilter | string
  }

  export type CustomerVisaCreateManyCustomerInput = {
    visa_id?: string
    status_visa?: StatusVisa | null
    date_expire?: Date | string | null
    country_citizenship?: string | null
    back_visafile?: string | null
    front_visafile?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: string | null
    updated_by?: string | null
  }

  export type CustomerJobDetailCreateManyCustomerInput = {
    jobdetail_id?: string
    experienced_company?: number
    annual_income?: number | null
    has_management_exp?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: string | null
    updated_by?: string | null
  }

  export type CustomerEducationCreateManyCustomerInput = {
    education_id?: string
    country?: string | null
    degree?: NullableJsonNullValueInput | InputJsonValue
    entrollment_date?: Date | string | null
    graduate_date?: Date | string | null
    is_current?: boolean | null
    school_id?: number | null
    school?: NullableJsonNullValueInput | InputJsonValue
    faculty?: string | null
    department?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: string | null
    updated_by?: string | null
  }

  export type CustomerLanguageCreateManyCustomerInput = {
    language_id?: string
    level?: LanguageLevel | null
    language?: number | null
    is_motherlanguage?: boolean
    certificate?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string | null
    created_by?: string | null
    updated_b?: string | null
  }

  export type CustomerQualificationCreateManyCustomersInput = {
    qualification_id?: string
    qualification?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: string | null
    updated_by?: string | null
  }

  export type CustomerWorkHistoryCreateManyCustomerInput = {
    workhistory_id?: string
    company_id?: string | null
    company_info?: NullableJsonNullValueInput | InputJsonValue
    occupation?: NullableJsonNullValueInput | InputJsonValue
    industry?: NullableJsonNullValueInput | InputJsonValue
    position?: JobPosition | null
    enter_date?: Date | string | null
    leave_date?: Date | string | null
    working_month?: number | null
    is_current?: boolean | null
    duties?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: string | null
    updated_by?: string | null
  }

  export type JobCandidateCreateManyCustomerInput = {
    job_candidate_id?: string
    job_id: string
    candidate_status: number
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: string | null
    updated_by?: string | null
  }

  export type CustomerDesiredCreateManyCustomerInput = {
    desired_id?: string
    occupation?: CustomerDesiredCreateoccupationInput | Enumerable<InputJsonValue>
    industry?: CustomerDesiredCreateindustryInput | Enumerable<InputJsonValue>
    location?: CustomerDesiredCreatelocationInput | Enumerable<InputJsonValue>
    career_level?: CustomerDesiredCreatecareer_levelInput | Enumerable<InputJsonValue>
    contract_type?: CustomerDesiredCreatecontract_typeInput | Enumerable<InputJsonValue>
    desired_company?: CustomerDesiredCreatedesired_companyInput | Enumerable<InputJsonValue>
    time_to: string
    annual_income: number
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: string | null
    updated_by?: string | null
  }

  export type CustomerVisaUpdateWithoutCustomerInput = {
    visa_id?: StringFieldUpdateOperationsInput | string
    status_visa?: NullableEnumStatusVisaFieldUpdateOperationsInput | StatusVisa | null
    date_expire?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    country_citizenship?: NullableStringFieldUpdateOperationsInput | string | null
    back_visafile?: NullableStringFieldUpdateOperationsInput | string | null
    front_visafile?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CustomerVisaUncheckedUpdateWithoutCustomerInput = {
    visa_id?: StringFieldUpdateOperationsInput | string
    status_visa?: NullableEnumStatusVisaFieldUpdateOperationsInput | StatusVisa | null
    date_expire?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    country_citizenship?: NullableStringFieldUpdateOperationsInput | string | null
    back_visafile?: NullableStringFieldUpdateOperationsInput | string | null
    front_visafile?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CustomerVisaUncheckedUpdateManyWithoutCustomer_visasInput = {
    visa_id?: StringFieldUpdateOperationsInput | string
    status_visa?: NullableEnumStatusVisaFieldUpdateOperationsInput | StatusVisa | null
    date_expire?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    country_citizenship?: NullableStringFieldUpdateOperationsInput | string | null
    back_visafile?: NullableStringFieldUpdateOperationsInput | string | null
    front_visafile?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CustomerJobDetailUpdateWithoutCustomerInput = {
    jobdetail_id?: StringFieldUpdateOperationsInput | string
    customer_experiences?: CustomerExperienceUpdateManyWithoutJobdetailsNestedInput
    experienced_company?: IntFieldUpdateOperationsInput | number
    annual_income?: NullableIntFieldUpdateOperationsInput | number | null
    has_management_exp?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CustomerJobDetailUncheckedUpdateWithoutCustomerInput = {
    jobdetail_id?: StringFieldUpdateOperationsInput | string
    customer_experiences?: CustomerExperienceUncheckedUpdateManyWithoutJobdetailsNestedInput
    experienced_company?: IntFieldUpdateOperationsInput | number
    annual_income?: NullableIntFieldUpdateOperationsInput | number | null
    has_management_exp?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CustomerJobDetailUncheckedUpdateManyWithoutCustomer_jobdetailsInput = {
    jobdetail_id?: StringFieldUpdateOperationsInput | string
    experienced_company?: IntFieldUpdateOperationsInput | number
    annual_income?: NullableIntFieldUpdateOperationsInput | number | null
    has_management_exp?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CustomerEducationUpdateWithoutCustomerInput = {
    education_id?: StringFieldUpdateOperationsInput | string
    country?: NullableStringFieldUpdateOperationsInput | string | null
    degree?: NullableJsonNullValueInput | InputJsonValue
    entrollment_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    graduate_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_current?: NullableBoolFieldUpdateOperationsInput | boolean | null
    school_id?: NullableIntFieldUpdateOperationsInput | number | null
    school?: NullableJsonNullValueInput | InputJsonValue
    faculty?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CustomerEducationUncheckedUpdateWithoutCustomerInput = {
    education_id?: StringFieldUpdateOperationsInput | string
    country?: NullableStringFieldUpdateOperationsInput | string | null
    degree?: NullableJsonNullValueInput | InputJsonValue
    entrollment_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    graduate_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_current?: NullableBoolFieldUpdateOperationsInput | boolean | null
    school_id?: NullableIntFieldUpdateOperationsInput | number | null
    school?: NullableJsonNullValueInput | InputJsonValue
    faculty?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CustomerEducationUncheckedUpdateManyWithoutCustomer_educationsInput = {
    education_id?: StringFieldUpdateOperationsInput | string
    country?: NullableStringFieldUpdateOperationsInput | string | null
    degree?: NullableJsonNullValueInput | InputJsonValue
    entrollment_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    graduate_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_current?: NullableBoolFieldUpdateOperationsInput | boolean | null
    school_id?: NullableIntFieldUpdateOperationsInput | number | null
    school?: NullableJsonNullValueInput | InputJsonValue
    faculty?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CustomerLanguageUpdateWithoutCustomerInput = {
    language_id?: StringFieldUpdateOperationsInput | string
    level?: NullableEnumLanguageLevelFieldUpdateOperationsInput | LanguageLevel | null
    language?: NullableIntFieldUpdateOperationsInput | number | null
    is_motherlanguage?: BoolFieldUpdateOperationsInput | boolean
    certificate?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_b?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CustomerLanguageUncheckedUpdateWithoutCustomerInput = {
    language_id?: StringFieldUpdateOperationsInput | string
    level?: NullableEnumLanguageLevelFieldUpdateOperationsInput | LanguageLevel | null
    language?: NullableIntFieldUpdateOperationsInput | number | null
    is_motherlanguage?: BoolFieldUpdateOperationsInput | boolean
    certificate?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_b?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CustomerLanguageUncheckedUpdateManyWithoutCustomer_languagesInput = {
    language_id?: StringFieldUpdateOperationsInput | string
    level?: NullableEnumLanguageLevelFieldUpdateOperationsInput | LanguageLevel | null
    language?: NullableIntFieldUpdateOperationsInput | number | null
    is_motherlanguage?: BoolFieldUpdateOperationsInput | boolean
    certificate?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_b?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CustomerQualificationUpdateWithoutCustomersInput = {
    qualification_id?: StringFieldUpdateOperationsInput | string
    qualification?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CustomerQualificationUncheckedUpdateWithoutCustomersInput = {
    qualification_id?: StringFieldUpdateOperationsInput | string
    qualification?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CustomerQualificationUncheckedUpdateManyWithoutCustomer_qualificationsInput = {
    qualification_id?: StringFieldUpdateOperationsInput | string
    qualification?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CustomerWorkHistoryUpdateWithoutCustomerInput = {
    workhistory_id?: StringFieldUpdateOperationsInput | string
    company_id?: NullableStringFieldUpdateOperationsInput | string | null
    company_info?: NullableJsonNullValueInput | InputJsonValue
    occupation?: NullableJsonNullValueInput | InputJsonValue
    industry?: NullableJsonNullValueInput | InputJsonValue
    position?: NullableEnumJobPositionFieldUpdateOperationsInput | JobPosition | null
    enter_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    leave_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    working_month?: NullableIntFieldUpdateOperationsInput | number | null
    is_current?: NullableBoolFieldUpdateOperationsInput | boolean | null
    duties?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CustomerWorkHistoryUncheckedUpdateWithoutCustomerInput = {
    workhistory_id?: StringFieldUpdateOperationsInput | string
    company_id?: NullableStringFieldUpdateOperationsInput | string | null
    company_info?: NullableJsonNullValueInput | InputJsonValue
    occupation?: NullableJsonNullValueInput | InputJsonValue
    industry?: NullableJsonNullValueInput | InputJsonValue
    position?: NullableEnumJobPositionFieldUpdateOperationsInput | JobPosition | null
    enter_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    leave_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    working_month?: NullableIntFieldUpdateOperationsInput | number | null
    is_current?: NullableBoolFieldUpdateOperationsInput | boolean | null
    duties?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CustomerWorkHistoryUncheckedUpdateManyWithoutCustomer_workhistoriesInput = {
    workhistory_id?: StringFieldUpdateOperationsInput | string
    company_id?: NullableStringFieldUpdateOperationsInput | string | null
    company_info?: NullableJsonNullValueInput | InputJsonValue
    occupation?: NullableJsonNullValueInput | InputJsonValue
    industry?: NullableJsonNullValueInput | InputJsonValue
    position?: NullableEnumJobPositionFieldUpdateOperationsInput | JobPosition | null
    enter_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    leave_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    working_month?: NullableIntFieldUpdateOperationsInput | number | null
    is_current?: NullableBoolFieldUpdateOperationsInput | boolean | null
    duties?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type JobCandidateUpdateWithoutCustomerInput = {
    job_candidate_id?: StringFieldUpdateOperationsInput | string
    job?: JobUpdateOneRequiredWithoutJob_candidatesNestedInput
    candidate_status?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type JobCandidateUncheckedUpdateWithoutCustomerInput = {
    job_candidate_id?: StringFieldUpdateOperationsInput | string
    job_id?: StringFieldUpdateOperationsInput | string
    candidate_status?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type JobCandidateUncheckedUpdateManyWithoutJob_candidatesInput = {
    job_candidate_id?: StringFieldUpdateOperationsInput | string
    job_id?: StringFieldUpdateOperationsInput | string
    candidate_status?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CustomerDesiredUpdateWithoutCustomerInput = {
    desired_id?: StringFieldUpdateOperationsInput | string
    occupation?: CustomerDesiredUpdateoccupationInput | Enumerable<InputJsonValue>
    industry?: CustomerDesiredUpdateindustryInput | Enumerable<InputJsonValue>
    location?: CustomerDesiredUpdatelocationInput | Enumerable<InputJsonValue>
    career_level?: CustomerDesiredUpdatecareer_levelInput | Enumerable<InputJsonValue>
    contract_type?: CustomerDesiredUpdatecontract_typeInput | Enumerable<InputJsonValue>
    desired_company?: CustomerDesiredUpdatedesired_companyInput | Enumerable<InputJsonValue>
    time_to?: StringFieldUpdateOperationsInput | string
    annual_income?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CustomerDesiredUncheckedUpdateWithoutCustomerInput = {
    desired_id?: StringFieldUpdateOperationsInput | string
    occupation?: CustomerDesiredUpdateoccupationInput | Enumerable<InputJsonValue>
    industry?: CustomerDesiredUpdateindustryInput | Enumerable<InputJsonValue>
    location?: CustomerDesiredUpdatelocationInput | Enumerable<InputJsonValue>
    career_level?: CustomerDesiredUpdatecareer_levelInput | Enumerable<InputJsonValue>
    contract_type?: CustomerDesiredUpdatecontract_typeInput | Enumerable<InputJsonValue>
    desired_company?: CustomerDesiredUpdatedesired_companyInput | Enumerable<InputJsonValue>
    time_to?: StringFieldUpdateOperationsInput | string
    annual_income?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CustomerDesiredUncheckedUpdateManyWithoutCustomer_desiredInput = {
    desired_id?: StringFieldUpdateOperationsInput | string
    occupation?: CustomerDesiredUpdateoccupationInput | Enumerable<InputJsonValue>
    industry?: CustomerDesiredUpdateindustryInput | Enumerable<InputJsonValue>
    location?: CustomerDesiredUpdatelocationInput | Enumerable<InputJsonValue>
    career_level?: CustomerDesiredUpdatecareer_levelInput | Enumerable<InputJsonValue>
    contract_type?: CustomerDesiredUpdatecontract_typeInput | Enumerable<InputJsonValue>
    desired_company?: CustomerDesiredUpdatedesired_companyInput | Enumerable<InputJsonValue>
    time_to?: StringFieldUpdateOperationsInput | string
    annual_income?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CustomerExperienceCreateManyJobdetailsInput = {
    experience_id?: string
    skill_id: number
    over_year?: number | null
    created_at?: Date | string
    updated_at?: Date | string | null
    created_by?: string | null
    updated_by?: string | null
  }

  export type CustomerExperienceUpdateWithoutJobdetailsInput = {
    experience_id?: StringFieldUpdateOperationsInput | string
    listitems?: ReferenceListItemsUpdateOneRequiredWithoutCustomer_experiencesNestedInput
    over_year?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CustomerExperienceUncheckedUpdateWithoutJobdetailsInput = {
    experience_id?: StringFieldUpdateOperationsInput | string
    skill_id?: IntFieldUpdateOperationsInput | number
    over_year?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CustomerExperienceUncheckedUpdateManyWithoutCustomer_experiencesInput = {
    experience_id?: StringFieldUpdateOperationsInput | string
    skill_id?: IntFieldUpdateOperationsInput | number
    over_year?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ReferenceListItemsCreateManyDictionaryInput = {
    listitem_id?: number
    list_id: number
    dictionary_id: number
    code?: string | null
    listitem_value?: string | null
    parent_id?: number | null
    value?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ReferenceListItemsUpdateWithoutDictionaryInput = {
    list?: ReferenceListUpdateOneRequiredWithoutListitemsNestedInput
    dictionary_id?: IntFieldUpdateOperationsInput | number
    code?: NullableStringFieldUpdateOperationsInput | string | null
    listitem_value?: NullableStringFieldUpdateOperationsInput | string | null
    parent_id?: NullableIntFieldUpdateOperationsInput | number | null
    value?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    customer_experiences?: CustomerExperienceUpdateManyWithoutListitemsNestedInput
    JobReferenceList?: JobReferenceListUpdateManyWithoutReference_list_itemNestedInput
  }

  export type ReferenceListItemsUncheckedUpdateWithoutDictionaryInput = {
    listitem_id?: IntFieldUpdateOperationsInput | number
    list_id?: IntFieldUpdateOperationsInput | number
    dictionary_id?: IntFieldUpdateOperationsInput | number
    code?: NullableStringFieldUpdateOperationsInput | string | null
    listitem_value?: NullableStringFieldUpdateOperationsInput | string | null
    parent_id?: NullableIntFieldUpdateOperationsInput | number | null
    value?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    customer_experiences?: CustomerExperienceUncheckedUpdateManyWithoutListitemsNestedInput
    JobReferenceList?: JobReferenceListUncheckedUpdateManyWithoutReference_list_itemNestedInput
  }

  export type ReferenceListItemsUncheckedUpdateManyWithoutReference_listitemsInput = {
    listitem_id?: IntFieldUpdateOperationsInput | number
    list_id?: IntFieldUpdateOperationsInput | number
    dictionary_id?: IntFieldUpdateOperationsInput | number
    code?: NullableStringFieldUpdateOperationsInput | string | null
    listitem_value?: NullableStringFieldUpdateOperationsInput | string | null
    parent_id?: NullableIntFieldUpdateOperationsInput | number | null
    value?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EntityDetailCreateManyEntityInput = {
    entity_detail_id?: string
    establishment?: Date | string | null
    capital?: number | null
    numberof_employees?: number | null
    business_performance?: NullableJsonNullValueInput | InputJsonValue
    representative_telephone?: string | null
    representative?: string | null
    average_age?: number | null
    foreign_capitalratio?: number | null
    homepage?: string | null
    business_summary?: string | null
    organizational_structure?: string | null
    company_sales?: string | null
    workplace_environment?: string | null
    shareholder?: NullableJsonNullValueInput | InputJsonValue
    related_company?: number | null
    recruitment_personname?: string | null
    memo?: string | null
    business_status?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: string | null
    updated_by?: string | null
  }

  export type EntityBranchCreateManyEntityInput = {
    branch_id?: number
    branch_name?: string | null
    kana?: string | null
    is_jeadquarter?: boolean
    image?: string | null
    prefecture?: NullableJsonNullValueInput | InputJsonValue
    post_code?: string | null
    city?: string | null
    district?: string | null
    address?: string | null
    address1?: string | null
    nearest_station?: string | null
    socials?: NullableJsonNullValueInput | InputJsonValue
    gps?: NullableJsonNullValueInput | InputJsonValue
    contact_person?: NullableJsonNullValueInput | InputJsonValue
    contact_details?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: string | null
    updated_by?: string | null
  }

  export type EntityAccountInfoCreateManyEntityInput = {
    entity_accountinfo_id?: string
    bank_code?: string | null
    branch_code?: string | null
    account_id?: string | null
    is_default?: boolean | null
    created_at?: Date | string
    updated_at?: Date | string
    updated_by?: string | null
    created_by?: string | null
  }

  export type InquiryCreateManyEntityInput = {
    inquire_id?: string
    parent_id?: string | null
    fromuser_id?: string | null
    assigned_user_id?: string | null
    subject: string
    body: string
    inquiry_status?: InquiryStatus | null
    is_read?: boolean
    is_answer?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: string | null
  }

  export type EntityDetailUpdateWithoutEntityInput = {
    entity_detail_id?: StringFieldUpdateOperationsInput | string
    establishment?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    capital?: NullableIntFieldUpdateOperationsInput | number | null
    numberof_employees?: NullableIntFieldUpdateOperationsInput | number | null
    business_performance?: NullableJsonNullValueInput | InputJsonValue
    representative_telephone?: NullableStringFieldUpdateOperationsInput | string | null
    representative?: NullableStringFieldUpdateOperationsInput | string | null
    average_age?: NullableIntFieldUpdateOperationsInput | number | null
    foreign_capitalratio?: NullableIntFieldUpdateOperationsInput | number | null
    homepage?: NullableStringFieldUpdateOperationsInput | string | null
    business_summary?: NullableStringFieldUpdateOperationsInput | string | null
    organizational_structure?: NullableStringFieldUpdateOperationsInput | string | null
    company_sales?: NullableStringFieldUpdateOperationsInput | string | null
    workplace_environment?: NullableStringFieldUpdateOperationsInput | string | null
    shareholder?: NullableJsonNullValueInput | InputJsonValue
    related_company?: NullableIntFieldUpdateOperationsInput | number | null
    recruitment_personname?: NullableStringFieldUpdateOperationsInput | string | null
    memo?: NullableStringFieldUpdateOperationsInput | string | null
    business_status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EntityDetailUncheckedUpdateWithoutEntityInput = {
    entity_detail_id?: StringFieldUpdateOperationsInput | string
    establishment?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    capital?: NullableIntFieldUpdateOperationsInput | number | null
    numberof_employees?: NullableIntFieldUpdateOperationsInput | number | null
    business_performance?: NullableJsonNullValueInput | InputJsonValue
    representative_telephone?: NullableStringFieldUpdateOperationsInput | string | null
    representative?: NullableStringFieldUpdateOperationsInput | string | null
    average_age?: NullableIntFieldUpdateOperationsInput | number | null
    foreign_capitalratio?: NullableIntFieldUpdateOperationsInput | number | null
    homepage?: NullableStringFieldUpdateOperationsInput | string | null
    business_summary?: NullableStringFieldUpdateOperationsInput | string | null
    organizational_structure?: NullableStringFieldUpdateOperationsInput | string | null
    company_sales?: NullableStringFieldUpdateOperationsInput | string | null
    workplace_environment?: NullableStringFieldUpdateOperationsInput | string | null
    shareholder?: NullableJsonNullValueInput | InputJsonValue
    related_company?: NullableIntFieldUpdateOperationsInput | number | null
    recruitment_personname?: NullableStringFieldUpdateOperationsInput | string | null
    memo?: NullableStringFieldUpdateOperationsInput | string | null
    business_status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EntityDetailUncheckedUpdateManyWithoutEntity_detailsInput = {
    entity_detail_id?: StringFieldUpdateOperationsInput | string
    establishment?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    capital?: NullableIntFieldUpdateOperationsInput | number | null
    numberof_employees?: NullableIntFieldUpdateOperationsInput | number | null
    business_performance?: NullableJsonNullValueInput | InputJsonValue
    representative_telephone?: NullableStringFieldUpdateOperationsInput | string | null
    representative?: NullableStringFieldUpdateOperationsInput | string | null
    average_age?: NullableIntFieldUpdateOperationsInput | number | null
    foreign_capitalratio?: NullableIntFieldUpdateOperationsInput | number | null
    homepage?: NullableStringFieldUpdateOperationsInput | string | null
    business_summary?: NullableStringFieldUpdateOperationsInput | string | null
    organizational_structure?: NullableStringFieldUpdateOperationsInput | string | null
    company_sales?: NullableStringFieldUpdateOperationsInput | string | null
    workplace_environment?: NullableStringFieldUpdateOperationsInput | string | null
    shareholder?: NullableJsonNullValueInput | InputJsonValue
    related_company?: NullableIntFieldUpdateOperationsInput | number | null
    recruitment_personname?: NullableStringFieldUpdateOperationsInput | string | null
    memo?: NullableStringFieldUpdateOperationsInput | string | null
    business_status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EntityBranchUpdateWithoutEntityInput = {
    branch_name?: NullableStringFieldUpdateOperationsInput | string | null
    kana?: NullableStringFieldUpdateOperationsInput | string | null
    is_jeadquarter?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    prefecture?: NullableJsonNullValueInput | InputJsonValue
    post_code?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    address1?: NullableStringFieldUpdateOperationsInput | string | null
    nearest_station?: NullableStringFieldUpdateOperationsInput | string | null
    socials?: NullableJsonNullValueInput | InputJsonValue
    gps?: NullableJsonNullValueInput | InputJsonValue
    contact_person?: NullableJsonNullValueInput | InputJsonValue
    contact_details?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    jobs?: JobUpdateManyWithoutEntity_branchNestedInput
  }

  export type EntityBranchUncheckedUpdateWithoutEntityInput = {
    branch_id?: IntFieldUpdateOperationsInput | number
    branch_name?: NullableStringFieldUpdateOperationsInput | string | null
    kana?: NullableStringFieldUpdateOperationsInput | string | null
    is_jeadquarter?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    prefecture?: NullableJsonNullValueInput | InputJsonValue
    post_code?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    address1?: NullableStringFieldUpdateOperationsInput | string | null
    nearest_station?: NullableStringFieldUpdateOperationsInput | string | null
    socials?: NullableJsonNullValueInput | InputJsonValue
    gps?: NullableJsonNullValueInput | InputJsonValue
    contact_person?: NullableJsonNullValueInput | InputJsonValue
    contact_details?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    jobs?: JobUncheckedUpdateManyWithoutEntity_branchNestedInput
  }

  export type EntityBranchUncheckedUpdateManyWithoutEntity_branchesInput = {
    branch_id?: IntFieldUpdateOperationsInput | number
    branch_name?: NullableStringFieldUpdateOperationsInput | string | null
    kana?: NullableStringFieldUpdateOperationsInput | string | null
    is_jeadquarter?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    prefecture?: NullableJsonNullValueInput | InputJsonValue
    post_code?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    address1?: NullableStringFieldUpdateOperationsInput | string | null
    nearest_station?: NullableStringFieldUpdateOperationsInput | string | null
    socials?: NullableJsonNullValueInput | InputJsonValue
    gps?: NullableJsonNullValueInput | InputJsonValue
    contact_person?: NullableJsonNullValueInput | InputJsonValue
    contact_details?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EntityAccountInfoUpdateWithoutEntityInput = {
    entity_accountinfo_id?: StringFieldUpdateOperationsInput | string
    bank_code?: NullableStringFieldUpdateOperationsInput | string | null
    branch_code?: NullableStringFieldUpdateOperationsInput | string | null
    account_id?: NullableStringFieldUpdateOperationsInput | string | null
    is_default?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EntityAccountInfoUncheckedUpdateWithoutEntityInput = {
    entity_accountinfo_id?: StringFieldUpdateOperationsInput | string
    bank_code?: NullableStringFieldUpdateOperationsInput | string | null
    branch_code?: NullableStringFieldUpdateOperationsInput | string | null
    account_id?: NullableStringFieldUpdateOperationsInput | string | null
    is_default?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EntityAccountInfoUncheckedUpdateManyWithoutEntity_accountinfosInput = {
    entity_accountinfo_id?: StringFieldUpdateOperationsInput | string
    bank_code?: NullableStringFieldUpdateOperationsInput | string | null
    branch_code?: NullableStringFieldUpdateOperationsInput | string | null
    account_id?: NullableStringFieldUpdateOperationsInput | string | null
    is_default?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InquiryUpdateWithoutEntityInput = {
    inquire_id?: StringFieldUpdateOperationsInput | string
    parent_id?: NullableStringFieldUpdateOperationsInput | string | null
    fromuser?: UserUpdateOneWithoutFrom_inquiriesNestedInput
    assignUser?: UserUpdateOneWithoutAssign_inquiriesNestedInput
    subject?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    inquiry_status?: NullableEnumInquiryStatusFieldUpdateOperationsInput | InquiryStatus | null
    is_read?: BoolFieldUpdateOperationsInput | boolean
    is_answer?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InquiryUncheckedUpdateWithoutEntityInput = {
    inquire_id?: StringFieldUpdateOperationsInput | string
    parent_id?: NullableStringFieldUpdateOperationsInput | string | null
    fromuser_id?: NullableStringFieldUpdateOperationsInput | string | null
    assigned_user_id?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    inquiry_status?: NullableEnumInquiryStatusFieldUpdateOperationsInput | InquiryStatus | null
    is_read?: BoolFieldUpdateOperationsInput | boolean
    is_answer?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InquiryUncheckedUpdateManyWithoutInquiriesInput = {
    inquire_id?: StringFieldUpdateOperationsInput | string
    parent_id?: NullableStringFieldUpdateOperationsInput | string | null
    fromuser_id?: NullableStringFieldUpdateOperationsInput | string | null
    assigned_user_id?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    inquiry_status?: NullableEnumInquiryStatusFieldUpdateOperationsInput | InquiryStatus | null
    is_read?: BoolFieldUpdateOperationsInput | boolean
    is_answer?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type JobCreateManyEntity_branchInput = {
    job_id?: string
    created_at?: Date | string
    updated_at?: Date | string
    created_by: string
    updated_by?: string | null
    job_publish: JobPublish
    location_details?: string | null
    career_level?: JobCreatecareer_levelInput | Enumerable<JobPosition>
    benefit_other?: string | null
    smoke?: JobCreatesmokeInput | Enumerable<Smoke>
    employment_status: EmploymentStatus
    japanese_level: LanguageLevel
    english_level: LanguageLevel
    experienced_count: number
    age_min?: number | null
    age_max?: number | null
    set_age_reason?: string | null
    recruitment_type?: ReqriutmentType | null
    job_title: string
    job_description: string
    japanese_percentage?: number | null
    must_condition: string
    want_condition?: string | null
    position_name?: string | null
    working_hour: string
    salary_type: SalaryType
    salary_min?: number | null
    salary_max?: number | null
    salary_detail: string
    day_off?: string | null
    progress_detail: string
    expire_date?: Date | string | null
  }

  export type JobUpdateWithoutEntity_branchInput = {
    job_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    job_publish?: EnumJobPublishFieldUpdateOperationsInput | JobPublish
    job_references?: JobReferenceListUpdateManyWithoutJobNestedInput
    location_details?: NullableStringFieldUpdateOperationsInput | string | null
    career_level?: JobUpdatecareer_levelInput | Enumerable<JobPosition>
    benefit_other?: NullableStringFieldUpdateOperationsInput | string | null
    smoke?: JobUpdatesmokeInput | Enumerable<Smoke>
    employment_status?: EnumEmploymentStatusFieldUpdateOperationsInput | EmploymentStatus
    japanese_level?: EnumLanguageLevelFieldUpdateOperationsInput | LanguageLevel
    english_level?: EnumLanguageLevelFieldUpdateOperationsInput | LanguageLevel
    job_other_languages?: JobOtherLanguageUpdateManyWithoutJobNestedInput
    experienced_count?: IntFieldUpdateOperationsInput | number
    age_min?: NullableIntFieldUpdateOperationsInput | number | null
    age_max?: NullableIntFieldUpdateOperationsInput | number | null
    set_age_reason?: NullableStringFieldUpdateOperationsInput | string | null
    recruitment_type?: NullableEnumReqriutmentTypeFieldUpdateOperationsInput | ReqriutmentType | null
    job_title?: StringFieldUpdateOperationsInput | string
    job_description?: StringFieldUpdateOperationsInput | string
    japanese_percentage?: NullableIntFieldUpdateOperationsInput | number | null
    must_condition?: StringFieldUpdateOperationsInput | string
    want_condition?: NullableStringFieldUpdateOperationsInput | string | null
    position_name?: NullableStringFieldUpdateOperationsInput | string | null
    working_hour?: StringFieldUpdateOperationsInput | string
    salary_type?: EnumSalaryTypeFieldUpdateOperationsInput | SalaryType
    salary_min?: NullableIntFieldUpdateOperationsInput | number | null
    salary_max?: NullableIntFieldUpdateOperationsInput | number | null
    salary_detail?: StringFieldUpdateOperationsInput | string
    day_off?: NullableStringFieldUpdateOperationsInput | string | null
    progress_detail?: StringFieldUpdateOperationsInput | string
    expire_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    job_candidates?: JobCandidateUpdateManyWithoutJobNestedInput
    JobRequirement?: JobRequirementUpdateManyWithoutJobsNestedInput
  }

  export type JobUncheckedUpdateWithoutEntity_branchInput = {
    job_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    job_publish?: EnumJobPublishFieldUpdateOperationsInput | JobPublish
    job_references?: JobReferenceListUncheckedUpdateManyWithoutJobNestedInput
    location_details?: NullableStringFieldUpdateOperationsInput | string | null
    career_level?: JobUpdatecareer_levelInput | Enumerable<JobPosition>
    benefit_other?: NullableStringFieldUpdateOperationsInput | string | null
    smoke?: JobUpdatesmokeInput | Enumerable<Smoke>
    employment_status?: EnumEmploymentStatusFieldUpdateOperationsInput | EmploymentStatus
    japanese_level?: EnumLanguageLevelFieldUpdateOperationsInput | LanguageLevel
    english_level?: EnumLanguageLevelFieldUpdateOperationsInput | LanguageLevel
    job_other_languages?: JobOtherLanguageUncheckedUpdateManyWithoutJobNestedInput
    experienced_count?: IntFieldUpdateOperationsInput | number
    age_min?: NullableIntFieldUpdateOperationsInput | number | null
    age_max?: NullableIntFieldUpdateOperationsInput | number | null
    set_age_reason?: NullableStringFieldUpdateOperationsInput | string | null
    recruitment_type?: NullableEnumReqriutmentTypeFieldUpdateOperationsInput | ReqriutmentType | null
    job_title?: StringFieldUpdateOperationsInput | string
    job_description?: StringFieldUpdateOperationsInput | string
    japanese_percentage?: NullableIntFieldUpdateOperationsInput | number | null
    must_condition?: StringFieldUpdateOperationsInput | string
    want_condition?: NullableStringFieldUpdateOperationsInput | string | null
    position_name?: NullableStringFieldUpdateOperationsInput | string | null
    working_hour?: StringFieldUpdateOperationsInput | string
    salary_type?: EnumSalaryTypeFieldUpdateOperationsInput | SalaryType
    salary_min?: NullableIntFieldUpdateOperationsInput | number | null
    salary_max?: NullableIntFieldUpdateOperationsInput | number | null
    salary_detail?: StringFieldUpdateOperationsInput | string
    day_off?: NullableStringFieldUpdateOperationsInput | string | null
    progress_detail?: StringFieldUpdateOperationsInput | string
    expire_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    job_candidates?: JobCandidateUncheckedUpdateManyWithoutJobNestedInput
    JobRequirement?: JobRequirementUncheckedUpdateManyWithoutJobsNestedInput
  }

  export type JobUncheckedUpdateManyWithoutJobsInput = {
    job_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    job_publish?: EnumJobPublishFieldUpdateOperationsInput | JobPublish
    location_details?: NullableStringFieldUpdateOperationsInput | string | null
    career_level?: JobUpdatecareer_levelInput | Enumerable<JobPosition>
    benefit_other?: NullableStringFieldUpdateOperationsInput | string | null
    smoke?: JobUpdatesmokeInput | Enumerable<Smoke>
    employment_status?: EnumEmploymentStatusFieldUpdateOperationsInput | EmploymentStatus
    japanese_level?: EnumLanguageLevelFieldUpdateOperationsInput | LanguageLevel
    english_level?: EnumLanguageLevelFieldUpdateOperationsInput | LanguageLevel
    experienced_count?: IntFieldUpdateOperationsInput | number
    age_min?: NullableIntFieldUpdateOperationsInput | number | null
    age_max?: NullableIntFieldUpdateOperationsInput | number | null
    set_age_reason?: NullableStringFieldUpdateOperationsInput | string | null
    recruitment_type?: NullableEnumReqriutmentTypeFieldUpdateOperationsInput | ReqriutmentType | null
    job_title?: StringFieldUpdateOperationsInput | string
    job_description?: StringFieldUpdateOperationsInput | string
    japanese_percentage?: NullableIntFieldUpdateOperationsInput | number | null
    must_condition?: StringFieldUpdateOperationsInput | string
    want_condition?: NullableStringFieldUpdateOperationsInput | string | null
    position_name?: NullableStringFieldUpdateOperationsInput | string | null
    working_hour?: StringFieldUpdateOperationsInput | string
    salary_type?: EnumSalaryTypeFieldUpdateOperationsInput | SalaryType
    salary_min?: NullableIntFieldUpdateOperationsInput | number | null
    salary_max?: NullableIntFieldUpdateOperationsInput | number | null
    salary_detail?: StringFieldUpdateOperationsInput | string
    day_off?: NullableStringFieldUpdateOperationsInput | string | null
    progress_detail?: StringFieldUpdateOperationsInput | string
    expire_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type JobReferenceListCreateManyJobInput = {
    job_reference_id?: string
    reference_list_id: number
    reference_list_item_id: number
  }

  export type JobOtherLanguageCreateManyJobInput = {
    job_other_language_id?: string
    language_id: number
    language_level: LanguageLevel
  }

  export type JobCandidateCreateManyJobInput = {
    job_candidate_id?: string
    customer_id: string
    candidate_status: number
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: string | null
    updated_by?: string | null
  }

  export type JobRequirementCreateManyJobsInput = {
    job_require_id?: string
    require_id: number
    require_detial?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: string | null
    updated_by?: string | null
  }

  export type JobReferenceListUpdateWithoutJobInput = {
    job_reference_id?: StringFieldUpdateOperationsInput | string
    reference_list?: ReferenceListUpdateOneRequiredWithoutJobReferenceListNestedInput
    reference_list_item?: ReferenceListItemsUpdateOneRequiredWithoutJobReferenceListNestedInput
  }

  export type JobReferenceListUncheckedUpdateWithoutJobInput = {
    job_reference_id?: StringFieldUpdateOperationsInput | string
    reference_list_id?: IntFieldUpdateOperationsInput | number
    reference_list_item_id?: IntFieldUpdateOperationsInput | number
  }

  export type JobReferenceListUncheckedUpdateManyWithoutJob_referencesInput = {
    job_reference_id?: StringFieldUpdateOperationsInput | string
    reference_list_id?: IntFieldUpdateOperationsInput | number
    reference_list_item_id?: IntFieldUpdateOperationsInput | number
  }

  export type JobOtherLanguageUpdateWithoutJobInput = {
    job_other_language_id?: StringFieldUpdateOperationsInput | string
    language_id?: IntFieldUpdateOperationsInput | number
    language_level?: EnumLanguageLevelFieldUpdateOperationsInput | LanguageLevel
  }

  export type JobOtherLanguageUncheckedUpdateWithoutJobInput = {
    job_other_language_id?: StringFieldUpdateOperationsInput | string
    language_id?: IntFieldUpdateOperationsInput | number
    language_level?: EnumLanguageLevelFieldUpdateOperationsInput | LanguageLevel
  }

  export type JobOtherLanguageUncheckedUpdateManyWithoutJob_other_languagesInput = {
    job_other_language_id?: StringFieldUpdateOperationsInput | string
    language_id?: IntFieldUpdateOperationsInput | number
    language_level?: EnumLanguageLevelFieldUpdateOperationsInput | LanguageLevel
  }

  export type JobCandidateUpdateWithoutJobInput = {
    job_candidate_id?: StringFieldUpdateOperationsInput | string
    customer?: CustomerUpdateOneRequiredWithoutJob_candidatesNestedInput
    candidate_status?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type JobCandidateUncheckedUpdateWithoutJobInput = {
    job_candidate_id?: StringFieldUpdateOperationsInput | string
    customer_id?: StringFieldUpdateOperationsInput | string
    candidate_status?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type JobRequirementUpdateWithoutJobsInput = {
    job_require_id?: StringFieldUpdateOperationsInput | string
    require_id?: IntFieldUpdateOperationsInput | number
    require_detial?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type JobRequirementUncheckedUpdateWithoutJobsInput = {
    job_require_id?: StringFieldUpdateOperationsInput | string
    require_id?: IntFieldUpdateOperationsInput | number
    require_detial?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type JobRequirementUncheckedUpdateManyWithoutJobRequirementInput = {
    job_require_id?: StringFieldUpdateOperationsInput | string
    require_id?: IntFieldUpdateOperationsInput | number
    require_detial?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NewsCreateManyPagesInput = {
    news_id?: string
    title: string
    brief: string
    image_id: string
    content: string
    is_top?: boolean
    is_publish?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    created_by: string
    update_by: string
  }

  export type NewsUpdateWithoutPagesInput = {
    news_id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    brief?: StringFieldUpdateOperationsInput | string
    image_id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    is_top?: BoolFieldUpdateOperationsInput | boolean
    is_publish?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: StringFieldUpdateOperationsInput | string
    update_by?: StringFieldUpdateOperationsInput | string
  }

  export type NewsUncheckedUpdateWithoutPagesInput = {
    news_id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    brief?: StringFieldUpdateOperationsInput | string
    image_id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    is_top?: BoolFieldUpdateOperationsInput | boolean
    is_publish?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: StringFieldUpdateOperationsInput | string
    update_by?: StringFieldUpdateOperationsInput | string
  }

  export type NewsUncheckedUpdateManyWithoutNewsInput = {
    news_id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    brief?: StringFieldUpdateOperationsInput | string
    image_id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    is_top?: BoolFieldUpdateOperationsInput | boolean
    is_publish?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: StringFieldUpdateOperationsInput | string
    update_by?: StringFieldUpdateOperationsInput | string
  }

  export type ReferenceListItemsCreateManyListInput = {
    listitem_id?: number
    dictionary_id: number
    code?: string | null
    listitem_value?: string | null
    parent_id?: number | null
    value?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    dictionaryDictionaries_id?: string | null
  }

  export type JobReferenceListCreateManyReference_listInput = {
    job_reference_id?: string
    job_id: string
    reference_list_item_id: number
  }

  export type ReferenceListItemsUpdateWithoutListInput = {
    dictionary_id?: IntFieldUpdateOperationsInput | number
    code?: NullableStringFieldUpdateOperationsInput | string | null
    listitem_value?: NullableStringFieldUpdateOperationsInput | string | null
    parent_id?: NullableIntFieldUpdateOperationsInput | number | null
    value?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    customer_experiences?: CustomerExperienceUpdateManyWithoutListitemsNestedInput
    Dictionary?: DictionaryUpdateOneWithoutReference_listitemsNestedInput
    JobReferenceList?: JobReferenceListUpdateManyWithoutReference_list_itemNestedInput
  }

  export type ReferenceListItemsUncheckedUpdateWithoutListInput = {
    listitem_id?: IntFieldUpdateOperationsInput | number
    dictionary_id?: IntFieldUpdateOperationsInput | number
    code?: NullableStringFieldUpdateOperationsInput | string | null
    listitem_value?: NullableStringFieldUpdateOperationsInput | string | null
    parent_id?: NullableIntFieldUpdateOperationsInput | number | null
    value?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    customer_experiences?: CustomerExperienceUncheckedUpdateManyWithoutListitemsNestedInput
    dictionaryDictionaries_id?: NullableStringFieldUpdateOperationsInput | string | null
    JobReferenceList?: JobReferenceListUncheckedUpdateManyWithoutReference_list_itemNestedInput
  }

  export type ReferenceListItemsUncheckedUpdateManyWithoutListitemsInput = {
    listitem_id?: IntFieldUpdateOperationsInput | number
    dictionary_id?: IntFieldUpdateOperationsInput | number
    code?: NullableStringFieldUpdateOperationsInput | string | null
    listitem_value?: NullableStringFieldUpdateOperationsInput | string | null
    parent_id?: NullableIntFieldUpdateOperationsInput | number | null
    value?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    dictionaryDictionaries_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type JobReferenceListUpdateWithoutReference_listInput = {
    job_reference_id?: StringFieldUpdateOperationsInput | string
    job?: JobUpdateOneRequiredWithoutJob_referencesNestedInput
    reference_list_item?: ReferenceListItemsUpdateOneRequiredWithoutJobReferenceListNestedInput
  }

  export type JobReferenceListUncheckedUpdateWithoutReference_listInput = {
    job_reference_id?: StringFieldUpdateOperationsInput | string
    job_id?: StringFieldUpdateOperationsInput | string
    reference_list_item_id?: IntFieldUpdateOperationsInput | number
  }

  export type JobReferenceListUncheckedUpdateManyWithoutJobReferenceListInput = {
    job_reference_id?: StringFieldUpdateOperationsInput | string
    job_id?: StringFieldUpdateOperationsInput | string
    reference_list_item_id?: IntFieldUpdateOperationsInput | number
  }

  export type CustomerExperienceCreateManyListitemsInput = {
    experience_id?: string
    jobdetail_id: string
    over_year?: number | null
    created_at?: Date | string
    updated_at?: Date | string | null
    created_by?: string | null
    updated_by?: string | null
  }

  export type JobReferenceListCreateManyReference_list_itemInput = {
    job_reference_id?: string
    job_id: string
    reference_list_id: number
  }

  export type CustomerExperienceUpdateWithoutListitemsInput = {
    experience_id?: StringFieldUpdateOperationsInput | string
    jobdetails?: CustomerJobDetailUpdateOneRequiredWithoutCustomer_experiencesNestedInput
    over_year?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CustomerExperienceUncheckedUpdateWithoutListitemsInput = {
    experience_id?: StringFieldUpdateOperationsInput | string
    jobdetail_id?: StringFieldUpdateOperationsInput | string
    over_year?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type JobReferenceListUpdateWithoutReference_list_itemInput = {
    job_reference_id?: StringFieldUpdateOperationsInput | string
    job?: JobUpdateOneRequiredWithoutJob_referencesNestedInput
    reference_list?: ReferenceListUpdateOneRequiredWithoutJobReferenceListNestedInput
  }

  export type JobReferenceListUncheckedUpdateWithoutReference_list_itemInput = {
    job_reference_id?: StringFieldUpdateOperationsInput | string
    job_id?: StringFieldUpdateOperationsInput | string
    reference_list_id?: IntFieldUpdateOperationsInput | number
  }

  export type LoggerCreateManyUserInput = {
    log_id?: string
    action_user?: UserAction
    new_value?: NullableJsonNullValueInput | InputJsonValue
    old_value?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: string | null
    updated_by?: string | null
  }

  export type InquiryCreateManyFromuserInput = {
    inquire_id?: string
    parent_id?: string | null
    entity_id?: number | null
    assigned_user_id?: string | null
    subject: string
    body: string
    inquiry_status?: InquiryStatus | null
    is_read?: boolean
    is_answer?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: string | null
  }

  export type InquiryCreateManyAssignUserInput = {
    inquire_id?: string
    parent_id?: string | null
    fromuser_id?: string | null
    entity_id?: number | null
    subject: string
    body: string
    inquiry_status?: InquiryStatus | null
    is_read?: boolean
    is_answer?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: string | null
  }

  export type NotificationCreateManyUserInput = {
    notifiation_id?: string
    link: string
    message: string
    is_new?: boolean
    is_badge?: boolean
    created_at?: Date | string
    created_by: string
  }

  export type ScoutFavCreateManyUserInput = {
    scout_id?: string
    entity_id?: number | null
    branch_id?: number | null
    job_id?: string | null
    note: string
    created_at?: Date | string
    created_by: string
  }

  export type LoggerUpdateWithoutUserInput = {
    log_id?: StringFieldUpdateOperationsInput | string
    action_user?: EnumUserActionFieldUpdateOperationsInput | UserAction
    new_value?: NullableJsonNullValueInput | InputJsonValue
    old_value?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LoggerUncheckedUpdateWithoutUserInput = {
    log_id?: StringFieldUpdateOperationsInput | string
    action_user?: EnumUserActionFieldUpdateOperationsInput | UserAction
    new_value?: NullableJsonNullValueInput | InputJsonValue
    old_value?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LoggerUncheckedUpdateManyWithoutLoggersInput = {
    log_id?: StringFieldUpdateOperationsInput | string
    action_user?: EnumUserActionFieldUpdateOperationsInput | UserAction
    new_value?: NullableJsonNullValueInput | InputJsonValue
    old_value?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InquiryUpdateWithoutFromuserInput = {
    inquire_id?: StringFieldUpdateOperationsInput | string
    parent_id?: NullableStringFieldUpdateOperationsInput | string | null
    entity?: EntityUpdateOneWithoutInquiriesNestedInput
    assignUser?: UserUpdateOneWithoutAssign_inquiriesNestedInput
    subject?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    inquiry_status?: NullableEnumInquiryStatusFieldUpdateOperationsInput | InquiryStatus | null
    is_read?: BoolFieldUpdateOperationsInput | boolean
    is_answer?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InquiryUncheckedUpdateWithoutFromuserInput = {
    inquire_id?: StringFieldUpdateOperationsInput | string
    parent_id?: NullableStringFieldUpdateOperationsInput | string | null
    entity_id?: NullableIntFieldUpdateOperationsInput | number | null
    assigned_user_id?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    inquiry_status?: NullableEnumInquiryStatusFieldUpdateOperationsInput | InquiryStatus | null
    is_read?: BoolFieldUpdateOperationsInput | boolean
    is_answer?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InquiryUncheckedUpdateManyWithoutFrom_inquiriesInput = {
    inquire_id?: StringFieldUpdateOperationsInput | string
    parent_id?: NullableStringFieldUpdateOperationsInput | string | null
    entity_id?: NullableIntFieldUpdateOperationsInput | number | null
    assigned_user_id?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    inquiry_status?: NullableEnumInquiryStatusFieldUpdateOperationsInput | InquiryStatus | null
    is_read?: BoolFieldUpdateOperationsInput | boolean
    is_answer?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InquiryUpdateWithoutAssignUserInput = {
    inquire_id?: StringFieldUpdateOperationsInput | string
    parent_id?: NullableStringFieldUpdateOperationsInput | string | null
    fromuser?: UserUpdateOneWithoutFrom_inquiriesNestedInput
    entity?: EntityUpdateOneWithoutInquiriesNestedInput
    subject?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    inquiry_status?: NullableEnumInquiryStatusFieldUpdateOperationsInput | InquiryStatus | null
    is_read?: BoolFieldUpdateOperationsInput | boolean
    is_answer?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InquiryUncheckedUpdateWithoutAssignUserInput = {
    inquire_id?: StringFieldUpdateOperationsInput | string
    parent_id?: NullableStringFieldUpdateOperationsInput | string | null
    fromuser_id?: NullableStringFieldUpdateOperationsInput | string | null
    entity_id?: NullableIntFieldUpdateOperationsInput | number | null
    subject?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    inquiry_status?: NullableEnumInquiryStatusFieldUpdateOperationsInput | InquiryStatus | null
    is_read?: BoolFieldUpdateOperationsInput | boolean
    is_answer?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InquiryUncheckedUpdateManyWithoutAssign_inquiriesInput = {
    inquire_id?: StringFieldUpdateOperationsInput | string
    parent_id?: NullableStringFieldUpdateOperationsInput | string | null
    fromuser_id?: NullableStringFieldUpdateOperationsInput | string | null
    entity_id?: NullableIntFieldUpdateOperationsInput | number | null
    subject?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    inquiry_status?: NullableEnumInquiryStatusFieldUpdateOperationsInput | InquiryStatus | null
    is_read?: BoolFieldUpdateOperationsInput | boolean
    is_answer?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NotificationUpdateWithoutUserInput = {
    notifiation_id?: StringFieldUpdateOperationsInput | string
    link?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    is_new?: BoolFieldUpdateOperationsInput | boolean
    is_badge?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: StringFieldUpdateOperationsInput | string
  }

  export type NotificationUncheckedUpdateWithoutUserInput = {
    notifiation_id?: StringFieldUpdateOperationsInput | string
    link?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    is_new?: BoolFieldUpdateOperationsInput | boolean
    is_badge?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: StringFieldUpdateOperationsInput | string
  }

  export type NotificationUncheckedUpdateManyWithoutNotificationsInput = {
    notifiation_id?: StringFieldUpdateOperationsInput | string
    link?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    is_new?: BoolFieldUpdateOperationsInput | boolean
    is_badge?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: StringFieldUpdateOperationsInput | string
  }

  export type ScoutFavUpdateWithoutUserInput = {
    scout_id?: StringFieldUpdateOperationsInput | string
    entity_id?: NullableIntFieldUpdateOperationsInput | number | null
    branch_id?: NullableIntFieldUpdateOperationsInput | number | null
    job_id?: NullableStringFieldUpdateOperationsInput | string | null
    note?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: StringFieldUpdateOperationsInput | string
  }

  export type ScoutFavUncheckedUpdateWithoutUserInput = {
    scout_id?: StringFieldUpdateOperationsInput | string
    entity_id?: NullableIntFieldUpdateOperationsInput | number | null
    branch_id?: NullableIntFieldUpdateOperationsInput | number | null
    job_id?: NullableStringFieldUpdateOperationsInput | string | null
    note?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: StringFieldUpdateOperationsInput | string
  }

  export type ScoutFavUncheckedUpdateManyWithoutScoutFavInput = {
    scout_id?: StringFieldUpdateOperationsInput | string
    entity_id?: NullableIntFieldUpdateOperationsInput | number | null
    branch_id?: NullableIntFieldUpdateOperationsInput | number | null
    job_id?: NullableStringFieldUpdateOperationsInput | string | null
    note?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: StringFieldUpdateOperationsInput | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}